
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserInventoryItem
 * 
 */
export type UserInventoryItem = $Result.DefaultSelection<Prisma.$UserInventoryItemPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model Challenge
 * 
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>
/**
 * Model ChallengeParticipant
 * 
 */
export type ChallengeParticipant = $Result.DefaultSelection<Prisma.$ChallengeParticipantPayload>
/**
 * Model ProgressLog
 * 
 */
export type ProgressLog = $Result.DefaultSelection<Prisma.$ProgressLogPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>
/**
 * Model HabitCategory
 * 
 */
export type HabitCategory = $Result.DefaultSelection<Prisma.$HabitCategoryPayload>
/**
 * Model Habit
 * 
 */
export type Habit = $Result.DefaultSelection<Prisma.$HabitPayload>
/**
 * Model HabitUserSettings
 * 
 */
export type HabitUserSettings = $Result.DefaultSelection<Prisma.$HabitUserSettingsPayload>
/**
 * Model HabitProof
 * 
 */
export type HabitProof = $Result.DefaultSelection<Prisma.$HabitProofPayload>
/**
 * Model ProofVote
 * 
 */
export type ProofVote = $Result.DefaultSelection<Prisma.$ProofVotePayload>
/**
 * Model Friendship
 * 
 */
export type Friendship = $Result.DefaultSelection<Prisma.$FriendshipPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model HabitInvite
 * 
 */
export type HabitInvite = $Result.DefaultSelection<Prisma.$HabitInvitePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userInventoryItem`: Exposes CRUD operations for the **UserInventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInventoryItems
    * const userInventoryItems = await prisma.userInventoryItem.findMany()
    * ```
    */
  get userInventoryItem(): Prisma.UserInventoryItemDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs>;

  /**
   * `prisma.challengeParticipant`: Exposes CRUD operations for the **ChallengeParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeParticipants
    * const challengeParticipants = await prisma.challengeParticipant.findMany()
    * ```
    */
  get challengeParticipant(): Prisma.ChallengeParticipantDelegate<ExtArgs>;

  /**
   * `prisma.progressLog`: Exposes CRUD operations for the **ProgressLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgressLogs
    * const progressLogs = await prisma.progressLog.findMany()
    * ```
    */
  get progressLog(): Prisma.ProgressLogDelegate<ExtArgs>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs>;

  /**
   * `prisma.habitCategory`: Exposes CRUD operations for the **HabitCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HabitCategories
    * const habitCategories = await prisma.habitCategory.findMany()
    * ```
    */
  get habitCategory(): Prisma.HabitCategoryDelegate<ExtArgs>;

  /**
   * `prisma.habit`: Exposes CRUD operations for the **Habit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Habits
    * const habits = await prisma.habit.findMany()
    * ```
    */
  get habit(): Prisma.HabitDelegate<ExtArgs>;

  /**
   * `prisma.habitUserSettings`: Exposes CRUD operations for the **HabitUserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HabitUserSettings
    * const habitUserSettings = await prisma.habitUserSettings.findMany()
    * ```
    */
  get habitUserSettings(): Prisma.HabitUserSettingsDelegate<ExtArgs>;

  /**
   * `prisma.habitProof`: Exposes CRUD operations for the **HabitProof** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HabitProofs
    * const habitProofs = await prisma.habitProof.findMany()
    * ```
    */
  get habitProof(): Prisma.HabitProofDelegate<ExtArgs>;

  /**
   * `prisma.proofVote`: Exposes CRUD operations for the **ProofVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProofVotes
    * const proofVotes = await prisma.proofVote.findMany()
    * ```
    */
  get proofVote(): Prisma.ProofVoteDelegate<ExtArgs>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.FriendshipDelegate<ExtArgs>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs>;

  /**
   * `prisma.habitInvite`: Exposes CRUD operations for the **HabitInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HabitInvites
    * const habitInvites = await prisma.habitInvite.findMany()
    * ```
    */
  get habitInvite(): Prisma.HabitInviteDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserInventoryItem: 'UserInventoryItem',
    Team: 'Team',
    TeamMember: 'TeamMember',
    Challenge: 'Challenge',
    ChallengeParticipant: 'ChallengeParticipant',
    ProgressLog: 'ProgressLog',
    Badge: 'Badge',
    UserBadge: 'UserBadge',
    HabitCategory: 'HabitCategory',
    Habit: 'Habit',
    HabitUserSettings: 'HabitUserSettings',
    HabitProof: 'HabitProof',
    ProofVote: 'ProofVote',
    Friendship: 'Friendship',
    Follow: 'Follow',
    HabitInvite: 'HabitInvite'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "userInventoryItem" | "team" | "teamMember" | "challenge" | "challengeParticipant" | "progressLog" | "badge" | "userBadge" | "habitCategory" | "habit" | "habitUserSettings" | "habitProof" | "proofVote" | "friendship" | "follow" | "habitInvite"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserInventoryItem: {
        payload: Prisma.$UserInventoryItemPayload<ExtArgs>
        fields: Prisma.UserInventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          findFirst: {
            args: Prisma.UserInventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          findMany: {
            args: Prisma.UserInventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>[]
          }
          create: {
            args: Prisma.UserInventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          createMany: {
            args: Prisma.UserInventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>[]
          }
          delete: {
            args: Prisma.UserInventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          update: {
            args: Prisma.UserInventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.UserInventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserInventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          aggregate: {
            args: Prisma.UserInventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInventoryItem>
          }
          groupBy: {
            args: Prisma.UserInventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<UserInventoryItemCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>
        fields: Prisma.ChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge>
          }
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeParticipant: {
        payload: Prisma.$ChallengeParticipantPayload<ExtArgs>
        fields: Prisma.ChallengeParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          findFirst: {
            args: Prisma.ChallengeParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          findMany: {
            args: Prisma.ChallengeParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>[]
          }
          create: {
            args: Prisma.ChallengeParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          createMany: {
            args: Prisma.ChallengeParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>[]
          }
          delete: {
            args: Prisma.ChallengeParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          update: {
            args: Prisma.ChallengeParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          aggregate: {
            args: Prisma.ChallengeParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeParticipant>
          }
          groupBy: {
            args: Prisma.ChallengeParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeParticipantCountAggregateOutputType> | number
          }
        }
      }
      ProgressLog: {
        payload: Prisma.$ProgressLogPayload<ExtArgs>
        fields: Prisma.ProgressLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgressLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgressLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressLogPayload>
          }
          findFirst: {
            args: Prisma.ProgressLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgressLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressLogPayload>
          }
          findMany: {
            args: Prisma.ProgressLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressLogPayload>[]
          }
          create: {
            args: Prisma.ProgressLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressLogPayload>
          }
          createMany: {
            args: Prisma.ProgressLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgressLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressLogPayload>[]
          }
          delete: {
            args: Prisma.ProgressLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressLogPayload>
          }
          update: {
            args: Prisma.ProgressLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressLogPayload>
          }
          deleteMany: {
            args: Prisma.ProgressLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgressLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgressLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgressLogPayload>
          }
          aggregate: {
            args: Prisma.ProgressLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgressLog>
          }
          groupBy: {
            args: Prisma.ProgressLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgressLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgressLogCountArgs<ExtArgs>
            result: $Utils.Optional<ProgressLogCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      HabitCategory: {
        payload: Prisma.$HabitCategoryPayload<ExtArgs>
        fields: Prisma.HabitCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HabitCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HabitCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCategoryPayload>
          }
          findFirst: {
            args: Prisma.HabitCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HabitCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCategoryPayload>
          }
          findMany: {
            args: Prisma.HabitCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCategoryPayload>[]
          }
          create: {
            args: Prisma.HabitCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCategoryPayload>
          }
          createMany: {
            args: Prisma.HabitCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HabitCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCategoryPayload>[]
          }
          delete: {
            args: Prisma.HabitCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCategoryPayload>
          }
          update: {
            args: Prisma.HabitCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCategoryPayload>
          }
          deleteMany: {
            args: Prisma.HabitCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HabitCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HabitCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitCategoryPayload>
          }
          aggregate: {
            args: Prisma.HabitCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabitCategory>
          }
          groupBy: {
            args: Prisma.HabitCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<HabitCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.HabitCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<HabitCategoryCountAggregateOutputType> | number
          }
        }
      }
      Habit: {
        payload: Prisma.$HabitPayload<ExtArgs>
        fields: Prisma.HabitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HabitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HabitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          findFirst: {
            args: Prisma.HabitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HabitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          findMany: {
            args: Prisma.HabitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>[]
          }
          create: {
            args: Prisma.HabitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          createMany: {
            args: Prisma.HabitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HabitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>[]
          }
          delete: {
            args: Prisma.HabitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          update: {
            args: Prisma.HabitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          deleteMany: {
            args: Prisma.HabitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HabitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HabitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitPayload>
          }
          aggregate: {
            args: Prisma.HabitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabit>
          }
          groupBy: {
            args: Prisma.HabitGroupByArgs<ExtArgs>
            result: $Utils.Optional<HabitGroupByOutputType>[]
          }
          count: {
            args: Prisma.HabitCountArgs<ExtArgs>
            result: $Utils.Optional<HabitCountAggregateOutputType> | number
          }
        }
      }
      HabitUserSettings: {
        payload: Prisma.$HabitUserSettingsPayload<ExtArgs>
        fields: Prisma.HabitUserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HabitUserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitUserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HabitUserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitUserSettingsPayload>
          }
          findFirst: {
            args: Prisma.HabitUserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitUserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HabitUserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitUserSettingsPayload>
          }
          findMany: {
            args: Prisma.HabitUserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitUserSettingsPayload>[]
          }
          create: {
            args: Prisma.HabitUserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitUserSettingsPayload>
          }
          createMany: {
            args: Prisma.HabitUserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HabitUserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitUserSettingsPayload>[]
          }
          delete: {
            args: Prisma.HabitUserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitUserSettingsPayload>
          }
          update: {
            args: Prisma.HabitUserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitUserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.HabitUserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HabitUserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HabitUserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitUserSettingsPayload>
          }
          aggregate: {
            args: Prisma.HabitUserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabitUserSettings>
          }
          groupBy: {
            args: Prisma.HabitUserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<HabitUserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.HabitUserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<HabitUserSettingsCountAggregateOutputType> | number
          }
        }
      }
      HabitProof: {
        payload: Prisma.$HabitProofPayload<ExtArgs>
        fields: Prisma.HabitProofFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HabitProofFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitProofPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HabitProofFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitProofPayload>
          }
          findFirst: {
            args: Prisma.HabitProofFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitProofPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HabitProofFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitProofPayload>
          }
          findMany: {
            args: Prisma.HabitProofFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitProofPayload>[]
          }
          create: {
            args: Prisma.HabitProofCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitProofPayload>
          }
          createMany: {
            args: Prisma.HabitProofCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HabitProofCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitProofPayload>[]
          }
          delete: {
            args: Prisma.HabitProofDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitProofPayload>
          }
          update: {
            args: Prisma.HabitProofUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitProofPayload>
          }
          deleteMany: {
            args: Prisma.HabitProofDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HabitProofUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HabitProofUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitProofPayload>
          }
          aggregate: {
            args: Prisma.HabitProofAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabitProof>
          }
          groupBy: {
            args: Prisma.HabitProofGroupByArgs<ExtArgs>
            result: $Utils.Optional<HabitProofGroupByOutputType>[]
          }
          count: {
            args: Prisma.HabitProofCountArgs<ExtArgs>
            result: $Utils.Optional<HabitProofCountAggregateOutputType> | number
          }
        }
      }
      ProofVote: {
        payload: Prisma.$ProofVotePayload<ExtArgs>
        fields: Prisma.ProofVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProofVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProofVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProofVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProofVotePayload>
          }
          findFirst: {
            args: Prisma.ProofVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProofVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProofVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProofVotePayload>
          }
          findMany: {
            args: Prisma.ProofVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProofVotePayload>[]
          }
          create: {
            args: Prisma.ProofVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProofVotePayload>
          }
          createMany: {
            args: Prisma.ProofVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProofVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProofVotePayload>[]
          }
          delete: {
            args: Prisma.ProofVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProofVotePayload>
          }
          update: {
            args: Prisma.ProofVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProofVotePayload>
          }
          deleteMany: {
            args: Prisma.ProofVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProofVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProofVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProofVotePayload>
          }
          aggregate: {
            args: Prisma.ProofVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProofVote>
          }
          groupBy: {
            args: Prisma.ProofVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProofVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProofVoteCountArgs<ExtArgs>
            result: $Utils.Optional<ProofVoteCountAggregateOutputType> | number
          }
        }
      }
      Friendship: {
        payload: Prisma.$FriendshipPayload<ExtArgs>
        fields: Prisma.FriendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findFirst: {
            args: Prisma.FriendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findMany: {
            args: Prisma.FriendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          create: {
            args: Prisma.FriendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          createMany: {
            args: Prisma.FriendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          delete: {
            args: Prisma.FriendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          update: {
            args: Prisma.FriendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          deleteMany: {
            args: Prisma.FriendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FriendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.FriendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      HabitInvite: {
        payload: Prisma.$HabitInvitePayload<ExtArgs>
        fields: Prisma.HabitInviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HabitInviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitInvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HabitInviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitInvitePayload>
          }
          findFirst: {
            args: Prisma.HabitInviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitInvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HabitInviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitInvitePayload>
          }
          findMany: {
            args: Prisma.HabitInviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitInvitePayload>[]
          }
          create: {
            args: Prisma.HabitInviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitInvitePayload>
          }
          createMany: {
            args: Prisma.HabitInviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HabitInviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitInvitePayload>[]
          }
          delete: {
            args: Prisma.HabitInviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitInvitePayload>
          }
          update: {
            args: Prisma.HabitInviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitInvitePayload>
          }
          deleteMany: {
            args: Prisma.HabitInviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HabitInviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HabitInviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HabitInvitePayload>
          }
          aggregate: {
            args: Prisma.HabitInviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabitInvite>
          }
          groupBy: {
            args: Prisma.HabitInviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<HabitInviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.HabitInviteCountArgs<ExtArgs>
            result: $Utils.Optional<HabitInviteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    inventory: number
    teamMembers: number
    participations: number
    progressLogs: number
    badges: number
    createdChallenges: number
    joinedHabits: number
    habitProofs: number
    proofVotes: number
    friends: number
    friendOf: number
    habitInvites: number
    habitSettings: number
    followers: number
    following: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | UserCountOutputTypeCountInventoryArgs
    teamMembers?: boolean | UserCountOutputTypeCountTeamMembersArgs
    participations?: boolean | UserCountOutputTypeCountParticipationsArgs
    progressLogs?: boolean | UserCountOutputTypeCountProgressLogsArgs
    badges?: boolean | UserCountOutputTypeCountBadgesArgs
    createdChallenges?: boolean | UserCountOutputTypeCountCreatedChallengesArgs
    joinedHabits?: boolean | UserCountOutputTypeCountJoinedHabitsArgs
    habitProofs?: boolean | UserCountOutputTypeCountHabitProofsArgs
    proofVotes?: boolean | UserCountOutputTypeCountProofVotesArgs
    friends?: boolean | UserCountOutputTypeCountFriendsArgs
    friendOf?: boolean | UserCountOutputTypeCountFriendOfArgs
    habitInvites?: boolean | UserCountOutputTypeCountHabitInvitesArgs
    habitSettings?: boolean | UserCountOutputTypeCountHabitSettingsArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInventoryItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgressLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJoinedHabitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHabitProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitProofWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProofVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProofVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHabitInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitInviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHabitSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitUserSettingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
    challenges: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    challenges?: boolean | TeamCountOutputTypeCountChallengesArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
  }


  /**
   * Count Type ChallengeCountOutputType
   */

  export type ChallengeCountOutputType = {
    participants: number
    progressLogs: number
  }

  export type ChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ChallengeCountOutputTypeCountParticipantsArgs
    progressLogs?: boolean | ChallengeCountOutputTypeCountProgressLogsArgs
  }

  // Custom InputTypes
  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     */
    select?: ChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeParticipantWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountProgressLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressLogWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    users: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BadgeCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Count Type HabitCategoryCountOutputType
   */

  export type HabitCategoryCountOutputType = {
    habits: number
    activeClimbers: number
  }

  export type HabitCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habits?: boolean | HabitCategoryCountOutputTypeCountHabitsArgs
    activeClimbers?: boolean | HabitCategoryCountOutputTypeCountActiveClimbersArgs
  }

  // Custom InputTypes
  /**
   * HabitCategoryCountOutputType without action
   */
  export type HabitCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategoryCountOutputType
     */
    select?: HabitCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HabitCategoryCountOutputType without action
   */
  export type HabitCategoryCountOutputTypeCountHabitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitWhereInput
  }

  /**
   * HabitCategoryCountOutputType without action
   */
  export type HabitCategoryCountOutputTypeCountActiveClimbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type HabitCountOutputType
   */

  export type HabitCountOutputType = {
    joinedUsers: number
    proofs: number
    invites: number
    userSettings: number
  }

  export type HabitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    joinedUsers?: boolean | HabitCountOutputTypeCountJoinedUsersArgs
    proofs?: boolean | HabitCountOutputTypeCountProofsArgs
    invites?: boolean | HabitCountOutputTypeCountInvitesArgs
    userSettings?: boolean | HabitCountOutputTypeCountUserSettingsArgs
  }

  // Custom InputTypes
  /**
   * HabitCountOutputType without action
   */
  export type HabitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCountOutputType
     */
    select?: HabitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HabitCountOutputType without action
   */
  export type HabitCountOutputTypeCountJoinedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * HabitCountOutputType without action
   */
  export type HabitCountOutputTypeCountProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitProofWhereInput
  }

  /**
   * HabitCountOutputType without action
   */
  export type HabitCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitInviteWhereInput
  }

  /**
   * HabitCountOutputType without action
   */
  export type HabitCountOutputTypeCountUserSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitUserSettingsWhereInput
  }


  /**
   * Count Type HabitProofCountOutputType
   */

  export type HabitProofCountOutputType = {
    votes: number
  }

  export type HabitProofCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | HabitProofCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * HabitProofCountOutputType without action
   */
  export type HabitProofCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProofCountOutputType
     */
    select?: HabitProofCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HabitProofCountOutputType without action
   */
  export type HabitProofCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProofVoteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    xp: number | null
    level: number | null
    coins: number | null
    totalAchievements: number | null
    currentAltitude: number | null
  }

  export type UserSumAggregateOutputType = {
    xp: number | null
    level: number | null
    coins: number | null
    totalAchievements: number | null
    currentAltitude: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    username: string | null
    password: string | null
    email: string | null
    gender: string | null
    birthday: Date | null
    bio: string | null
    avatarUrl: string | null
    otp: string | null
    otpExpiresAt: Date | null
    isPublic: boolean | null
    xp: number | null
    level: number | null
    coins: number | null
    totalAchievements: number | null
    currentMountainId: string | null
    currentAltitude: number | null
    lastActive: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    username: string | null
    password: string | null
    email: string | null
    gender: string | null
    birthday: Date | null
    bio: string | null
    avatarUrl: string | null
    otp: string | null
    otpExpiresAt: Date | null
    isPublic: boolean | null
    xp: number | null
    level: number | null
    coins: number | null
    totalAchievements: number | null
    currentMountainId: string | null
    currentAltitude: number | null
    lastActive: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    phoneNumber: number
    username: number
    password: number
    email: number
    gender: number
    birthday: number
    bio: number
    avatarUrl: number
    otp: number
    otpExpiresAt: number
    isPublic: number
    xp: number
    level: number
    coins: number
    totalAchievements: number
    currentMountainId: number
    currentAltitude: number
    lastActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    xp?: true
    level?: true
    coins?: true
    totalAchievements?: true
    currentAltitude?: true
  }

  export type UserSumAggregateInputType = {
    xp?: true
    level?: true
    coins?: true
    totalAchievements?: true
    currentAltitude?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    username?: true
    password?: true
    email?: true
    gender?: true
    birthday?: true
    bio?: true
    avatarUrl?: true
    otp?: true
    otpExpiresAt?: true
    isPublic?: true
    xp?: true
    level?: true
    coins?: true
    totalAchievements?: true
    currentMountainId?: true
    currentAltitude?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    username?: true
    password?: true
    email?: true
    gender?: true
    birthday?: true
    bio?: true
    avatarUrl?: true
    otp?: true
    otpExpiresAt?: true
    isPublic?: true
    xp?: true
    level?: true
    coins?: true
    totalAchievements?: true
    currentMountainId?: true
    currentAltitude?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    username?: true
    password?: true
    email?: true
    gender?: true
    birthday?: true
    bio?: true
    avatarUrl?: true
    otp?: true
    otpExpiresAt?: true
    isPublic?: true
    xp?: true
    level?: true
    coins?: true
    totalAchievements?: true
    currentMountainId?: true
    currentAltitude?: true
    lastActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    phoneNumber: string | null
    username: string
    password: string | null
    email: string | null
    gender: string | null
    birthday: Date | null
    bio: string | null
    avatarUrl: string | null
    otp: string | null
    otpExpiresAt: Date | null
    isPublic: boolean
    xp: number
    level: number
    coins: number
    totalAchievements: number
    currentMountainId: string | null
    currentAltitude: number
    lastActive: Date
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    gender?: boolean
    birthday?: boolean
    bio?: boolean
    avatarUrl?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    isPublic?: boolean
    xp?: boolean
    level?: boolean
    coins?: boolean
    totalAchievements?: boolean
    currentMountainId?: boolean
    currentAltitude?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMountain?: boolean | User$currentMountainArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    teamMembers?: boolean | User$teamMembersArgs<ExtArgs>
    participations?: boolean | User$participationsArgs<ExtArgs>
    progressLogs?: boolean | User$progressLogsArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    createdChallenges?: boolean | User$createdChallengesArgs<ExtArgs>
    joinedHabits?: boolean | User$joinedHabitsArgs<ExtArgs>
    habitProofs?: boolean | User$habitProofsArgs<ExtArgs>
    proofVotes?: boolean | User$proofVotesArgs<ExtArgs>
    friends?: boolean | User$friendsArgs<ExtArgs>
    friendOf?: boolean | User$friendOfArgs<ExtArgs>
    habitInvites?: boolean | User$habitInvitesArgs<ExtArgs>
    habitSettings?: boolean | User$habitSettingsArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    gender?: boolean
    birthday?: boolean
    bio?: boolean
    avatarUrl?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    isPublic?: boolean
    xp?: boolean
    level?: boolean
    coins?: boolean
    totalAchievements?: boolean
    currentMountainId?: boolean
    currentAltitude?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMountain?: boolean | User$currentMountainArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    phoneNumber?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    gender?: boolean
    birthday?: boolean
    bio?: boolean
    avatarUrl?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    isPublic?: boolean
    xp?: boolean
    level?: boolean
    coins?: boolean
    totalAchievements?: boolean
    currentMountainId?: boolean
    currentAltitude?: boolean
    lastActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentMountain?: boolean | User$currentMountainArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    teamMembers?: boolean | User$teamMembersArgs<ExtArgs>
    participations?: boolean | User$participationsArgs<ExtArgs>
    progressLogs?: boolean | User$progressLogsArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    createdChallenges?: boolean | User$createdChallengesArgs<ExtArgs>
    joinedHabits?: boolean | User$joinedHabitsArgs<ExtArgs>
    habitProofs?: boolean | User$habitProofsArgs<ExtArgs>
    proofVotes?: boolean | User$proofVotesArgs<ExtArgs>
    friends?: boolean | User$friendsArgs<ExtArgs>
    friendOf?: boolean | User$friendOfArgs<ExtArgs>
    habitInvites?: boolean | User$habitInvitesArgs<ExtArgs>
    habitSettings?: boolean | User$habitSettingsArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentMountain?: boolean | User$currentMountainArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      currentMountain: Prisma.$HabitCategoryPayload<ExtArgs> | null
      inventory: Prisma.$UserInventoryItemPayload<ExtArgs>[]
      teamMembers: Prisma.$TeamMemberPayload<ExtArgs>[]
      participations: Prisma.$ChallengeParticipantPayload<ExtArgs>[]
      progressLogs: Prisma.$ProgressLogPayload<ExtArgs>[]
      badges: Prisma.$UserBadgePayload<ExtArgs>[]
      createdChallenges: Prisma.$ChallengePayload<ExtArgs>[]
      joinedHabits: Prisma.$HabitPayload<ExtArgs>[]
      habitProofs: Prisma.$HabitProofPayload<ExtArgs>[]
      proofVotes: Prisma.$ProofVotePayload<ExtArgs>[]
      friends: Prisma.$FriendshipPayload<ExtArgs>[]
      friendOf: Prisma.$FriendshipPayload<ExtArgs>[]
      habitInvites: Prisma.$HabitInvitePayload<ExtArgs>[]
      habitSettings: Prisma.$HabitUserSettingsPayload<ExtArgs>[]
      followers: Prisma.$FollowPayload<ExtArgs>[]
      following: Prisma.$FollowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phoneNumber: string | null
      username: string
      password: string | null
      email: string | null
      gender: string | null
      birthday: Date | null
      bio: string | null
      avatarUrl: string | null
      otp: string | null
      otpExpiresAt: Date | null
      isPublic: boolean
      xp: number
      level: number
      coins: number
      totalAchievements: number
      currentMountainId: string | null
      currentAltitude: number
      lastActive: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currentMountain<T extends User$currentMountainArgs<ExtArgs> = {}>(args?: Subset<T, User$currentMountainArgs<ExtArgs>>): Prisma__HabitCategoryClient<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inventory<T extends User$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findMany"> | Null>
    teamMembers<T extends User$teamMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    participations<T extends User$participationsArgs<ExtArgs> = {}>(args?: Subset<T, User$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    progressLogs<T extends User$progressLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$progressLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "findMany"> | Null>
    badges<T extends User$badgesArgs<ExtArgs> = {}>(args?: Subset<T, User$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    createdChallenges<T extends User$createdChallengesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany"> | Null>
    joinedHabits<T extends User$joinedHabitsArgs<ExtArgs> = {}>(args?: Subset<T, User$joinedHabitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findMany"> | Null>
    habitProofs<T extends User$habitProofsArgs<ExtArgs> = {}>(args?: Subset<T, User$habitProofsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "findMany"> | Null>
    proofVotes<T extends User$proofVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$proofVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "findMany"> | Null>
    friends<T extends User$friendsArgs<ExtArgs> = {}>(args?: Subset<T, User$friendsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany"> | Null>
    friendOf<T extends User$friendOfArgs<ExtArgs> = {}>(args?: Subset<T, User$friendOfArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany"> | Null>
    habitInvites<T extends User$habitInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$habitInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "findMany"> | Null>
    habitSettings<T extends User$habitSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$habitSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "findMany"> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany"> | Null>
    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly birthday: FieldRef<"User", 'DateTime'>
    readonly bio: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly otp: FieldRef<"User", 'String'>
    readonly otpExpiresAt: FieldRef<"User", 'DateTime'>
    readonly isPublic: FieldRef<"User", 'Boolean'>
    readonly xp: FieldRef<"User", 'Int'>
    readonly level: FieldRef<"User", 'Int'>
    readonly coins: FieldRef<"User", 'Int'>
    readonly totalAchievements: FieldRef<"User", 'Int'>
    readonly currentMountainId: FieldRef<"User", 'String'>
    readonly currentAltitude: FieldRef<"User", 'Float'>
    readonly lastActive: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.currentMountain
   */
  export type User$currentMountainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
    where?: HabitCategoryWhereInput
  }

  /**
   * User.inventory
   */
  export type User$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    where?: UserInventoryItemWhereInput
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    cursor?: UserInventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInventoryItemScalarFieldEnum | UserInventoryItemScalarFieldEnum[]
  }

  /**
   * User.teamMembers
   */
  export type User$teamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.participations
   */
  export type User$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    where?: ChallengeParticipantWhereInput
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    cursor?: ChallengeParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * User.progressLogs
   */
  export type User$progressLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    where?: ProgressLogWhereInput
    orderBy?: ProgressLogOrderByWithRelationInput | ProgressLogOrderByWithRelationInput[]
    cursor?: ProgressLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressLogScalarFieldEnum | ProgressLogScalarFieldEnum[]
  }

  /**
   * User.badges
   */
  export type User$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * User.createdChallenges
   */
  export type User$createdChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    cursor?: ChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * User.joinedHabits
   */
  export type User$joinedHabitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    where?: HabitWhereInput
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    cursor?: HabitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * User.habitProofs
   */
  export type User$habitProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    where?: HabitProofWhereInput
    orderBy?: HabitProofOrderByWithRelationInput | HabitProofOrderByWithRelationInput[]
    cursor?: HabitProofWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitProofScalarFieldEnum | HabitProofScalarFieldEnum[]
  }

  /**
   * User.proofVotes
   */
  export type User$proofVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    where?: ProofVoteWhereInput
    orderBy?: ProofVoteOrderByWithRelationInput | ProofVoteOrderByWithRelationInput[]
    cursor?: ProofVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProofVoteScalarFieldEnum | ProofVoteScalarFieldEnum[]
  }

  /**
   * User.friends
   */
  export type User$friendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.friendOf
   */
  export type User$friendOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.habitInvites
   */
  export type User$habitInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    where?: HabitInviteWhereInput
    orderBy?: HabitInviteOrderByWithRelationInput | HabitInviteOrderByWithRelationInput[]
    cursor?: HabitInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitInviteScalarFieldEnum | HabitInviteScalarFieldEnum[]
  }

  /**
   * User.habitSettings
   */
  export type User$habitSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    where?: HabitUserSettingsWhereInput
    orderBy?: HabitUserSettingsOrderByWithRelationInput | HabitUserSettingsOrderByWithRelationInput[]
    cursor?: HabitUserSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitUserSettingsScalarFieldEnum | HabitUserSettingsScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserInventoryItem
   */

  export type AggregateUserInventoryItem = {
    _count: UserInventoryItemCountAggregateOutputType | null
    _min: UserInventoryItemMinAggregateOutputType | null
    _max: UserInventoryItemMaxAggregateOutputType | null
  }

  export type UserInventoryItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    itemId: string | null
  }

  export type UserInventoryItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    itemId: string | null
  }

  export type UserInventoryItemCountAggregateOutputType = {
    id: number
    userId: number
    itemId: number
    _all: number
  }


  export type UserInventoryItemMinAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
  }

  export type UserInventoryItemMaxAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
  }

  export type UserInventoryItemCountAggregateInputType = {
    id?: true
    userId?: true
    itemId?: true
    _all?: true
  }

  export type UserInventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInventoryItem to aggregate.
     */
    where?: UserInventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventoryItems to fetch.
     */
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInventoryItems
    **/
    _count?: true | UserInventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInventoryItemMaxAggregateInputType
  }

  export type GetUserInventoryItemAggregateType<T extends UserInventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInventoryItem[P]>
      : GetScalarType<T[P], AggregateUserInventoryItem[P]>
  }




  export type UserInventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInventoryItemWhereInput
    orderBy?: UserInventoryItemOrderByWithAggregationInput | UserInventoryItemOrderByWithAggregationInput[]
    by: UserInventoryItemScalarFieldEnum[] | UserInventoryItemScalarFieldEnum
    having?: UserInventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInventoryItemCountAggregateInputType | true
    _min?: UserInventoryItemMinAggregateInputType
    _max?: UserInventoryItemMaxAggregateInputType
  }

  export type UserInventoryItemGroupByOutputType = {
    id: string
    userId: string
    itemId: string
    _count: UserInventoryItemCountAggregateOutputType | null
    _min: UserInventoryItemMinAggregateOutputType | null
    _max: UserInventoryItemMaxAggregateOutputType | null
  }

  type GetUserInventoryItemGroupByPayload<T extends UserInventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], UserInventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type UserInventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInventoryItem"]>

  export type UserInventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itemId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInventoryItem"]>

  export type UserInventoryItemSelectScalar = {
    id?: boolean
    userId?: boolean
    itemId?: boolean
  }

  export type UserInventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserInventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInventoryItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      itemId: string
    }, ExtArgs["result"]["userInventoryItem"]>
    composites: {}
  }

  type UserInventoryItemGetPayload<S extends boolean | null | undefined | UserInventoryItemDefaultArgs> = $Result.GetResult<Prisma.$UserInventoryItemPayload, S>

  type UserInventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserInventoryItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserInventoryItemCountAggregateInputType | true
    }

  export interface UserInventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInventoryItem'], meta: { name: 'UserInventoryItem' } }
    /**
     * Find zero or one UserInventoryItem that matches the filter.
     * @param {UserInventoryItemFindUniqueArgs} args - Arguments to find a UserInventoryItem
     * @example
     * // Get one UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInventoryItemFindUniqueArgs>(args: SelectSubset<T, UserInventoryItemFindUniqueArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserInventoryItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserInventoryItemFindUniqueOrThrowArgs} args - Arguments to find a UserInventoryItem
     * @example
     * // Get one UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserInventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemFindFirstArgs} args - Arguments to find a UserInventoryItem
     * @example
     * // Get one UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInventoryItemFindFirstArgs>(args?: SelectSubset<T, UserInventoryItemFindFirstArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserInventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemFindFirstOrThrowArgs} args - Arguments to find a UserInventoryItem
     * @example
     * // Get one UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserInventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInventoryItems
     * const userInventoryItems = await prisma.userInventoryItem.findMany()
     * 
     * // Get first 10 UserInventoryItems
     * const userInventoryItems = await prisma.userInventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInventoryItemWithIdOnly = await prisma.userInventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInventoryItemFindManyArgs>(args?: SelectSubset<T, UserInventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserInventoryItem.
     * @param {UserInventoryItemCreateArgs} args - Arguments to create a UserInventoryItem.
     * @example
     * // Create one UserInventoryItem
     * const UserInventoryItem = await prisma.userInventoryItem.create({
     *   data: {
     *     // ... data to create a UserInventoryItem
     *   }
     * })
     * 
     */
    create<T extends UserInventoryItemCreateArgs>(args: SelectSubset<T, UserInventoryItemCreateArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserInventoryItems.
     * @param {UserInventoryItemCreateManyArgs} args - Arguments to create many UserInventoryItems.
     * @example
     * // Create many UserInventoryItems
     * const userInventoryItem = await prisma.userInventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInventoryItemCreateManyArgs>(args?: SelectSubset<T, UserInventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInventoryItems and returns the data saved in the database.
     * @param {UserInventoryItemCreateManyAndReturnArgs} args - Arguments to create many UserInventoryItems.
     * @example
     * // Create many UserInventoryItems
     * const userInventoryItem = await prisma.userInventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInventoryItems and only return the `id`
     * const userInventoryItemWithIdOnly = await prisma.userInventoryItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserInventoryItem.
     * @param {UserInventoryItemDeleteArgs} args - Arguments to delete one UserInventoryItem.
     * @example
     * // Delete one UserInventoryItem
     * const UserInventoryItem = await prisma.userInventoryItem.delete({
     *   where: {
     *     // ... filter to delete one UserInventoryItem
     *   }
     * })
     * 
     */
    delete<T extends UserInventoryItemDeleteArgs>(args: SelectSubset<T, UserInventoryItemDeleteArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserInventoryItem.
     * @param {UserInventoryItemUpdateArgs} args - Arguments to update one UserInventoryItem.
     * @example
     * // Update one UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInventoryItemUpdateArgs>(args: SelectSubset<T, UserInventoryItemUpdateArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserInventoryItems.
     * @param {UserInventoryItemDeleteManyArgs} args - Arguments to filter UserInventoryItems to delete.
     * @example
     * // Delete a few UserInventoryItems
     * const { count } = await prisma.userInventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInventoryItemDeleteManyArgs>(args?: SelectSubset<T, UserInventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInventoryItems
     * const userInventoryItem = await prisma.userInventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInventoryItemUpdateManyArgs>(args: SelectSubset<T, UserInventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserInventoryItem.
     * @param {UserInventoryItemUpsertArgs} args - Arguments to update or create a UserInventoryItem.
     * @example
     * // Update or create a UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.upsert({
     *   create: {
     *     // ... data to create a UserInventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends UserInventoryItemUpsertArgs>(args: SelectSubset<T, UserInventoryItemUpsertArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserInventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemCountArgs} args - Arguments to filter UserInventoryItems to count.
     * @example
     * // Count the number of UserInventoryItems
     * const count = await prisma.userInventoryItem.count({
     *   where: {
     *     // ... the filter for the UserInventoryItems we want to count
     *   }
     * })
    **/
    count<T extends UserInventoryItemCountArgs>(
      args?: Subset<T, UserInventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInventoryItemAggregateArgs>(args: Subset<T, UserInventoryItemAggregateArgs>): Prisma.PrismaPromise<GetUserInventoryItemAggregateType<T>>

    /**
     * Group by UserInventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: UserInventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInventoryItem model
   */
  readonly fields: UserInventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInventoryItem model
   */ 
  interface UserInventoryItemFieldRefs {
    readonly id: FieldRef<"UserInventoryItem", 'String'>
    readonly userId: FieldRef<"UserInventoryItem", 'String'>
    readonly itemId: FieldRef<"UserInventoryItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserInventoryItem findUnique
   */
  export type UserInventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which UserInventoryItem to fetch.
     */
    where: UserInventoryItemWhereUniqueInput
  }

  /**
   * UserInventoryItem findUniqueOrThrow
   */
  export type UserInventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which UserInventoryItem to fetch.
     */
    where: UserInventoryItemWhereUniqueInput
  }

  /**
   * UserInventoryItem findFirst
   */
  export type UserInventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which UserInventoryItem to fetch.
     */
    where?: UserInventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventoryItems to fetch.
     */
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInventoryItems.
     */
    cursor?: UserInventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInventoryItems.
     */
    distinct?: UserInventoryItemScalarFieldEnum | UserInventoryItemScalarFieldEnum[]
  }

  /**
   * UserInventoryItem findFirstOrThrow
   */
  export type UserInventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which UserInventoryItem to fetch.
     */
    where?: UserInventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventoryItems to fetch.
     */
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInventoryItems.
     */
    cursor?: UserInventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInventoryItems.
     */
    distinct?: UserInventoryItemScalarFieldEnum | UserInventoryItemScalarFieldEnum[]
  }

  /**
   * UserInventoryItem findMany
   */
  export type UserInventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which UserInventoryItems to fetch.
     */
    where?: UserInventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventoryItems to fetch.
     */
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInventoryItems.
     */
    cursor?: UserInventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventoryItems.
     */
    skip?: number
    distinct?: UserInventoryItemScalarFieldEnum | UserInventoryItemScalarFieldEnum[]
  }

  /**
   * UserInventoryItem create
   */
  export type UserInventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInventoryItem.
     */
    data: XOR<UserInventoryItemCreateInput, UserInventoryItemUncheckedCreateInput>
  }

  /**
   * UserInventoryItem createMany
   */
  export type UserInventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInventoryItems.
     */
    data: UserInventoryItemCreateManyInput | UserInventoryItemCreateManyInput[]
  }

  /**
   * UserInventoryItem createManyAndReturn
   */
  export type UserInventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserInventoryItems.
     */
    data: UserInventoryItemCreateManyInput | UserInventoryItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInventoryItem update
   */
  export type UserInventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInventoryItem.
     */
    data: XOR<UserInventoryItemUpdateInput, UserInventoryItemUncheckedUpdateInput>
    /**
     * Choose, which UserInventoryItem to update.
     */
    where: UserInventoryItemWhereUniqueInput
  }

  /**
   * UserInventoryItem updateMany
   */
  export type UserInventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInventoryItems.
     */
    data: XOR<UserInventoryItemUpdateManyMutationInput, UserInventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which UserInventoryItems to update
     */
    where?: UserInventoryItemWhereInput
  }

  /**
   * UserInventoryItem upsert
   */
  export type UserInventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInventoryItem to update in case it exists.
     */
    where: UserInventoryItemWhereUniqueInput
    /**
     * In case the UserInventoryItem found by the `where` argument doesn't exist, create a new UserInventoryItem with this data.
     */
    create: XOR<UserInventoryItemCreateInput, UserInventoryItemUncheckedCreateInput>
    /**
     * In case the UserInventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInventoryItemUpdateInput, UserInventoryItemUncheckedUpdateInput>
  }

  /**
   * UserInventoryItem delete
   */
  export type UserInventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter which UserInventoryItem to delete.
     */
    where: UserInventoryItemWhereUniqueInput
  }

  /**
   * UserInventoryItem deleteMany
   */
  export type UserInventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInventoryItems to delete
     */
    where?: UserInventoryItemWhereInput
  }

  /**
   * UserInventoryItem without action
   */
  export type UserInventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    avatarUrl: string | null
    inviteCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    avatarUrl: string | null
    inviteCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    avatarUrl: number
    inviteCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    avatarUrl?: true
    inviteCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    avatarUrl?: true
    inviteCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    avatarUrl?: true
    inviteCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    description: string | null
    avatarUrl: string | null
    inviteCode: string
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    avatarUrl?: boolean
    inviteCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Team$membersArgs<ExtArgs>
    challenges?: boolean | Team$challengesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    avatarUrl?: boolean
    inviteCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    avatarUrl?: boolean
    inviteCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Team$membersArgs<ExtArgs>
    challenges?: boolean | Team$challengesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
      challenges: Prisma.$ChallengePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      avatarUrl: string | null
      inviteCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    challenges<T extends Team$challengesArgs<ExtArgs> = {}>(args?: Subset<T, Team$challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly avatarUrl: FieldRef<"Team", 'String'>
    readonly inviteCode: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team.challenges
   */
  export type Team$challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    cursor?: ChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    teamId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    teamId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    userId: number
    teamId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    role?: true
    joinedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    role?: true
    joinedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    userId: string
    teamId: string
    role: string
    joinedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    teamId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      teamId: string
      role: string
      joinedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */ 
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly userId: FieldRef<"TeamMember", 'String'>
    readonly teamId: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'String'>
    readonly joinedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeAvgAggregateOutputType = {
    targetGoal: number | null
    thresholdPct: number | null
    maxHearts: number | null
  }

  export type ChallengeSumAggregateOutputType = {
    targetGoal: number | null
    thresholdPct: number | null
    maxHearts: number | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    category: string | null
    targetGoal: number | null
    thresholdPct: number | null
    maxHearts: number | null
    startDate: Date | null
    endDate: Date | null
    creatorId: string | null
    teamId: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    category: string | null
    targetGoal: number | null
    thresholdPct: number | null
    maxHearts: number | null
    startDate: Date | null
    endDate: Date | null
    creatorId: string | null
    teamId: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    category: number
    targetGoal: number
    thresholdPct: number
    maxHearts: number
    startDate: number
    endDate: number
    creatorId: number
    teamId: number
    isPublic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChallengeAvgAggregateInputType = {
    targetGoal?: true
    thresholdPct?: true
    maxHearts?: true
  }

  export type ChallengeSumAggregateInputType = {
    targetGoal?: true
    thresholdPct?: true
    maxHearts?: true
  }

  export type ChallengeMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    category?: true
    targetGoal?: true
    thresholdPct?: true
    maxHearts?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    teamId?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    category?: true
    targetGoal?: true
    thresholdPct?: true
    maxHearts?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    teamId?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    category?: true
    targetGoal?: true
    thresholdPct?: true
    maxHearts?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    teamId?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[]
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _avg?: ChallengeAvgAggregateInputType
    _sum?: ChallengeSumAggregateInputType
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }

  export type ChallengeGroupByOutputType = {
    id: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct: number | null
    maxHearts: number | null
    startDate: Date
    endDate: Date
    creatorId: string
    teamId: string | null
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    targetGoal?: boolean
    thresholdPct?: boolean
    maxHearts?: boolean
    startDate?: boolean
    endDate?: boolean
    creatorId?: boolean
    teamId?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | Challenge$teamArgs<ExtArgs>
    participants?: boolean | Challenge$participantsArgs<ExtArgs>
    progressLogs?: boolean | Challenge$progressLogsArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    targetGoal?: boolean
    thresholdPct?: boolean
    maxHearts?: boolean
    startDate?: boolean
    endDate?: boolean
    creatorId?: boolean
    teamId?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | Challenge$teamArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    targetGoal?: boolean
    thresholdPct?: boolean
    maxHearts?: boolean
    startDate?: boolean
    endDate?: boolean
    creatorId?: boolean
    teamId?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | Challenge$teamArgs<ExtArgs>
    participants?: boolean | Challenge$participantsArgs<ExtArgs>
    progressLogs?: boolean | Challenge$progressLogsArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | Challenge$teamArgs<ExtArgs>
  }

  export type $ChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Challenge"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
      participants: Prisma.$ChallengeParticipantPayload<ExtArgs>[]
      progressLogs: Prisma.$ProgressLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      type: string
      category: string
      targetGoal: number
      thresholdPct: number | null
      maxHearts: number | null
      startDate: Date
      endDate: Date
      creatorId: string
      teamId: string | null
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["challenge"]>
    composites: {}
  }

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> = $Result.GetResult<Prisma.$ChallengePayload, S>

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengeCountAggregateInputType | true
    }

  export interface ChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Challenge'], meta: { name: 'Challenge' } }
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeFindManyArgs>(args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
     */
    create<T extends ChallengeCreateArgs>(args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeCreateManyArgs>(args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {ChallengeCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDeleteArgs>(args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeUpdateArgs>(args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeUpdateManyArgs>(args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Challenge model
   */
  readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends Challenge$teamArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    participants<T extends Challenge$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    progressLogs<T extends Challenge$progressLogsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$progressLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Challenge model
   */ 
  interface ChallengeFieldRefs {
    readonly id: FieldRef<"Challenge", 'String'>
    readonly title: FieldRef<"Challenge", 'String'>
    readonly description: FieldRef<"Challenge", 'String'>
    readonly type: FieldRef<"Challenge", 'String'>
    readonly category: FieldRef<"Challenge", 'String'>
    readonly targetGoal: FieldRef<"Challenge", 'Float'>
    readonly thresholdPct: FieldRef<"Challenge", 'Float'>
    readonly maxHearts: FieldRef<"Challenge", 'Int'>
    readonly startDate: FieldRef<"Challenge", 'DateTime'>
    readonly endDate: FieldRef<"Challenge", 'DateTime'>
    readonly creatorId: FieldRef<"Challenge", 'String'>
    readonly teamId: FieldRef<"Challenge", 'String'>
    readonly isPublic: FieldRef<"Challenge", 'Boolean'>
    readonly createdAt: FieldRef<"Challenge", 'DateTime'>
    readonly updatedAt: FieldRef<"Challenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
  }

  /**
   * Challenge createManyAndReturn
   */
  export type ChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
  }

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput
  }

  /**
   * Challenge.team
   */
  export type Challenge$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Challenge.participants
   */
  export type Challenge$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    where?: ChallengeParticipantWhereInput
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    cursor?: ChallengeParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * Challenge.progressLogs
   */
  export type Challenge$progressLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    where?: ProgressLogWhereInput
    orderBy?: ProgressLogOrderByWithRelationInput | ProgressLogOrderByWithRelationInput[]
    cursor?: ProgressLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgressLogScalarFieldEnum | ProgressLogScalarFieldEnum[]
  }

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeParticipant
   */

  export type AggregateChallengeParticipant = {
    _count: ChallengeParticipantCountAggregateOutputType | null
    _avg: ChallengeParticipantAvgAggregateOutputType | null
    _sum: ChallengeParticipantSumAggregateOutputType | null
    _min: ChallengeParticipantMinAggregateOutputType | null
    _max: ChallengeParticipantMaxAggregateOutputType | null
  }

  export type ChallengeParticipantAvgAggregateOutputType = {
    currentValue: number | null
    heartsLeft: number | null
    relayOrder: number | null
  }

  export type ChallengeParticipantSumAggregateOutputType = {
    currentValue: number | null
    heartsLeft: number | null
    relayOrder: number | null
  }

  export type ChallengeParticipantMinAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    currentValue: number | null
    heartsLeft: number | null
    isEliminated: boolean | null
    relayOrder: number | null
    relayCompleted: boolean | null
    joinedAt: Date | null
  }

  export type ChallengeParticipantMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    currentValue: number | null
    heartsLeft: number | null
    isEliminated: boolean | null
    relayOrder: number | null
    relayCompleted: boolean | null
    joinedAt: Date | null
  }

  export type ChallengeParticipantCountAggregateOutputType = {
    id: number
    userId: number
    challengeId: number
    currentValue: number
    heartsLeft: number
    isEliminated: number
    relayOrder: number
    relayCompleted: number
    joinedAt: number
    _all: number
  }


  export type ChallengeParticipantAvgAggregateInputType = {
    currentValue?: true
    heartsLeft?: true
    relayOrder?: true
  }

  export type ChallengeParticipantSumAggregateInputType = {
    currentValue?: true
    heartsLeft?: true
    relayOrder?: true
  }

  export type ChallengeParticipantMinAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    currentValue?: true
    heartsLeft?: true
    isEliminated?: true
    relayOrder?: true
    relayCompleted?: true
    joinedAt?: true
  }

  export type ChallengeParticipantMaxAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    currentValue?: true
    heartsLeft?: true
    isEliminated?: true
    relayOrder?: true
    relayCompleted?: true
    joinedAt?: true
  }

  export type ChallengeParticipantCountAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    currentValue?: true
    heartsLeft?: true
    isEliminated?: true
    relayOrder?: true
    relayCompleted?: true
    joinedAt?: true
    _all?: true
  }

  export type ChallengeParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeParticipant to aggregate.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeParticipants
    **/
    _count?: true | ChallengeParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeParticipantMaxAggregateInputType
  }

  export type GetChallengeParticipantAggregateType<T extends ChallengeParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeParticipant[P]>
      : GetScalarType<T[P], AggregateChallengeParticipant[P]>
  }




  export type ChallengeParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeParticipantWhereInput
    orderBy?: ChallengeParticipantOrderByWithAggregationInput | ChallengeParticipantOrderByWithAggregationInput[]
    by: ChallengeParticipantScalarFieldEnum[] | ChallengeParticipantScalarFieldEnum
    having?: ChallengeParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeParticipantCountAggregateInputType | true
    _avg?: ChallengeParticipantAvgAggregateInputType
    _sum?: ChallengeParticipantSumAggregateInputType
    _min?: ChallengeParticipantMinAggregateInputType
    _max?: ChallengeParticipantMaxAggregateInputType
  }

  export type ChallengeParticipantGroupByOutputType = {
    id: string
    userId: string
    challengeId: string
    currentValue: number
    heartsLeft: number | null
    isEliminated: boolean
    relayOrder: number | null
    relayCompleted: boolean
    joinedAt: Date
    _count: ChallengeParticipantCountAggregateOutputType | null
    _avg: ChallengeParticipantAvgAggregateOutputType | null
    _sum: ChallengeParticipantSumAggregateOutputType | null
    _min: ChallengeParticipantMinAggregateOutputType | null
    _max: ChallengeParticipantMaxAggregateOutputType | null
  }

  type GetChallengeParticipantGroupByPayload<T extends ChallengeParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    currentValue?: boolean
    heartsLeft?: boolean
    isEliminated?: boolean
    relayOrder?: boolean
    relayCompleted?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeParticipant"]>

  export type ChallengeParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    currentValue?: boolean
    heartsLeft?: boolean
    isEliminated?: boolean
    relayOrder?: boolean
    relayCompleted?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeParticipant"]>

  export type ChallengeParticipantSelectScalar = {
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    currentValue?: boolean
    heartsLeft?: boolean
    isEliminated?: boolean
    relayOrder?: boolean
    relayCompleted?: boolean
    joinedAt?: boolean
  }

  export type ChallengeParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeParticipant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      challengeId: string
      currentValue: number
      heartsLeft: number | null
      isEliminated: boolean
      relayOrder: number | null
      relayCompleted: boolean
      joinedAt: Date
    }, ExtArgs["result"]["challengeParticipant"]>
    composites: {}
  }

  type ChallengeParticipantGetPayload<S extends boolean | null | undefined | ChallengeParticipantDefaultArgs> = $Result.GetResult<Prisma.$ChallengeParticipantPayload, S>

  type ChallengeParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChallengeParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengeParticipantCountAggregateInputType | true
    }

  export interface ChallengeParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeParticipant'], meta: { name: 'ChallengeParticipant' } }
    /**
     * Find zero or one ChallengeParticipant that matches the filter.
     * @param {ChallengeParticipantFindUniqueArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeParticipantFindUniqueArgs>(args: SelectSubset<T, ChallengeParticipantFindUniqueArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChallengeParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChallengeParticipantFindUniqueOrThrowArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChallengeParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantFindFirstArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeParticipantFindFirstArgs>(args?: SelectSubset<T, ChallengeParticipantFindFirstArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChallengeParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantFindFirstOrThrowArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChallengeParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeParticipants
     * const challengeParticipants = await prisma.challengeParticipant.findMany()
     * 
     * // Get first 10 ChallengeParticipants
     * const challengeParticipants = await prisma.challengeParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeParticipantWithIdOnly = await prisma.challengeParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeParticipantFindManyArgs>(args?: SelectSubset<T, ChallengeParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChallengeParticipant.
     * @param {ChallengeParticipantCreateArgs} args - Arguments to create a ChallengeParticipant.
     * @example
     * // Create one ChallengeParticipant
     * const ChallengeParticipant = await prisma.challengeParticipant.create({
     *   data: {
     *     // ... data to create a ChallengeParticipant
     *   }
     * })
     * 
     */
    create<T extends ChallengeParticipantCreateArgs>(args: SelectSubset<T, ChallengeParticipantCreateArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChallengeParticipants.
     * @param {ChallengeParticipantCreateManyArgs} args - Arguments to create many ChallengeParticipants.
     * @example
     * // Create many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeParticipantCreateManyArgs>(args?: SelectSubset<T, ChallengeParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeParticipants and returns the data saved in the database.
     * @param {ChallengeParticipantCreateManyAndReturnArgs} args - Arguments to create many ChallengeParticipants.
     * @example
     * // Create many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeParticipants and only return the `id`
     * const challengeParticipantWithIdOnly = await prisma.challengeParticipant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChallengeParticipant.
     * @param {ChallengeParticipantDeleteArgs} args - Arguments to delete one ChallengeParticipant.
     * @example
     * // Delete one ChallengeParticipant
     * const ChallengeParticipant = await prisma.challengeParticipant.delete({
     *   where: {
     *     // ... filter to delete one ChallengeParticipant
     *   }
     * })
     * 
     */
    delete<T extends ChallengeParticipantDeleteArgs>(args: SelectSubset<T, ChallengeParticipantDeleteArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChallengeParticipant.
     * @param {ChallengeParticipantUpdateArgs} args - Arguments to update one ChallengeParticipant.
     * @example
     * // Update one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeParticipantUpdateArgs>(args: SelectSubset<T, ChallengeParticipantUpdateArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChallengeParticipants.
     * @param {ChallengeParticipantDeleteManyArgs} args - Arguments to filter ChallengeParticipants to delete.
     * @example
     * // Delete a few ChallengeParticipants
     * const { count } = await prisma.challengeParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeParticipantDeleteManyArgs>(args?: SelectSubset<T, ChallengeParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeParticipantUpdateManyArgs>(args: SelectSubset<T, ChallengeParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChallengeParticipant.
     * @param {ChallengeParticipantUpsertArgs} args - Arguments to update or create a ChallengeParticipant.
     * @example
     * // Update or create a ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.upsert({
     *   create: {
     *     // ... data to create a ChallengeParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeParticipantUpsertArgs>(args: SelectSubset<T, ChallengeParticipantUpsertArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChallengeParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantCountArgs} args - Arguments to filter ChallengeParticipants to count.
     * @example
     * // Count the number of ChallengeParticipants
     * const count = await prisma.challengeParticipant.count({
     *   where: {
     *     // ... the filter for the ChallengeParticipants we want to count
     *   }
     * })
    **/
    count<T extends ChallengeParticipantCountArgs>(
      args?: Subset<T, ChallengeParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeParticipantAggregateArgs>(args: Subset<T, ChallengeParticipantAggregateArgs>): Prisma.PrismaPromise<GetChallengeParticipantAggregateType<T>>

    /**
     * Group by ChallengeParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeParticipant model
   */
  readonly fields: ChallengeParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeParticipant model
   */ 
  interface ChallengeParticipantFieldRefs {
    readonly id: FieldRef<"ChallengeParticipant", 'String'>
    readonly userId: FieldRef<"ChallengeParticipant", 'String'>
    readonly challengeId: FieldRef<"ChallengeParticipant", 'String'>
    readonly currentValue: FieldRef<"ChallengeParticipant", 'Float'>
    readonly heartsLeft: FieldRef<"ChallengeParticipant", 'Int'>
    readonly isEliminated: FieldRef<"ChallengeParticipant", 'Boolean'>
    readonly relayOrder: FieldRef<"ChallengeParticipant", 'Int'>
    readonly relayCompleted: FieldRef<"ChallengeParticipant", 'Boolean'>
    readonly joinedAt: FieldRef<"ChallengeParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeParticipant findUnique
   */
  export type ChallengeParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant findUniqueOrThrow
   */
  export type ChallengeParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant findFirst
   */
  export type ChallengeParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeParticipants.
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeParticipants.
     */
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * ChallengeParticipant findFirstOrThrow
   */
  export type ChallengeParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeParticipants.
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeParticipants.
     */
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * ChallengeParticipant findMany
   */
  export type ChallengeParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipants to fetch.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeParticipants.
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * ChallengeParticipant create
   */
  export type ChallengeParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeParticipant.
     */
    data: XOR<ChallengeParticipantCreateInput, ChallengeParticipantUncheckedCreateInput>
  }

  /**
   * ChallengeParticipant createMany
   */
  export type ChallengeParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeParticipants.
     */
    data: ChallengeParticipantCreateManyInput | ChallengeParticipantCreateManyInput[]
  }

  /**
   * ChallengeParticipant createManyAndReturn
   */
  export type ChallengeParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChallengeParticipants.
     */
    data: ChallengeParticipantCreateManyInput | ChallengeParticipantCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeParticipant update
   */
  export type ChallengeParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeParticipant.
     */
    data: XOR<ChallengeParticipantUpdateInput, ChallengeParticipantUncheckedUpdateInput>
    /**
     * Choose, which ChallengeParticipant to update.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant updateMany
   */
  export type ChallengeParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeParticipants.
     */
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeParticipants to update
     */
    where?: ChallengeParticipantWhereInput
  }

  /**
   * ChallengeParticipant upsert
   */
  export type ChallengeParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeParticipant to update in case it exists.
     */
    where: ChallengeParticipantWhereUniqueInput
    /**
     * In case the ChallengeParticipant found by the `where` argument doesn't exist, create a new ChallengeParticipant with this data.
     */
    create: XOR<ChallengeParticipantCreateInput, ChallengeParticipantUncheckedCreateInput>
    /**
     * In case the ChallengeParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeParticipantUpdateInput, ChallengeParticipantUncheckedUpdateInput>
  }

  /**
   * ChallengeParticipant delete
   */
  export type ChallengeParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter which ChallengeParticipant to delete.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant deleteMany
   */
  export type ChallengeParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeParticipants to delete
     */
    where?: ChallengeParticipantWhereInput
  }

  /**
   * ChallengeParticipant without action
   */
  export type ChallengeParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
  }


  /**
   * Model ProgressLog
   */

  export type AggregateProgressLog = {
    _count: ProgressLogCountAggregateOutputType | null
    _avg: ProgressLogAvgAggregateOutputType | null
    _sum: ProgressLogSumAggregateOutputType | null
    _min: ProgressLogMinAggregateOutputType | null
    _max: ProgressLogMaxAggregateOutputType | null
  }

  export type ProgressLogAvgAggregateOutputType = {
    value: number | null
  }

  export type ProgressLogSumAggregateOutputType = {
    value: number | null
  }

  export type ProgressLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    value: number | null
    isSuccess: boolean | null
    note: string | null
    date: Date | null
    createdAt: Date | null
  }

  export type ProgressLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    value: number | null
    isSuccess: boolean | null
    note: string | null
    date: Date | null
    createdAt: Date | null
  }

  export type ProgressLogCountAggregateOutputType = {
    id: number
    userId: number
    challengeId: number
    value: number
    isSuccess: number
    note: number
    date: number
    createdAt: number
    _all: number
  }


  export type ProgressLogAvgAggregateInputType = {
    value?: true
  }

  export type ProgressLogSumAggregateInputType = {
    value?: true
  }

  export type ProgressLogMinAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    value?: true
    isSuccess?: true
    note?: true
    date?: true
    createdAt?: true
  }

  export type ProgressLogMaxAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    value?: true
    isSuccess?: true
    note?: true
    date?: true
    createdAt?: true
  }

  export type ProgressLogCountAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    value?: true
    isSuccess?: true
    note?: true
    date?: true
    createdAt?: true
    _all?: true
  }

  export type ProgressLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressLog to aggregate.
     */
    where?: ProgressLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressLogs to fetch.
     */
    orderBy?: ProgressLogOrderByWithRelationInput | ProgressLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgressLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgressLogs
    **/
    _count?: true | ProgressLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgressLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgressLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgressLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgressLogMaxAggregateInputType
  }

  export type GetProgressLogAggregateType<T extends ProgressLogAggregateArgs> = {
        [P in keyof T & keyof AggregateProgressLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgressLog[P]>
      : GetScalarType<T[P], AggregateProgressLog[P]>
  }




  export type ProgressLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgressLogWhereInput
    orderBy?: ProgressLogOrderByWithAggregationInput | ProgressLogOrderByWithAggregationInput[]
    by: ProgressLogScalarFieldEnum[] | ProgressLogScalarFieldEnum
    having?: ProgressLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgressLogCountAggregateInputType | true
    _avg?: ProgressLogAvgAggregateInputType
    _sum?: ProgressLogSumAggregateInputType
    _min?: ProgressLogMinAggregateInputType
    _max?: ProgressLogMaxAggregateInputType
  }

  export type ProgressLogGroupByOutputType = {
    id: string
    userId: string
    challengeId: string
    value: number
    isSuccess: boolean
    note: string | null
    date: Date
    createdAt: Date
    _count: ProgressLogCountAggregateOutputType | null
    _avg: ProgressLogAvgAggregateOutputType | null
    _sum: ProgressLogSumAggregateOutputType | null
    _min: ProgressLogMinAggregateOutputType | null
    _max: ProgressLogMaxAggregateOutputType | null
  }

  type GetProgressLogGroupByPayload<T extends ProgressLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgressLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgressLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgressLogGroupByOutputType[P]>
            : GetScalarType<T[P], ProgressLogGroupByOutputType[P]>
        }
      >
    >


  export type ProgressLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    value?: boolean
    isSuccess?: boolean
    note?: boolean
    date?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressLog"]>

  export type ProgressLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    value?: boolean
    isSuccess?: boolean
    note?: boolean
    date?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["progressLog"]>

  export type ProgressLogSelectScalar = {
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    value?: boolean
    isSuccess?: boolean
    note?: boolean
    date?: boolean
    createdAt?: boolean
  }

  export type ProgressLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ProgressLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ProgressLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgressLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      challengeId: string
      value: number
      isSuccess: boolean
      note: string | null
      date: Date
      createdAt: Date
    }, ExtArgs["result"]["progressLog"]>
    composites: {}
  }

  type ProgressLogGetPayload<S extends boolean | null | undefined | ProgressLogDefaultArgs> = $Result.GetResult<Prisma.$ProgressLogPayload, S>

  type ProgressLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgressLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgressLogCountAggregateInputType | true
    }

  export interface ProgressLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgressLog'], meta: { name: 'ProgressLog' } }
    /**
     * Find zero or one ProgressLog that matches the filter.
     * @param {ProgressLogFindUniqueArgs} args - Arguments to find a ProgressLog
     * @example
     * // Get one ProgressLog
     * const progressLog = await prisma.progressLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgressLogFindUniqueArgs>(args: SelectSubset<T, ProgressLogFindUniqueArgs<ExtArgs>>): Prisma__ProgressLogClient<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgressLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgressLogFindUniqueOrThrowArgs} args - Arguments to find a ProgressLog
     * @example
     * // Get one ProgressLog
     * const progressLog = await prisma.progressLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgressLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgressLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgressLogClient<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgressLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressLogFindFirstArgs} args - Arguments to find a ProgressLog
     * @example
     * // Get one ProgressLog
     * const progressLog = await prisma.progressLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgressLogFindFirstArgs>(args?: SelectSubset<T, ProgressLogFindFirstArgs<ExtArgs>>): Prisma__ProgressLogClient<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgressLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressLogFindFirstOrThrowArgs} args - Arguments to find a ProgressLog
     * @example
     * // Get one ProgressLog
     * const progressLog = await prisma.progressLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgressLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgressLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgressLogClient<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgressLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgressLogs
     * const progressLogs = await prisma.progressLog.findMany()
     * 
     * // Get first 10 ProgressLogs
     * const progressLogs = await prisma.progressLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const progressLogWithIdOnly = await prisma.progressLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgressLogFindManyArgs>(args?: SelectSubset<T, ProgressLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgressLog.
     * @param {ProgressLogCreateArgs} args - Arguments to create a ProgressLog.
     * @example
     * // Create one ProgressLog
     * const ProgressLog = await prisma.progressLog.create({
     *   data: {
     *     // ... data to create a ProgressLog
     *   }
     * })
     * 
     */
    create<T extends ProgressLogCreateArgs>(args: SelectSubset<T, ProgressLogCreateArgs<ExtArgs>>): Prisma__ProgressLogClient<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgressLogs.
     * @param {ProgressLogCreateManyArgs} args - Arguments to create many ProgressLogs.
     * @example
     * // Create many ProgressLogs
     * const progressLog = await prisma.progressLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgressLogCreateManyArgs>(args?: SelectSubset<T, ProgressLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgressLogs and returns the data saved in the database.
     * @param {ProgressLogCreateManyAndReturnArgs} args - Arguments to create many ProgressLogs.
     * @example
     * // Create many ProgressLogs
     * const progressLog = await prisma.progressLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgressLogs and only return the `id`
     * const progressLogWithIdOnly = await prisma.progressLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgressLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgressLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgressLog.
     * @param {ProgressLogDeleteArgs} args - Arguments to delete one ProgressLog.
     * @example
     * // Delete one ProgressLog
     * const ProgressLog = await prisma.progressLog.delete({
     *   where: {
     *     // ... filter to delete one ProgressLog
     *   }
     * })
     * 
     */
    delete<T extends ProgressLogDeleteArgs>(args: SelectSubset<T, ProgressLogDeleteArgs<ExtArgs>>): Prisma__ProgressLogClient<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgressLog.
     * @param {ProgressLogUpdateArgs} args - Arguments to update one ProgressLog.
     * @example
     * // Update one ProgressLog
     * const progressLog = await prisma.progressLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgressLogUpdateArgs>(args: SelectSubset<T, ProgressLogUpdateArgs<ExtArgs>>): Prisma__ProgressLogClient<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgressLogs.
     * @param {ProgressLogDeleteManyArgs} args - Arguments to filter ProgressLogs to delete.
     * @example
     * // Delete a few ProgressLogs
     * const { count } = await prisma.progressLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgressLogDeleteManyArgs>(args?: SelectSubset<T, ProgressLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgressLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgressLogs
     * const progressLog = await prisma.progressLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgressLogUpdateManyArgs>(args: SelectSubset<T, ProgressLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgressLog.
     * @param {ProgressLogUpsertArgs} args - Arguments to update or create a ProgressLog.
     * @example
     * // Update or create a ProgressLog
     * const progressLog = await prisma.progressLog.upsert({
     *   create: {
     *     // ... data to create a ProgressLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgressLog we want to update
     *   }
     * })
     */
    upsert<T extends ProgressLogUpsertArgs>(args: SelectSubset<T, ProgressLogUpsertArgs<ExtArgs>>): Prisma__ProgressLogClient<$Result.GetResult<Prisma.$ProgressLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgressLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressLogCountArgs} args - Arguments to filter ProgressLogs to count.
     * @example
     * // Count the number of ProgressLogs
     * const count = await prisma.progressLog.count({
     *   where: {
     *     // ... the filter for the ProgressLogs we want to count
     *   }
     * })
    **/
    count<T extends ProgressLogCountArgs>(
      args?: Subset<T, ProgressLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgressLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgressLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgressLogAggregateArgs>(args: Subset<T, ProgressLogAggregateArgs>): Prisma.PrismaPromise<GetProgressLogAggregateType<T>>

    /**
     * Group by ProgressLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgressLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgressLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgressLogGroupByArgs['orderBy'] }
        : { orderBy?: ProgressLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgressLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgressLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgressLog model
   */
  readonly fields: ProgressLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgressLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgressLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgressLog model
   */ 
  interface ProgressLogFieldRefs {
    readonly id: FieldRef<"ProgressLog", 'String'>
    readonly userId: FieldRef<"ProgressLog", 'String'>
    readonly challengeId: FieldRef<"ProgressLog", 'String'>
    readonly value: FieldRef<"ProgressLog", 'Float'>
    readonly isSuccess: FieldRef<"ProgressLog", 'Boolean'>
    readonly note: FieldRef<"ProgressLog", 'String'>
    readonly date: FieldRef<"ProgressLog", 'DateTime'>
    readonly createdAt: FieldRef<"ProgressLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgressLog findUnique
   */
  export type ProgressLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    /**
     * Filter, which ProgressLog to fetch.
     */
    where: ProgressLogWhereUniqueInput
  }

  /**
   * ProgressLog findUniqueOrThrow
   */
  export type ProgressLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    /**
     * Filter, which ProgressLog to fetch.
     */
    where: ProgressLogWhereUniqueInput
  }

  /**
   * ProgressLog findFirst
   */
  export type ProgressLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    /**
     * Filter, which ProgressLog to fetch.
     */
    where?: ProgressLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressLogs to fetch.
     */
    orderBy?: ProgressLogOrderByWithRelationInput | ProgressLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressLogs.
     */
    cursor?: ProgressLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressLogs.
     */
    distinct?: ProgressLogScalarFieldEnum | ProgressLogScalarFieldEnum[]
  }

  /**
   * ProgressLog findFirstOrThrow
   */
  export type ProgressLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    /**
     * Filter, which ProgressLog to fetch.
     */
    where?: ProgressLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressLogs to fetch.
     */
    orderBy?: ProgressLogOrderByWithRelationInput | ProgressLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgressLogs.
     */
    cursor?: ProgressLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgressLogs.
     */
    distinct?: ProgressLogScalarFieldEnum | ProgressLogScalarFieldEnum[]
  }

  /**
   * ProgressLog findMany
   */
  export type ProgressLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    /**
     * Filter, which ProgressLogs to fetch.
     */
    where?: ProgressLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgressLogs to fetch.
     */
    orderBy?: ProgressLogOrderByWithRelationInput | ProgressLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgressLogs.
     */
    cursor?: ProgressLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgressLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgressLogs.
     */
    skip?: number
    distinct?: ProgressLogScalarFieldEnum | ProgressLogScalarFieldEnum[]
  }

  /**
   * ProgressLog create
   */
  export type ProgressLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgressLog.
     */
    data: XOR<ProgressLogCreateInput, ProgressLogUncheckedCreateInput>
  }

  /**
   * ProgressLog createMany
   */
  export type ProgressLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgressLogs.
     */
    data: ProgressLogCreateManyInput | ProgressLogCreateManyInput[]
  }

  /**
   * ProgressLog createManyAndReturn
   */
  export type ProgressLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgressLogs.
     */
    data: ProgressLogCreateManyInput | ProgressLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgressLog update
   */
  export type ProgressLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgressLog.
     */
    data: XOR<ProgressLogUpdateInput, ProgressLogUncheckedUpdateInput>
    /**
     * Choose, which ProgressLog to update.
     */
    where: ProgressLogWhereUniqueInput
  }

  /**
   * ProgressLog updateMany
   */
  export type ProgressLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgressLogs.
     */
    data: XOR<ProgressLogUpdateManyMutationInput, ProgressLogUncheckedUpdateManyInput>
    /**
     * Filter which ProgressLogs to update
     */
    where?: ProgressLogWhereInput
  }

  /**
   * ProgressLog upsert
   */
  export type ProgressLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgressLog to update in case it exists.
     */
    where: ProgressLogWhereUniqueInput
    /**
     * In case the ProgressLog found by the `where` argument doesn't exist, create a new ProgressLog with this data.
     */
    create: XOR<ProgressLogCreateInput, ProgressLogUncheckedCreateInput>
    /**
     * In case the ProgressLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgressLogUpdateInput, ProgressLogUncheckedUpdateInput>
  }

  /**
   * ProgressLog delete
   */
  export type ProgressLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
    /**
     * Filter which ProgressLog to delete.
     */
    where: ProgressLogWhereUniqueInput
  }

  /**
   * ProgressLog deleteMany
   */
  export type ProgressLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgressLogs to delete
     */
    where?: ProgressLogWhereInput
  }

  /**
   * ProgressLog without action
   */
  export type ProgressLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgressLog
     */
    select?: ProgressLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgressLogInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    xpReward: number | null
  }

  export type BadgeSumAggregateOutputType = {
    xpReward: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    iconUrl: string | null
    xpReward: number | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    iconUrl: string | null
    xpReward: number | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    iconUrl: number
    xpReward: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    xpReward?: true
  }

  export type BadgeSumAggregateInputType = {
    xpReward?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    iconUrl?: true
    xpReward?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    iconUrl?: true
    xpReward?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    iconUrl?: true
    xpReward?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    name: string
    description: string
    iconUrl: string | null
    xpReward: number
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    xpReward?: boolean
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    xpReward?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    xpReward?: boolean
  }

  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      users: Prisma.$UserBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      iconUrl: string | null
      xpReward: number
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Badge$usersArgs<ExtArgs> = {}>(args?: Subset<T, Badge$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */ 
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly iconUrl: FieldRef<"Badge", 'String'>
    readonly xpReward: FieldRef<"Badge", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge.users
   */
  export type Badge$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    earnedAt: Date | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    earnedAt: Date | null
  }

  export type UserBadgeCountAggregateOutputType = {
    id: number
    userId: number
    badgeId: number
    earnedAt: number
    _all: number
  }


  export type UserBadgeMinAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    earnedAt?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    earnedAt?: true
  }

  export type UserBadgeCountAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    earnedAt?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    id: string
    userId: string
    badgeId: string
    earnedAt: Date
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectScalar = {
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
  }

  export type UserBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }

  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      badge: Prisma.$BadgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      badgeId: string
      earnedAt: Date
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBadgeFindUniqueArgs>(args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBadgeFindFirstArgs>(args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBadgeFindManyArgs>(args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends UserBadgeCreateArgs>(args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBadges.
     * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBadgeCreateManyArgs>(args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBadges and returns the data saved in the database.
     * @param {UserBadgeCreateManyAndReturnArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBadges and only return the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends UserBadgeDeleteArgs>(args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBadgeUpdateArgs>(args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBadgeDeleteManyArgs>(args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBadgeUpdateManyArgs>(args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends UserBadgeUpsertArgs>(args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBadge model
   */ 
  interface UserBadgeFieldRefs {
    readonly id: FieldRef<"UserBadge", 'String'>
    readonly userId: FieldRef<"UserBadge", 'String'>
    readonly badgeId: FieldRef<"UserBadge", 'String'>
    readonly earnedAt: FieldRef<"UserBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }

  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
  }

  /**
   * UserBadge createManyAndReturn
   */
  export type UserBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }

  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
  }


  /**
   * Model HabitCategory
   */

  export type AggregateHabitCategory = {
    _count: HabitCategoryCountAggregateOutputType | null
    _min: HabitCategoryMinAggregateOutputType | null
    _max: HabitCategoryMaxAggregateOutputType | null
  }

  export type HabitCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    biomeType: string | null
    mountainIcon: string | null
    mountainImage: string | null
    primaryColor: string | null
    secondaryColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    biomeType: string | null
    mountainIcon: string | null
    mountainImage: string | null
    primaryColor: string | null
    secondaryColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitCategoryCountAggregateOutputType = {
    id: number
    name: number
    biomeType: number
    mountainIcon: number
    mountainImage: number
    primaryColor: number
    secondaryColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HabitCategoryMinAggregateInputType = {
    id?: true
    name?: true
    biomeType?: true
    mountainIcon?: true
    mountainImage?: true
    primaryColor?: true
    secondaryColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    biomeType?: true
    mountainIcon?: true
    mountainImage?: true
    primaryColor?: true
    secondaryColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitCategoryCountAggregateInputType = {
    id?: true
    name?: true
    biomeType?: true
    mountainIcon?: true
    mountainImage?: true
    primaryColor?: true
    secondaryColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HabitCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HabitCategory to aggregate.
     */
    where?: HabitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitCategories to fetch.
     */
    orderBy?: HabitCategoryOrderByWithRelationInput | HabitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HabitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HabitCategories
    **/
    _count?: true | HabitCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HabitCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HabitCategoryMaxAggregateInputType
  }

  export type GetHabitCategoryAggregateType<T extends HabitCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHabitCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabitCategory[P]>
      : GetScalarType<T[P], AggregateHabitCategory[P]>
  }




  export type HabitCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitCategoryWhereInput
    orderBy?: HabitCategoryOrderByWithAggregationInput | HabitCategoryOrderByWithAggregationInput[]
    by: HabitCategoryScalarFieldEnum[] | HabitCategoryScalarFieldEnum
    having?: HabitCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HabitCategoryCountAggregateInputType | true
    _min?: HabitCategoryMinAggregateInputType
    _max?: HabitCategoryMaxAggregateInputType
  }

  export type HabitCategoryGroupByOutputType = {
    id: string
    name: string
    biomeType: string
    mountainIcon: string
    mountainImage: string | null
    primaryColor: string
    secondaryColor: string
    createdAt: Date
    updatedAt: Date
    _count: HabitCategoryCountAggregateOutputType | null
    _min: HabitCategoryMinAggregateOutputType | null
    _max: HabitCategoryMaxAggregateOutputType | null
  }

  type GetHabitCategoryGroupByPayload<T extends HabitCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HabitCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HabitCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HabitCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], HabitCategoryGroupByOutputType[P]>
        }
      >
    >


  export type HabitCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    biomeType?: boolean
    mountainIcon?: boolean
    mountainImage?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    habits?: boolean | HabitCategory$habitsArgs<ExtArgs>
    activeClimbers?: boolean | HabitCategory$activeClimbersArgs<ExtArgs>
    _count?: boolean | HabitCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habitCategory"]>

  export type HabitCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    biomeType?: boolean
    mountainIcon?: boolean
    mountainImage?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["habitCategory"]>

  export type HabitCategorySelectScalar = {
    id?: boolean
    name?: boolean
    biomeType?: boolean
    mountainIcon?: boolean
    mountainImage?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HabitCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habits?: boolean | HabitCategory$habitsArgs<ExtArgs>
    activeClimbers?: boolean | HabitCategory$activeClimbersArgs<ExtArgs>
    _count?: boolean | HabitCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HabitCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HabitCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HabitCategory"
    objects: {
      habits: Prisma.$HabitPayload<ExtArgs>[]
      activeClimbers: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      biomeType: string
      mountainIcon: string
      mountainImage: string | null
      primaryColor: string
      secondaryColor: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["habitCategory"]>
    composites: {}
  }

  type HabitCategoryGetPayload<S extends boolean | null | undefined | HabitCategoryDefaultArgs> = $Result.GetResult<Prisma.$HabitCategoryPayload, S>

  type HabitCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HabitCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HabitCategoryCountAggregateInputType | true
    }

  export interface HabitCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HabitCategory'], meta: { name: 'HabitCategory' } }
    /**
     * Find zero or one HabitCategory that matches the filter.
     * @param {HabitCategoryFindUniqueArgs} args - Arguments to find a HabitCategory
     * @example
     * // Get one HabitCategory
     * const habitCategory = await prisma.habitCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HabitCategoryFindUniqueArgs>(args: SelectSubset<T, HabitCategoryFindUniqueArgs<ExtArgs>>): Prisma__HabitCategoryClient<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HabitCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HabitCategoryFindUniqueOrThrowArgs} args - Arguments to find a HabitCategory
     * @example
     * // Get one HabitCategory
     * const habitCategory = await prisma.habitCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HabitCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, HabitCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HabitCategoryClient<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HabitCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCategoryFindFirstArgs} args - Arguments to find a HabitCategory
     * @example
     * // Get one HabitCategory
     * const habitCategory = await prisma.habitCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HabitCategoryFindFirstArgs>(args?: SelectSubset<T, HabitCategoryFindFirstArgs<ExtArgs>>): Prisma__HabitCategoryClient<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HabitCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCategoryFindFirstOrThrowArgs} args - Arguments to find a HabitCategory
     * @example
     * // Get one HabitCategory
     * const habitCategory = await prisma.habitCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HabitCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, HabitCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__HabitCategoryClient<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HabitCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HabitCategories
     * const habitCategories = await prisma.habitCategory.findMany()
     * 
     * // Get first 10 HabitCategories
     * const habitCategories = await prisma.habitCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const habitCategoryWithIdOnly = await prisma.habitCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HabitCategoryFindManyArgs>(args?: SelectSubset<T, HabitCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HabitCategory.
     * @param {HabitCategoryCreateArgs} args - Arguments to create a HabitCategory.
     * @example
     * // Create one HabitCategory
     * const HabitCategory = await prisma.habitCategory.create({
     *   data: {
     *     // ... data to create a HabitCategory
     *   }
     * })
     * 
     */
    create<T extends HabitCategoryCreateArgs>(args: SelectSubset<T, HabitCategoryCreateArgs<ExtArgs>>): Prisma__HabitCategoryClient<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HabitCategories.
     * @param {HabitCategoryCreateManyArgs} args - Arguments to create many HabitCategories.
     * @example
     * // Create many HabitCategories
     * const habitCategory = await prisma.habitCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HabitCategoryCreateManyArgs>(args?: SelectSubset<T, HabitCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HabitCategories and returns the data saved in the database.
     * @param {HabitCategoryCreateManyAndReturnArgs} args - Arguments to create many HabitCategories.
     * @example
     * // Create many HabitCategories
     * const habitCategory = await prisma.habitCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HabitCategories and only return the `id`
     * const habitCategoryWithIdOnly = await prisma.habitCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HabitCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, HabitCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HabitCategory.
     * @param {HabitCategoryDeleteArgs} args - Arguments to delete one HabitCategory.
     * @example
     * // Delete one HabitCategory
     * const HabitCategory = await prisma.habitCategory.delete({
     *   where: {
     *     // ... filter to delete one HabitCategory
     *   }
     * })
     * 
     */
    delete<T extends HabitCategoryDeleteArgs>(args: SelectSubset<T, HabitCategoryDeleteArgs<ExtArgs>>): Prisma__HabitCategoryClient<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HabitCategory.
     * @param {HabitCategoryUpdateArgs} args - Arguments to update one HabitCategory.
     * @example
     * // Update one HabitCategory
     * const habitCategory = await prisma.habitCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HabitCategoryUpdateArgs>(args: SelectSubset<T, HabitCategoryUpdateArgs<ExtArgs>>): Prisma__HabitCategoryClient<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HabitCategories.
     * @param {HabitCategoryDeleteManyArgs} args - Arguments to filter HabitCategories to delete.
     * @example
     * // Delete a few HabitCategories
     * const { count } = await prisma.habitCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HabitCategoryDeleteManyArgs>(args?: SelectSubset<T, HabitCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HabitCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HabitCategories
     * const habitCategory = await prisma.habitCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HabitCategoryUpdateManyArgs>(args: SelectSubset<T, HabitCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HabitCategory.
     * @param {HabitCategoryUpsertArgs} args - Arguments to update or create a HabitCategory.
     * @example
     * // Update or create a HabitCategory
     * const habitCategory = await prisma.habitCategory.upsert({
     *   create: {
     *     // ... data to create a HabitCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HabitCategory we want to update
     *   }
     * })
     */
    upsert<T extends HabitCategoryUpsertArgs>(args: SelectSubset<T, HabitCategoryUpsertArgs<ExtArgs>>): Prisma__HabitCategoryClient<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HabitCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCategoryCountArgs} args - Arguments to filter HabitCategories to count.
     * @example
     * // Count the number of HabitCategories
     * const count = await prisma.habitCategory.count({
     *   where: {
     *     // ... the filter for the HabitCategories we want to count
     *   }
     * })
    **/
    count<T extends HabitCategoryCountArgs>(
      args?: Subset<T, HabitCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HabitCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HabitCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HabitCategoryAggregateArgs>(args: Subset<T, HabitCategoryAggregateArgs>): Prisma.PrismaPromise<GetHabitCategoryAggregateType<T>>

    /**
     * Group by HabitCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HabitCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HabitCategoryGroupByArgs['orderBy'] }
        : { orderBy?: HabitCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HabitCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabitCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HabitCategory model
   */
  readonly fields: HabitCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HabitCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HabitCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    habits<T extends HabitCategory$habitsArgs<ExtArgs> = {}>(args?: Subset<T, HabitCategory$habitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findMany"> | Null>
    activeClimbers<T extends HabitCategory$activeClimbersArgs<ExtArgs> = {}>(args?: Subset<T, HabitCategory$activeClimbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HabitCategory model
   */ 
  interface HabitCategoryFieldRefs {
    readonly id: FieldRef<"HabitCategory", 'String'>
    readonly name: FieldRef<"HabitCategory", 'String'>
    readonly biomeType: FieldRef<"HabitCategory", 'String'>
    readonly mountainIcon: FieldRef<"HabitCategory", 'String'>
    readonly mountainImage: FieldRef<"HabitCategory", 'String'>
    readonly primaryColor: FieldRef<"HabitCategory", 'String'>
    readonly secondaryColor: FieldRef<"HabitCategory", 'String'>
    readonly createdAt: FieldRef<"HabitCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"HabitCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HabitCategory findUnique
   */
  export type HabitCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HabitCategory to fetch.
     */
    where: HabitCategoryWhereUniqueInput
  }

  /**
   * HabitCategory findUniqueOrThrow
   */
  export type HabitCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HabitCategory to fetch.
     */
    where: HabitCategoryWhereUniqueInput
  }

  /**
   * HabitCategory findFirst
   */
  export type HabitCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HabitCategory to fetch.
     */
    where?: HabitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitCategories to fetch.
     */
    orderBy?: HabitCategoryOrderByWithRelationInput | HabitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HabitCategories.
     */
    cursor?: HabitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HabitCategories.
     */
    distinct?: HabitCategoryScalarFieldEnum | HabitCategoryScalarFieldEnum[]
  }

  /**
   * HabitCategory findFirstOrThrow
   */
  export type HabitCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HabitCategory to fetch.
     */
    where?: HabitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitCategories to fetch.
     */
    orderBy?: HabitCategoryOrderByWithRelationInput | HabitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HabitCategories.
     */
    cursor?: HabitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HabitCategories.
     */
    distinct?: HabitCategoryScalarFieldEnum | HabitCategoryScalarFieldEnum[]
  }

  /**
   * HabitCategory findMany
   */
  export type HabitCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HabitCategories to fetch.
     */
    where?: HabitCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitCategories to fetch.
     */
    orderBy?: HabitCategoryOrderByWithRelationInput | HabitCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HabitCategories.
     */
    cursor?: HabitCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitCategories.
     */
    skip?: number
    distinct?: HabitCategoryScalarFieldEnum | HabitCategoryScalarFieldEnum[]
  }

  /**
   * HabitCategory create
   */
  export type HabitCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a HabitCategory.
     */
    data: XOR<HabitCategoryCreateInput, HabitCategoryUncheckedCreateInput>
  }

  /**
   * HabitCategory createMany
   */
  export type HabitCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HabitCategories.
     */
    data: HabitCategoryCreateManyInput | HabitCategoryCreateManyInput[]
  }

  /**
   * HabitCategory createManyAndReturn
   */
  export type HabitCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HabitCategories.
     */
    data: HabitCategoryCreateManyInput | HabitCategoryCreateManyInput[]
  }

  /**
   * HabitCategory update
   */
  export type HabitCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a HabitCategory.
     */
    data: XOR<HabitCategoryUpdateInput, HabitCategoryUncheckedUpdateInput>
    /**
     * Choose, which HabitCategory to update.
     */
    where: HabitCategoryWhereUniqueInput
  }

  /**
   * HabitCategory updateMany
   */
  export type HabitCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HabitCategories.
     */
    data: XOR<HabitCategoryUpdateManyMutationInput, HabitCategoryUncheckedUpdateManyInput>
    /**
     * Filter which HabitCategories to update
     */
    where?: HabitCategoryWhereInput
  }

  /**
   * HabitCategory upsert
   */
  export type HabitCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the HabitCategory to update in case it exists.
     */
    where: HabitCategoryWhereUniqueInput
    /**
     * In case the HabitCategory found by the `where` argument doesn't exist, create a new HabitCategory with this data.
     */
    create: XOR<HabitCategoryCreateInput, HabitCategoryUncheckedCreateInput>
    /**
     * In case the HabitCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HabitCategoryUpdateInput, HabitCategoryUncheckedUpdateInput>
  }

  /**
   * HabitCategory delete
   */
  export type HabitCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
    /**
     * Filter which HabitCategory to delete.
     */
    where: HabitCategoryWhereUniqueInput
  }

  /**
   * HabitCategory deleteMany
   */
  export type HabitCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HabitCategories to delete
     */
    where?: HabitCategoryWhereInput
  }

  /**
   * HabitCategory.habits
   */
  export type HabitCategory$habitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    where?: HabitWhereInput
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    cursor?: HabitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * HabitCategory.activeClimbers
   */
  export type HabitCategory$activeClimbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * HabitCategory without action
   */
  export type HabitCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitCategory
     */
    select?: HabitCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Habit
   */

  export type AggregateHabit = {
    _count: HabitCountAggregateOutputType | null
    _avg: HabitAvgAggregateOutputType | null
    _sum: HabitSumAggregateOutputType | null
    _min: HabitMinAggregateOutputType | null
    _max: HabitMaxAggregateOutputType | null
  }

  export type HabitAvgAggregateOutputType = {
    rating: number | null
  }

  export type HabitSumAggregateOutputType = {
    rating: number | null
  }

  export type HabitMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    title: string | null
    difficulty: string | null
    description: string | null
    rating: number | null
    maturity: string | null
    submissionType: string | null
    tips: string | null
    preChallengeGuide: string | null
    incentives: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    title: string | null
    difficulty: string | null
    description: string | null
    rating: number | null
    maturity: string | null
    submissionType: string | null
    tips: string | null
    preChallengeGuide: string | null
    incentives: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitCountAggregateOutputType = {
    id: number
    categoryId: number
    title: number
    difficulty: number
    description: number
    rating: number
    maturity: number
    submissionType: number
    tips: number
    preChallengeGuide: number
    incentives: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HabitAvgAggregateInputType = {
    rating?: true
  }

  export type HabitSumAggregateInputType = {
    rating?: true
  }

  export type HabitMinAggregateInputType = {
    id?: true
    categoryId?: true
    title?: true
    difficulty?: true
    description?: true
    rating?: true
    maturity?: true
    submissionType?: true
    tips?: true
    preChallengeGuide?: true
    incentives?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitMaxAggregateInputType = {
    id?: true
    categoryId?: true
    title?: true
    difficulty?: true
    description?: true
    rating?: true
    maturity?: true
    submissionType?: true
    tips?: true
    preChallengeGuide?: true
    incentives?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitCountAggregateInputType = {
    id?: true
    categoryId?: true
    title?: true
    difficulty?: true
    description?: true
    rating?: true
    maturity?: true
    submissionType?: true
    tips?: true
    preChallengeGuide?: true
    incentives?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HabitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Habit to aggregate.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Habits
    **/
    _count?: true | HabitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HabitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HabitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HabitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HabitMaxAggregateInputType
  }

  export type GetHabitAggregateType<T extends HabitAggregateArgs> = {
        [P in keyof T & keyof AggregateHabit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabit[P]>
      : GetScalarType<T[P], AggregateHabit[P]>
  }




  export type HabitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitWhereInput
    orderBy?: HabitOrderByWithAggregationInput | HabitOrderByWithAggregationInput[]
    by: HabitScalarFieldEnum[] | HabitScalarFieldEnum
    having?: HabitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HabitCountAggregateInputType | true
    _avg?: HabitAvgAggregateInputType
    _sum?: HabitSumAggregateInputType
    _min?: HabitMinAggregateInputType
    _max?: HabitMaxAggregateInputType
  }

  export type HabitGroupByOutputType = {
    id: string
    categoryId: string
    title: string
    difficulty: string
    description: string | null
    rating: number
    maturity: string | null
    submissionType: string
    tips: string | null
    preChallengeGuide: string | null
    incentives: string | null
    createdAt: Date
    updatedAt: Date
    _count: HabitCountAggregateOutputType | null
    _avg: HabitAvgAggregateOutputType | null
    _sum: HabitSumAggregateOutputType | null
    _min: HabitMinAggregateOutputType | null
    _max: HabitMaxAggregateOutputType | null
  }

  type GetHabitGroupByPayload<T extends HabitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HabitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HabitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HabitGroupByOutputType[P]>
            : GetScalarType<T[P], HabitGroupByOutputType[P]>
        }
      >
    >


  export type HabitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    title?: boolean
    difficulty?: boolean
    description?: boolean
    rating?: boolean
    maturity?: boolean
    submissionType?: boolean
    tips?: boolean
    preChallengeGuide?: boolean
    incentives?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | HabitCategoryDefaultArgs<ExtArgs>
    joinedUsers?: boolean | Habit$joinedUsersArgs<ExtArgs>
    proofs?: boolean | Habit$proofsArgs<ExtArgs>
    invites?: boolean | Habit$invitesArgs<ExtArgs>
    userSettings?: boolean | Habit$userSettingsArgs<ExtArgs>
    _count?: boolean | HabitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habit"]>

  export type HabitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    title?: boolean
    difficulty?: boolean
    description?: boolean
    rating?: boolean
    maturity?: boolean
    submissionType?: boolean
    tips?: boolean
    preChallengeGuide?: boolean
    incentives?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | HabitCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habit"]>

  export type HabitSelectScalar = {
    id?: boolean
    categoryId?: boolean
    title?: boolean
    difficulty?: boolean
    description?: boolean
    rating?: boolean
    maturity?: boolean
    submissionType?: boolean
    tips?: boolean
    preChallengeGuide?: boolean
    incentives?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HabitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | HabitCategoryDefaultArgs<ExtArgs>
    joinedUsers?: boolean | Habit$joinedUsersArgs<ExtArgs>
    proofs?: boolean | Habit$proofsArgs<ExtArgs>
    invites?: boolean | Habit$invitesArgs<ExtArgs>
    userSettings?: boolean | Habit$userSettingsArgs<ExtArgs>
    _count?: boolean | HabitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HabitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | HabitCategoryDefaultArgs<ExtArgs>
  }

  export type $HabitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Habit"
    objects: {
      category: Prisma.$HabitCategoryPayload<ExtArgs>
      joinedUsers: Prisma.$UserPayload<ExtArgs>[]
      proofs: Prisma.$HabitProofPayload<ExtArgs>[]
      invites: Prisma.$HabitInvitePayload<ExtArgs>[]
      userSettings: Prisma.$HabitUserSettingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      title: string
      difficulty: string
      description: string | null
      rating: number
      maturity: string | null
      submissionType: string
      tips: string | null
      preChallengeGuide: string | null
      incentives: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["habit"]>
    composites: {}
  }

  type HabitGetPayload<S extends boolean | null | undefined | HabitDefaultArgs> = $Result.GetResult<Prisma.$HabitPayload, S>

  type HabitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HabitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HabitCountAggregateInputType | true
    }

  export interface HabitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Habit'], meta: { name: 'Habit' } }
    /**
     * Find zero or one Habit that matches the filter.
     * @param {HabitFindUniqueArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HabitFindUniqueArgs>(args: SelectSubset<T, HabitFindUniqueArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Habit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HabitFindUniqueOrThrowArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HabitFindUniqueOrThrowArgs>(args: SelectSubset<T, HabitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Habit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitFindFirstArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HabitFindFirstArgs>(args?: SelectSubset<T, HabitFindFirstArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Habit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitFindFirstOrThrowArgs} args - Arguments to find a Habit
     * @example
     * // Get one Habit
     * const habit = await prisma.habit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HabitFindFirstOrThrowArgs>(args?: SelectSubset<T, HabitFindFirstOrThrowArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Habits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Habits
     * const habits = await prisma.habit.findMany()
     * 
     * // Get first 10 Habits
     * const habits = await prisma.habit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const habitWithIdOnly = await prisma.habit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HabitFindManyArgs>(args?: SelectSubset<T, HabitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Habit.
     * @param {HabitCreateArgs} args - Arguments to create a Habit.
     * @example
     * // Create one Habit
     * const Habit = await prisma.habit.create({
     *   data: {
     *     // ... data to create a Habit
     *   }
     * })
     * 
     */
    create<T extends HabitCreateArgs>(args: SelectSubset<T, HabitCreateArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Habits.
     * @param {HabitCreateManyArgs} args - Arguments to create many Habits.
     * @example
     * // Create many Habits
     * const habit = await prisma.habit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HabitCreateManyArgs>(args?: SelectSubset<T, HabitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Habits and returns the data saved in the database.
     * @param {HabitCreateManyAndReturnArgs} args - Arguments to create many Habits.
     * @example
     * // Create many Habits
     * const habit = await prisma.habit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Habits and only return the `id`
     * const habitWithIdOnly = await prisma.habit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HabitCreateManyAndReturnArgs>(args?: SelectSubset<T, HabitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Habit.
     * @param {HabitDeleteArgs} args - Arguments to delete one Habit.
     * @example
     * // Delete one Habit
     * const Habit = await prisma.habit.delete({
     *   where: {
     *     // ... filter to delete one Habit
     *   }
     * })
     * 
     */
    delete<T extends HabitDeleteArgs>(args: SelectSubset<T, HabitDeleteArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Habit.
     * @param {HabitUpdateArgs} args - Arguments to update one Habit.
     * @example
     * // Update one Habit
     * const habit = await prisma.habit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HabitUpdateArgs>(args: SelectSubset<T, HabitUpdateArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Habits.
     * @param {HabitDeleteManyArgs} args - Arguments to filter Habits to delete.
     * @example
     * // Delete a few Habits
     * const { count } = await prisma.habit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HabitDeleteManyArgs>(args?: SelectSubset<T, HabitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Habits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Habits
     * const habit = await prisma.habit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HabitUpdateManyArgs>(args: SelectSubset<T, HabitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Habit.
     * @param {HabitUpsertArgs} args - Arguments to update or create a Habit.
     * @example
     * // Update or create a Habit
     * const habit = await prisma.habit.upsert({
     *   create: {
     *     // ... data to create a Habit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Habit we want to update
     *   }
     * })
     */
    upsert<T extends HabitUpsertArgs>(args: SelectSubset<T, HabitUpsertArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Habits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitCountArgs} args - Arguments to filter Habits to count.
     * @example
     * // Count the number of Habits
     * const count = await prisma.habit.count({
     *   where: {
     *     // ... the filter for the Habits we want to count
     *   }
     * })
    **/
    count<T extends HabitCountArgs>(
      args?: Subset<T, HabitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HabitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Habit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HabitAggregateArgs>(args: Subset<T, HabitAggregateArgs>): Prisma.PrismaPromise<GetHabitAggregateType<T>>

    /**
     * Group by Habit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HabitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HabitGroupByArgs['orderBy'] }
        : { orderBy?: HabitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HabitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Habit model
   */
  readonly fields: HabitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Habit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HabitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends HabitCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HabitCategoryDefaultArgs<ExtArgs>>): Prisma__HabitCategoryClient<$Result.GetResult<Prisma.$HabitCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    joinedUsers<T extends Habit$joinedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Habit$joinedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    proofs<T extends Habit$proofsArgs<ExtArgs> = {}>(args?: Subset<T, Habit$proofsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "findMany"> | Null>
    invites<T extends Habit$invitesArgs<ExtArgs> = {}>(args?: Subset<T, Habit$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "findMany"> | Null>
    userSettings<T extends Habit$userSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Habit$userSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Habit model
   */ 
  interface HabitFieldRefs {
    readonly id: FieldRef<"Habit", 'String'>
    readonly categoryId: FieldRef<"Habit", 'String'>
    readonly title: FieldRef<"Habit", 'String'>
    readonly difficulty: FieldRef<"Habit", 'String'>
    readonly description: FieldRef<"Habit", 'String'>
    readonly rating: FieldRef<"Habit", 'Float'>
    readonly maturity: FieldRef<"Habit", 'String'>
    readonly submissionType: FieldRef<"Habit", 'String'>
    readonly tips: FieldRef<"Habit", 'String'>
    readonly preChallengeGuide: FieldRef<"Habit", 'String'>
    readonly incentives: FieldRef<"Habit", 'String'>
    readonly createdAt: FieldRef<"Habit", 'DateTime'>
    readonly updatedAt: FieldRef<"Habit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Habit findUnique
   */
  export type HabitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit findUniqueOrThrow
   */
  export type HabitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit findFirst
   */
  export type HabitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Habits.
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Habits.
     */
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * Habit findFirstOrThrow
   */
  export type HabitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habit to fetch.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Habits.
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Habits.
     */
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * Habit findMany
   */
  export type HabitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter, which Habits to fetch.
     */
    where?: HabitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Habits to fetch.
     */
    orderBy?: HabitOrderByWithRelationInput | HabitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Habits.
     */
    cursor?: HabitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Habits.
     */
    skip?: number
    distinct?: HabitScalarFieldEnum | HabitScalarFieldEnum[]
  }

  /**
   * Habit create
   */
  export type HabitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * The data needed to create a Habit.
     */
    data: XOR<HabitCreateInput, HabitUncheckedCreateInput>
  }

  /**
   * Habit createMany
   */
  export type HabitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Habits.
     */
    data: HabitCreateManyInput | HabitCreateManyInput[]
  }

  /**
   * Habit createManyAndReturn
   */
  export type HabitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Habits.
     */
    data: HabitCreateManyInput | HabitCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Habit update
   */
  export type HabitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * The data needed to update a Habit.
     */
    data: XOR<HabitUpdateInput, HabitUncheckedUpdateInput>
    /**
     * Choose, which Habit to update.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit updateMany
   */
  export type HabitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Habits.
     */
    data: XOR<HabitUpdateManyMutationInput, HabitUncheckedUpdateManyInput>
    /**
     * Filter which Habits to update
     */
    where?: HabitWhereInput
  }

  /**
   * Habit upsert
   */
  export type HabitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * The filter to search for the Habit to update in case it exists.
     */
    where: HabitWhereUniqueInput
    /**
     * In case the Habit found by the `where` argument doesn't exist, create a new Habit with this data.
     */
    create: XOR<HabitCreateInput, HabitUncheckedCreateInput>
    /**
     * In case the Habit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HabitUpdateInput, HabitUncheckedUpdateInput>
  }

  /**
   * Habit delete
   */
  export type HabitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    /**
     * Filter which Habit to delete.
     */
    where: HabitWhereUniqueInput
  }

  /**
   * Habit deleteMany
   */
  export type HabitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Habits to delete
     */
    where?: HabitWhereInput
  }

  /**
   * Habit.joinedUsers
   */
  export type Habit$joinedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Habit.proofs
   */
  export type Habit$proofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    where?: HabitProofWhereInput
    orderBy?: HabitProofOrderByWithRelationInput | HabitProofOrderByWithRelationInput[]
    cursor?: HabitProofWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitProofScalarFieldEnum | HabitProofScalarFieldEnum[]
  }

  /**
   * Habit.invites
   */
  export type Habit$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    where?: HabitInviteWhereInput
    orderBy?: HabitInviteOrderByWithRelationInput | HabitInviteOrderByWithRelationInput[]
    cursor?: HabitInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitInviteScalarFieldEnum | HabitInviteScalarFieldEnum[]
  }

  /**
   * Habit.userSettings
   */
  export type Habit$userSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    where?: HabitUserSettingsWhereInput
    orderBy?: HabitUserSettingsOrderByWithRelationInput | HabitUserSettingsOrderByWithRelationInput[]
    cursor?: HabitUserSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitUserSettingsScalarFieldEnum | HabitUserSettingsScalarFieldEnum[]
  }

  /**
   * Habit without action
   */
  export type HabitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
  }


  /**
   * Model HabitUserSettings
   */

  export type AggregateHabitUserSettings = {
    _count: HabitUserSettingsCountAggregateOutputType | null
    _avg: HabitUserSettingsAvgAggregateOutputType | null
    _sum: HabitUserSettingsSumAggregateOutputType | null
    _min: HabitUserSettingsMinAggregateOutputType | null
    _max: HabitUserSettingsMaxAggregateOutputType | null
  }

  export type HabitUserSettingsAvgAggregateOutputType = {
    rating: number | null
  }

  export type HabitUserSettingsSumAggregateOutputType = {
    rating: number | null
  }

  export type HabitUserSettingsMinAggregateOutputType = {
    userId: string | null
    habitId: string | null
    isFavorite: boolean | null
    notifyMe: boolean | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitUserSettingsMaxAggregateOutputType = {
    userId: string | null
    habitId: string | null
    isFavorite: boolean | null
    notifyMe: boolean | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitUserSettingsCountAggregateOutputType = {
    userId: number
    habitId: number
    isFavorite: number
    notifyMe: number
    rating: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HabitUserSettingsAvgAggregateInputType = {
    rating?: true
  }

  export type HabitUserSettingsSumAggregateInputType = {
    rating?: true
  }

  export type HabitUserSettingsMinAggregateInputType = {
    userId?: true
    habitId?: true
    isFavorite?: true
    notifyMe?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitUserSettingsMaxAggregateInputType = {
    userId?: true
    habitId?: true
    isFavorite?: true
    notifyMe?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitUserSettingsCountAggregateInputType = {
    userId?: true
    habitId?: true
    isFavorite?: true
    notifyMe?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HabitUserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HabitUserSettings to aggregate.
     */
    where?: HabitUserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitUserSettings to fetch.
     */
    orderBy?: HabitUserSettingsOrderByWithRelationInput | HabitUserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HabitUserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitUserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitUserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HabitUserSettings
    **/
    _count?: true | HabitUserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HabitUserSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HabitUserSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HabitUserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HabitUserSettingsMaxAggregateInputType
  }

  export type GetHabitUserSettingsAggregateType<T extends HabitUserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateHabitUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabitUserSettings[P]>
      : GetScalarType<T[P], AggregateHabitUserSettings[P]>
  }




  export type HabitUserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitUserSettingsWhereInput
    orderBy?: HabitUserSettingsOrderByWithAggregationInput | HabitUserSettingsOrderByWithAggregationInput[]
    by: HabitUserSettingsScalarFieldEnum[] | HabitUserSettingsScalarFieldEnum
    having?: HabitUserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HabitUserSettingsCountAggregateInputType | true
    _avg?: HabitUserSettingsAvgAggregateInputType
    _sum?: HabitUserSettingsSumAggregateInputType
    _min?: HabitUserSettingsMinAggregateInputType
    _max?: HabitUserSettingsMaxAggregateInputType
  }

  export type HabitUserSettingsGroupByOutputType = {
    userId: string
    habitId: string
    isFavorite: boolean
    notifyMe: boolean
    rating: number | null
    createdAt: Date
    updatedAt: Date
    _count: HabitUserSettingsCountAggregateOutputType | null
    _avg: HabitUserSettingsAvgAggregateOutputType | null
    _sum: HabitUserSettingsSumAggregateOutputType | null
    _min: HabitUserSettingsMinAggregateOutputType | null
    _max: HabitUserSettingsMaxAggregateOutputType | null
  }

  type GetHabitUserSettingsGroupByPayload<T extends HabitUserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HabitUserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HabitUserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HabitUserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], HabitUserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type HabitUserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    habitId?: boolean
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    habit?: boolean | HabitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habitUserSettings"]>

  export type HabitUserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    habitId?: boolean
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    habit?: boolean | HabitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habitUserSettings"]>

  export type HabitUserSettingsSelectScalar = {
    userId?: boolean
    habitId?: boolean
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HabitUserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    habit?: boolean | HabitDefaultArgs<ExtArgs>
  }
  export type HabitUserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    habit?: boolean | HabitDefaultArgs<ExtArgs>
  }

  export type $HabitUserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HabitUserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      habit: Prisma.$HabitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      habitId: string
      isFavorite: boolean
      notifyMe: boolean
      rating: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["habitUserSettings"]>
    composites: {}
  }

  type HabitUserSettingsGetPayload<S extends boolean | null | undefined | HabitUserSettingsDefaultArgs> = $Result.GetResult<Prisma.$HabitUserSettingsPayload, S>

  type HabitUserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HabitUserSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HabitUserSettingsCountAggregateInputType | true
    }

  export interface HabitUserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HabitUserSettings'], meta: { name: 'HabitUserSettings' } }
    /**
     * Find zero or one HabitUserSettings that matches the filter.
     * @param {HabitUserSettingsFindUniqueArgs} args - Arguments to find a HabitUserSettings
     * @example
     * // Get one HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HabitUserSettingsFindUniqueArgs>(args: SelectSubset<T, HabitUserSettingsFindUniqueArgs<ExtArgs>>): Prisma__HabitUserSettingsClient<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HabitUserSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HabitUserSettingsFindUniqueOrThrowArgs} args - Arguments to find a HabitUserSettings
     * @example
     * // Get one HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HabitUserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, HabitUserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HabitUserSettingsClient<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HabitUserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitUserSettingsFindFirstArgs} args - Arguments to find a HabitUserSettings
     * @example
     * // Get one HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HabitUserSettingsFindFirstArgs>(args?: SelectSubset<T, HabitUserSettingsFindFirstArgs<ExtArgs>>): Prisma__HabitUserSettingsClient<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HabitUserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitUserSettingsFindFirstOrThrowArgs} args - Arguments to find a HabitUserSettings
     * @example
     * // Get one HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HabitUserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, HabitUserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__HabitUserSettingsClient<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HabitUserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitUserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.findMany()
     * 
     * // Get first 10 HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const habitUserSettingsWithUserIdOnly = await prisma.habitUserSettings.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends HabitUserSettingsFindManyArgs>(args?: SelectSubset<T, HabitUserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HabitUserSettings.
     * @param {HabitUserSettingsCreateArgs} args - Arguments to create a HabitUserSettings.
     * @example
     * // Create one HabitUserSettings
     * const HabitUserSettings = await prisma.habitUserSettings.create({
     *   data: {
     *     // ... data to create a HabitUserSettings
     *   }
     * })
     * 
     */
    create<T extends HabitUserSettingsCreateArgs>(args: SelectSubset<T, HabitUserSettingsCreateArgs<ExtArgs>>): Prisma__HabitUserSettingsClient<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HabitUserSettings.
     * @param {HabitUserSettingsCreateManyArgs} args - Arguments to create many HabitUserSettings.
     * @example
     * // Create many HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HabitUserSettingsCreateManyArgs>(args?: SelectSubset<T, HabitUserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HabitUserSettings and returns the data saved in the database.
     * @param {HabitUserSettingsCreateManyAndReturnArgs} args - Arguments to create many HabitUserSettings.
     * @example
     * // Create many HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HabitUserSettings and only return the `userId`
     * const habitUserSettingsWithUserIdOnly = await prisma.habitUserSettings.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HabitUserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, HabitUserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HabitUserSettings.
     * @param {HabitUserSettingsDeleteArgs} args - Arguments to delete one HabitUserSettings.
     * @example
     * // Delete one HabitUserSettings
     * const HabitUserSettings = await prisma.habitUserSettings.delete({
     *   where: {
     *     // ... filter to delete one HabitUserSettings
     *   }
     * })
     * 
     */
    delete<T extends HabitUserSettingsDeleteArgs>(args: SelectSubset<T, HabitUserSettingsDeleteArgs<ExtArgs>>): Prisma__HabitUserSettingsClient<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HabitUserSettings.
     * @param {HabitUserSettingsUpdateArgs} args - Arguments to update one HabitUserSettings.
     * @example
     * // Update one HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HabitUserSettingsUpdateArgs>(args: SelectSubset<T, HabitUserSettingsUpdateArgs<ExtArgs>>): Prisma__HabitUserSettingsClient<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HabitUserSettings.
     * @param {HabitUserSettingsDeleteManyArgs} args - Arguments to filter HabitUserSettings to delete.
     * @example
     * // Delete a few HabitUserSettings
     * const { count } = await prisma.habitUserSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HabitUserSettingsDeleteManyArgs>(args?: SelectSubset<T, HabitUserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HabitUserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitUserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HabitUserSettingsUpdateManyArgs>(args: SelectSubset<T, HabitUserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HabitUserSettings.
     * @param {HabitUserSettingsUpsertArgs} args - Arguments to update or create a HabitUserSettings.
     * @example
     * // Update or create a HabitUserSettings
     * const habitUserSettings = await prisma.habitUserSettings.upsert({
     *   create: {
     *     // ... data to create a HabitUserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HabitUserSettings we want to update
     *   }
     * })
     */
    upsert<T extends HabitUserSettingsUpsertArgs>(args: SelectSubset<T, HabitUserSettingsUpsertArgs<ExtArgs>>): Prisma__HabitUserSettingsClient<$Result.GetResult<Prisma.$HabitUserSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HabitUserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitUserSettingsCountArgs} args - Arguments to filter HabitUserSettings to count.
     * @example
     * // Count the number of HabitUserSettings
     * const count = await prisma.habitUserSettings.count({
     *   where: {
     *     // ... the filter for the HabitUserSettings we want to count
     *   }
     * })
    **/
    count<T extends HabitUserSettingsCountArgs>(
      args?: Subset<T, HabitUserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HabitUserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HabitUserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitUserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HabitUserSettingsAggregateArgs>(args: Subset<T, HabitUserSettingsAggregateArgs>): Prisma.PrismaPromise<GetHabitUserSettingsAggregateType<T>>

    /**
     * Group by HabitUserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitUserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HabitUserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HabitUserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: HabitUserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HabitUserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabitUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HabitUserSettings model
   */
  readonly fields: HabitUserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HabitUserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HabitUserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    habit<T extends HabitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HabitDefaultArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HabitUserSettings model
   */ 
  interface HabitUserSettingsFieldRefs {
    readonly userId: FieldRef<"HabitUserSettings", 'String'>
    readonly habitId: FieldRef<"HabitUserSettings", 'String'>
    readonly isFavorite: FieldRef<"HabitUserSettings", 'Boolean'>
    readonly notifyMe: FieldRef<"HabitUserSettings", 'Boolean'>
    readonly rating: FieldRef<"HabitUserSettings", 'Int'>
    readonly createdAt: FieldRef<"HabitUserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"HabitUserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HabitUserSettings findUnique
   */
  export type HabitUserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which HabitUserSettings to fetch.
     */
    where: HabitUserSettingsWhereUniqueInput
  }

  /**
   * HabitUserSettings findUniqueOrThrow
   */
  export type HabitUserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which HabitUserSettings to fetch.
     */
    where: HabitUserSettingsWhereUniqueInput
  }

  /**
   * HabitUserSettings findFirst
   */
  export type HabitUserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which HabitUserSettings to fetch.
     */
    where?: HabitUserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitUserSettings to fetch.
     */
    orderBy?: HabitUserSettingsOrderByWithRelationInput | HabitUserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HabitUserSettings.
     */
    cursor?: HabitUserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitUserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitUserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HabitUserSettings.
     */
    distinct?: HabitUserSettingsScalarFieldEnum | HabitUserSettingsScalarFieldEnum[]
  }

  /**
   * HabitUserSettings findFirstOrThrow
   */
  export type HabitUserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which HabitUserSettings to fetch.
     */
    where?: HabitUserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitUserSettings to fetch.
     */
    orderBy?: HabitUserSettingsOrderByWithRelationInput | HabitUserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HabitUserSettings.
     */
    cursor?: HabitUserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitUserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitUserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HabitUserSettings.
     */
    distinct?: HabitUserSettingsScalarFieldEnum | HabitUserSettingsScalarFieldEnum[]
  }

  /**
   * HabitUserSettings findMany
   */
  export type HabitUserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which HabitUserSettings to fetch.
     */
    where?: HabitUserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitUserSettings to fetch.
     */
    orderBy?: HabitUserSettingsOrderByWithRelationInput | HabitUserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HabitUserSettings.
     */
    cursor?: HabitUserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitUserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitUserSettings.
     */
    skip?: number
    distinct?: HabitUserSettingsScalarFieldEnum | HabitUserSettingsScalarFieldEnum[]
  }

  /**
   * HabitUserSettings create
   */
  export type HabitUserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a HabitUserSettings.
     */
    data: XOR<HabitUserSettingsCreateInput, HabitUserSettingsUncheckedCreateInput>
  }

  /**
   * HabitUserSettings createMany
   */
  export type HabitUserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HabitUserSettings.
     */
    data: HabitUserSettingsCreateManyInput | HabitUserSettingsCreateManyInput[]
  }

  /**
   * HabitUserSettings createManyAndReturn
   */
  export type HabitUserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HabitUserSettings.
     */
    data: HabitUserSettingsCreateManyInput | HabitUserSettingsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HabitUserSettings update
   */
  export type HabitUserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a HabitUserSettings.
     */
    data: XOR<HabitUserSettingsUpdateInput, HabitUserSettingsUncheckedUpdateInput>
    /**
     * Choose, which HabitUserSettings to update.
     */
    where: HabitUserSettingsWhereUniqueInput
  }

  /**
   * HabitUserSettings updateMany
   */
  export type HabitUserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HabitUserSettings.
     */
    data: XOR<HabitUserSettingsUpdateManyMutationInput, HabitUserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which HabitUserSettings to update
     */
    where?: HabitUserSettingsWhereInput
  }

  /**
   * HabitUserSettings upsert
   */
  export type HabitUserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the HabitUserSettings to update in case it exists.
     */
    where: HabitUserSettingsWhereUniqueInput
    /**
     * In case the HabitUserSettings found by the `where` argument doesn't exist, create a new HabitUserSettings with this data.
     */
    create: XOR<HabitUserSettingsCreateInput, HabitUserSettingsUncheckedCreateInput>
    /**
     * In case the HabitUserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HabitUserSettingsUpdateInput, HabitUserSettingsUncheckedUpdateInput>
  }

  /**
   * HabitUserSettings delete
   */
  export type HabitUserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
    /**
     * Filter which HabitUserSettings to delete.
     */
    where: HabitUserSettingsWhereUniqueInput
  }

  /**
   * HabitUserSettings deleteMany
   */
  export type HabitUserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HabitUserSettings to delete
     */
    where?: HabitUserSettingsWhereInput
  }

  /**
   * HabitUserSettings without action
   */
  export type HabitUserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitUserSettings
     */
    select?: HabitUserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitUserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model HabitProof
   */

  export type AggregateHabitProof = {
    _count: HabitProofCountAggregateOutputType | null
    _avg: HabitProofAvgAggregateOutputType | null
    _sum: HabitProofSumAggregateOutputType | null
    _min: HabitProofMinAggregateOutputType | null
    _max: HabitProofMaxAggregateOutputType | null
  }

  export type HabitProofAvgAggregateOutputType = {
    round: number | null
  }

  export type HabitProofSumAggregateOutputType = {
    round: number | null
  }

  export type HabitProofMinAggregateOutputType = {
    id: string | null
    userId: string | null
    habitId: string | null
    imageUrl: string | null
    round: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitProofMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    habitId: string | null
    imageUrl: string | null
    round: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitProofCountAggregateOutputType = {
    id: number
    userId: number
    habitId: number
    imageUrl: number
    round: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HabitProofAvgAggregateInputType = {
    round?: true
  }

  export type HabitProofSumAggregateInputType = {
    round?: true
  }

  export type HabitProofMinAggregateInputType = {
    id?: true
    userId?: true
    habitId?: true
    imageUrl?: true
    round?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitProofMaxAggregateInputType = {
    id?: true
    userId?: true
    habitId?: true
    imageUrl?: true
    round?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitProofCountAggregateInputType = {
    id?: true
    userId?: true
    habitId?: true
    imageUrl?: true
    round?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HabitProofAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HabitProof to aggregate.
     */
    where?: HabitProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitProofs to fetch.
     */
    orderBy?: HabitProofOrderByWithRelationInput | HabitProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HabitProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HabitProofs
    **/
    _count?: true | HabitProofCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HabitProofAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HabitProofSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HabitProofMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HabitProofMaxAggregateInputType
  }

  export type GetHabitProofAggregateType<T extends HabitProofAggregateArgs> = {
        [P in keyof T & keyof AggregateHabitProof]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabitProof[P]>
      : GetScalarType<T[P], AggregateHabitProof[P]>
  }




  export type HabitProofGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitProofWhereInput
    orderBy?: HabitProofOrderByWithAggregationInput | HabitProofOrderByWithAggregationInput[]
    by: HabitProofScalarFieldEnum[] | HabitProofScalarFieldEnum
    having?: HabitProofScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HabitProofCountAggregateInputType | true
    _avg?: HabitProofAvgAggregateInputType
    _sum?: HabitProofSumAggregateInputType
    _min?: HabitProofMinAggregateInputType
    _max?: HabitProofMaxAggregateInputType
  }

  export type HabitProofGroupByOutputType = {
    id: string
    userId: string
    habitId: string
    imageUrl: string
    round: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: HabitProofCountAggregateOutputType | null
    _avg: HabitProofAvgAggregateOutputType | null
    _sum: HabitProofSumAggregateOutputType | null
    _min: HabitProofMinAggregateOutputType | null
    _max: HabitProofMaxAggregateOutputType | null
  }

  type GetHabitProofGroupByPayload<T extends HabitProofGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HabitProofGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HabitProofGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HabitProofGroupByOutputType[P]>
            : GetScalarType<T[P], HabitProofGroupByOutputType[P]>
        }
      >
    >


  export type HabitProofSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    habitId?: boolean
    imageUrl?: boolean
    round?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    habit?: boolean | HabitDefaultArgs<ExtArgs>
    votes?: boolean | HabitProof$votesArgs<ExtArgs>
    _count?: boolean | HabitProofCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habitProof"]>

  export type HabitProofSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    habitId?: boolean
    imageUrl?: boolean
    round?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    habit?: boolean | HabitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habitProof"]>

  export type HabitProofSelectScalar = {
    id?: boolean
    userId?: boolean
    habitId?: boolean
    imageUrl?: boolean
    round?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HabitProofInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    habit?: boolean | HabitDefaultArgs<ExtArgs>
    votes?: boolean | HabitProof$votesArgs<ExtArgs>
    _count?: boolean | HabitProofCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HabitProofIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    habit?: boolean | HabitDefaultArgs<ExtArgs>
  }

  export type $HabitProofPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HabitProof"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      habit: Prisma.$HabitPayload<ExtArgs>
      votes: Prisma.$ProofVotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      habitId: string
      imageUrl: string
      round: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["habitProof"]>
    composites: {}
  }

  type HabitProofGetPayload<S extends boolean | null | undefined | HabitProofDefaultArgs> = $Result.GetResult<Prisma.$HabitProofPayload, S>

  type HabitProofCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HabitProofFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HabitProofCountAggregateInputType | true
    }

  export interface HabitProofDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HabitProof'], meta: { name: 'HabitProof' } }
    /**
     * Find zero or one HabitProof that matches the filter.
     * @param {HabitProofFindUniqueArgs} args - Arguments to find a HabitProof
     * @example
     * // Get one HabitProof
     * const habitProof = await prisma.habitProof.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HabitProofFindUniqueArgs>(args: SelectSubset<T, HabitProofFindUniqueArgs<ExtArgs>>): Prisma__HabitProofClient<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HabitProof that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HabitProofFindUniqueOrThrowArgs} args - Arguments to find a HabitProof
     * @example
     * // Get one HabitProof
     * const habitProof = await prisma.habitProof.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HabitProofFindUniqueOrThrowArgs>(args: SelectSubset<T, HabitProofFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HabitProofClient<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HabitProof that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitProofFindFirstArgs} args - Arguments to find a HabitProof
     * @example
     * // Get one HabitProof
     * const habitProof = await prisma.habitProof.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HabitProofFindFirstArgs>(args?: SelectSubset<T, HabitProofFindFirstArgs<ExtArgs>>): Prisma__HabitProofClient<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HabitProof that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitProofFindFirstOrThrowArgs} args - Arguments to find a HabitProof
     * @example
     * // Get one HabitProof
     * const habitProof = await prisma.habitProof.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HabitProofFindFirstOrThrowArgs>(args?: SelectSubset<T, HabitProofFindFirstOrThrowArgs<ExtArgs>>): Prisma__HabitProofClient<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HabitProofs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitProofFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HabitProofs
     * const habitProofs = await prisma.habitProof.findMany()
     * 
     * // Get first 10 HabitProofs
     * const habitProofs = await prisma.habitProof.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const habitProofWithIdOnly = await prisma.habitProof.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HabitProofFindManyArgs>(args?: SelectSubset<T, HabitProofFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HabitProof.
     * @param {HabitProofCreateArgs} args - Arguments to create a HabitProof.
     * @example
     * // Create one HabitProof
     * const HabitProof = await prisma.habitProof.create({
     *   data: {
     *     // ... data to create a HabitProof
     *   }
     * })
     * 
     */
    create<T extends HabitProofCreateArgs>(args: SelectSubset<T, HabitProofCreateArgs<ExtArgs>>): Prisma__HabitProofClient<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HabitProofs.
     * @param {HabitProofCreateManyArgs} args - Arguments to create many HabitProofs.
     * @example
     * // Create many HabitProofs
     * const habitProof = await prisma.habitProof.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HabitProofCreateManyArgs>(args?: SelectSubset<T, HabitProofCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HabitProofs and returns the data saved in the database.
     * @param {HabitProofCreateManyAndReturnArgs} args - Arguments to create many HabitProofs.
     * @example
     * // Create many HabitProofs
     * const habitProof = await prisma.habitProof.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HabitProofs and only return the `id`
     * const habitProofWithIdOnly = await prisma.habitProof.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HabitProofCreateManyAndReturnArgs>(args?: SelectSubset<T, HabitProofCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HabitProof.
     * @param {HabitProofDeleteArgs} args - Arguments to delete one HabitProof.
     * @example
     * // Delete one HabitProof
     * const HabitProof = await prisma.habitProof.delete({
     *   where: {
     *     // ... filter to delete one HabitProof
     *   }
     * })
     * 
     */
    delete<T extends HabitProofDeleteArgs>(args: SelectSubset<T, HabitProofDeleteArgs<ExtArgs>>): Prisma__HabitProofClient<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HabitProof.
     * @param {HabitProofUpdateArgs} args - Arguments to update one HabitProof.
     * @example
     * // Update one HabitProof
     * const habitProof = await prisma.habitProof.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HabitProofUpdateArgs>(args: SelectSubset<T, HabitProofUpdateArgs<ExtArgs>>): Prisma__HabitProofClient<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HabitProofs.
     * @param {HabitProofDeleteManyArgs} args - Arguments to filter HabitProofs to delete.
     * @example
     * // Delete a few HabitProofs
     * const { count } = await prisma.habitProof.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HabitProofDeleteManyArgs>(args?: SelectSubset<T, HabitProofDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HabitProofs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitProofUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HabitProofs
     * const habitProof = await prisma.habitProof.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HabitProofUpdateManyArgs>(args: SelectSubset<T, HabitProofUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HabitProof.
     * @param {HabitProofUpsertArgs} args - Arguments to update or create a HabitProof.
     * @example
     * // Update or create a HabitProof
     * const habitProof = await prisma.habitProof.upsert({
     *   create: {
     *     // ... data to create a HabitProof
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HabitProof we want to update
     *   }
     * })
     */
    upsert<T extends HabitProofUpsertArgs>(args: SelectSubset<T, HabitProofUpsertArgs<ExtArgs>>): Prisma__HabitProofClient<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HabitProofs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitProofCountArgs} args - Arguments to filter HabitProofs to count.
     * @example
     * // Count the number of HabitProofs
     * const count = await prisma.habitProof.count({
     *   where: {
     *     // ... the filter for the HabitProofs we want to count
     *   }
     * })
    **/
    count<T extends HabitProofCountArgs>(
      args?: Subset<T, HabitProofCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HabitProofCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HabitProof.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitProofAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HabitProofAggregateArgs>(args: Subset<T, HabitProofAggregateArgs>): Prisma.PrismaPromise<GetHabitProofAggregateType<T>>

    /**
     * Group by HabitProof.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitProofGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HabitProofGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HabitProofGroupByArgs['orderBy'] }
        : { orderBy?: HabitProofGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HabitProofGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabitProofGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HabitProof model
   */
  readonly fields: HabitProofFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HabitProof.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HabitProofClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    habit<T extends HabitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HabitDefaultArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    votes<T extends HabitProof$votesArgs<ExtArgs> = {}>(args?: Subset<T, HabitProof$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HabitProof model
   */ 
  interface HabitProofFieldRefs {
    readonly id: FieldRef<"HabitProof", 'String'>
    readonly userId: FieldRef<"HabitProof", 'String'>
    readonly habitId: FieldRef<"HabitProof", 'String'>
    readonly imageUrl: FieldRef<"HabitProof", 'String'>
    readonly round: FieldRef<"HabitProof", 'Int'>
    readonly status: FieldRef<"HabitProof", 'String'>
    readonly createdAt: FieldRef<"HabitProof", 'DateTime'>
    readonly updatedAt: FieldRef<"HabitProof", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HabitProof findUnique
   */
  export type HabitProofFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    /**
     * Filter, which HabitProof to fetch.
     */
    where: HabitProofWhereUniqueInput
  }

  /**
   * HabitProof findUniqueOrThrow
   */
  export type HabitProofFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    /**
     * Filter, which HabitProof to fetch.
     */
    where: HabitProofWhereUniqueInput
  }

  /**
   * HabitProof findFirst
   */
  export type HabitProofFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    /**
     * Filter, which HabitProof to fetch.
     */
    where?: HabitProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitProofs to fetch.
     */
    orderBy?: HabitProofOrderByWithRelationInput | HabitProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HabitProofs.
     */
    cursor?: HabitProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HabitProofs.
     */
    distinct?: HabitProofScalarFieldEnum | HabitProofScalarFieldEnum[]
  }

  /**
   * HabitProof findFirstOrThrow
   */
  export type HabitProofFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    /**
     * Filter, which HabitProof to fetch.
     */
    where?: HabitProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitProofs to fetch.
     */
    orderBy?: HabitProofOrderByWithRelationInput | HabitProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HabitProofs.
     */
    cursor?: HabitProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HabitProofs.
     */
    distinct?: HabitProofScalarFieldEnum | HabitProofScalarFieldEnum[]
  }

  /**
   * HabitProof findMany
   */
  export type HabitProofFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    /**
     * Filter, which HabitProofs to fetch.
     */
    where?: HabitProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitProofs to fetch.
     */
    orderBy?: HabitProofOrderByWithRelationInput | HabitProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HabitProofs.
     */
    cursor?: HabitProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitProofs.
     */
    skip?: number
    distinct?: HabitProofScalarFieldEnum | HabitProofScalarFieldEnum[]
  }

  /**
   * HabitProof create
   */
  export type HabitProofCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    /**
     * The data needed to create a HabitProof.
     */
    data: XOR<HabitProofCreateInput, HabitProofUncheckedCreateInput>
  }

  /**
   * HabitProof createMany
   */
  export type HabitProofCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HabitProofs.
     */
    data: HabitProofCreateManyInput | HabitProofCreateManyInput[]
  }

  /**
   * HabitProof createManyAndReturn
   */
  export type HabitProofCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HabitProofs.
     */
    data: HabitProofCreateManyInput | HabitProofCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HabitProof update
   */
  export type HabitProofUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    /**
     * The data needed to update a HabitProof.
     */
    data: XOR<HabitProofUpdateInput, HabitProofUncheckedUpdateInput>
    /**
     * Choose, which HabitProof to update.
     */
    where: HabitProofWhereUniqueInput
  }

  /**
   * HabitProof updateMany
   */
  export type HabitProofUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HabitProofs.
     */
    data: XOR<HabitProofUpdateManyMutationInput, HabitProofUncheckedUpdateManyInput>
    /**
     * Filter which HabitProofs to update
     */
    where?: HabitProofWhereInput
  }

  /**
   * HabitProof upsert
   */
  export type HabitProofUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    /**
     * The filter to search for the HabitProof to update in case it exists.
     */
    where: HabitProofWhereUniqueInput
    /**
     * In case the HabitProof found by the `where` argument doesn't exist, create a new HabitProof with this data.
     */
    create: XOR<HabitProofCreateInput, HabitProofUncheckedCreateInput>
    /**
     * In case the HabitProof was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HabitProofUpdateInput, HabitProofUncheckedUpdateInput>
  }

  /**
   * HabitProof delete
   */
  export type HabitProofDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
    /**
     * Filter which HabitProof to delete.
     */
    where: HabitProofWhereUniqueInput
  }

  /**
   * HabitProof deleteMany
   */
  export type HabitProofDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HabitProofs to delete
     */
    where?: HabitProofWhereInput
  }

  /**
   * HabitProof.votes
   */
  export type HabitProof$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    where?: ProofVoteWhereInput
    orderBy?: ProofVoteOrderByWithRelationInput | ProofVoteOrderByWithRelationInput[]
    cursor?: ProofVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProofVoteScalarFieldEnum | ProofVoteScalarFieldEnum[]
  }

  /**
   * HabitProof without action
   */
  export type HabitProofDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitProof
     */
    select?: HabitProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitProofInclude<ExtArgs> | null
  }


  /**
   * Model ProofVote
   */

  export type AggregateProofVote = {
    _count: ProofVoteCountAggregateOutputType | null
    _min: ProofVoteMinAggregateOutputType | null
    _max: ProofVoteMaxAggregateOutputType | null
  }

  export type ProofVoteMinAggregateOutputType = {
    id: string | null
    proofId: string | null
    voterId: string | null
    voteType: string | null
    createdAt: Date | null
  }

  export type ProofVoteMaxAggregateOutputType = {
    id: string | null
    proofId: string | null
    voterId: string | null
    voteType: string | null
    createdAt: Date | null
  }

  export type ProofVoteCountAggregateOutputType = {
    id: number
    proofId: number
    voterId: number
    voteType: number
    createdAt: number
    _all: number
  }


  export type ProofVoteMinAggregateInputType = {
    id?: true
    proofId?: true
    voterId?: true
    voteType?: true
    createdAt?: true
  }

  export type ProofVoteMaxAggregateInputType = {
    id?: true
    proofId?: true
    voterId?: true
    voteType?: true
    createdAt?: true
  }

  export type ProofVoteCountAggregateInputType = {
    id?: true
    proofId?: true
    voterId?: true
    voteType?: true
    createdAt?: true
    _all?: true
  }

  export type ProofVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProofVote to aggregate.
     */
    where?: ProofVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProofVotes to fetch.
     */
    orderBy?: ProofVoteOrderByWithRelationInput | ProofVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProofVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProofVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProofVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProofVotes
    **/
    _count?: true | ProofVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProofVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProofVoteMaxAggregateInputType
  }

  export type GetProofVoteAggregateType<T extends ProofVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateProofVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProofVote[P]>
      : GetScalarType<T[P], AggregateProofVote[P]>
  }




  export type ProofVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProofVoteWhereInput
    orderBy?: ProofVoteOrderByWithAggregationInput | ProofVoteOrderByWithAggregationInput[]
    by: ProofVoteScalarFieldEnum[] | ProofVoteScalarFieldEnum
    having?: ProofVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProofVoteCountAggregateInputType | true
    _min?: ProofVoteMinAggregateInputType
    _max?: ProofVoteMaxAggregateInputType
  }

  export type ProofVoteGroupByOutputType = {
    id: string
    proofId: string
    voterId: string
    voteType: string
    createdAt: Date
    _count: ProofVoteCountAggregateOutputType | null
    _min: ProofVoteMinAggregateOutputType | null
    _max: ProofVoteMaxAggregateOutputType | null
  }

  type GetProofVoteGroupByPayload<T extends ProofVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProofVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProofVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProofVoteGroupByOutputType[P]>
            : GetScalarType<T[P], ProofVoteGroupByOutputType[P]>
        }
      >
    >


  export type ProofVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proofId?: boolean
    voterId?: boolean
    voteType?: boolean
    createdAt?: boolean
    proof?: boolean | HabitProofDefaultArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proofVote"]>

  export type ProofVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proofId?: boolean
    voterId?: boolean
    voteType?: boolean
    createdAt?: boolean
    proof?: boolean | HabitProofDefaultArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proofVote"]>

  export type ProofVoteSelectScalar = {
    id?: boolean
    proofId?: boolean
    voterId?: boolean
    voteType?: boolean
    createdAt?: boolean
  }

  export type ProofVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proof?: boolean | HabitProofDefaultArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProofVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proof?: boolean | HabitProofDefaultArgs<ExtArgs>
    voter?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProofVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProofVote"
    objects: {
      proof: Prisma.$HabitProofPayload<ExtArgs>
      voter: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proofId: string
      voterId: string
      voteType: string
      createdAt: Date
    }, ExtArgs["result"]["proofVote"]>
    composites: {}
  }

  type ProofVoteGetPayload<S extends boolean | null | undefined | ProofVoteDefaultArgs> = $Result.GetResult<Prisma.$ProofVotePayload, S>

  type ProofVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProofVoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProofVoteCountAggregateInputType | true
    }

  export interface ProofVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProofVote'], meta: { name: 'ProofVote' } }
    /**
     * Find zero or one ProofVote that matches the filter.
     * @param {ProofVoteFindUniqueArgs} args - Arguments to find a ProofVote
     * @example
     * // Get one ProofVote
     * const proofVote = await prisma.proofVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProofVoteFindUniqueArgs>(args: SelectSubset<T, ProofVoteFindUniqueArgs<ExtArgs>>): Prisma__ProofVoteClient<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProofVote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProofVoteFindUniqueOrThrowArgs} args - Arguments to find a ProofVote
     * @example
     * // Get one ProofVote
     * const proofVote = await prisma.proofVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProofVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ProofVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProofVoteClient<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProofVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProofVoteFindFirstArgs} args - Arguments to find a ProofVote
     * @example
     * // Get one ProofVote
     * const proofVote = await prisma.proofVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProofVoteFindFirstArgs>(args?: SelectSubset<T, ProofVoteFindFirstArgs<ExtArgs>>): Prisma__ProofVoteClient<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProofVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProofVoteFindFirstOrThrowArgs} args - Arguments to find a ProofVote
     * @example
     * // Get one ProofVote
     * const proofVote = await prisma.proofVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProofVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ProofVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProofVoteClient<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProofVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProofVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProofVotes
     * const proofVotes = await prisma.proofVote.findMany()
     * 
     * // Get first 10 ProofVotes
     * const proofVotes = await prisma.proofVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proofVoteWithIdOnly = await prisma.proofVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProofVoteFindManyArgs>(args?: SelectSubset<T, ProofVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProofVote.
     * @param {ProofVoteCreateArgs} args - Arguments to create a ProofVote.
     * @example
     * // Create one ProofVote
     * const ProofVote = await prisma.proofVote.create({
     *   data: {
     *     // ... data to create a ProofVote
     *   }
     * })
     * 
     */
    create<T extends ProofVoteCreateArgs>(args: SelectSubset<T, ProofVoteCreateArgs<ExtArgs>>): Prisma__ProofVoteClient<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProofVotes.
     * @param {ProofVoteCreateManyArgs} args - Arguments to create many ProofVotes.
     * @example
     * // Create many ProofVotes
     * const proofVote = await prisma.proofVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProofVoteCreateManyArgs>(args?: SelectSubset<T, ProofVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProofVotes and returns the data saved in the database.
     * @param {ProofVoteCreateManyAndReturnArgs} args - Arguments to create many ProofVotes.
     * @example
     * // Create many ProofVotes
     * const proofVote = await prisma.proofVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProofVotes and only return the `id`
     * const proofVoteWithIdOnly = await prisma.proofVote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProofVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ProofVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProofVote.
     * @param {ProofVoteDeleteArgs} args - Arguments to delete one ProofVote.
     * @example
     * // Delete one ProofVote
     * const ProofVote = await prisma.proofVote.delete({
     *   where: {
     *     // ... filter to delete one ProofVote
     *   }
     * })
     * 
     */
    delete<T extends ProofVoteDeleteArgs>(args: SelectSubset<T, ProofVoteDeleteArgs<ExtArgs>>): Prisma__ProofVoteClient<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProofVote.
     * @param {ProofVoteUpdateArgs} args - Arguments to update one ProofVote.
     * @example
     * // Update one ProofVote
     * const proofVote = await prisma.proofVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProofVoteUpdateArgs>(args: SelectSubset<T, ProofVoteUpdateArgs<ExtArgs>>): Prisma__ProofVoteClient<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProofVotes.
     * @param {ProofVoteDeleteManyArgs} args - Arguments to filter ProofVotes to delete.
     * @example
     * // Delete a few ProofVotes
     * const { count } = await prisma.proofVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProofVoteDeleteManyArgs>(args?: SelectSubset<T, ProofVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProofVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProofVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProofVotes
     * const proofVote = await prisma.proofVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProofVoteUpdateManyArgs>(args: SelectSubset<T, ProofVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProofVote.
     * @param {ProofVoteUpsertArgs} args - Arguments to update or create a ProofVote.
     * @example
     * // Update or create a ProofVote
     * const proofVote = await prisma.proofVote.upsert({
     *   create: {
     *     // ... data to create a ProofVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProofVote we want to update
     *   }
     * })
     */
    upsert<T extends ProofVoteUpsertArgs>(args: SelectSubset<T, ProofVoteUpsertArgs<ExtArgs>>): Prisma__ProofVoteClient<$Result.GetResult<Prisma.$ProofVotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProofVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProofVoteCountArgs} args - Arguments to filter ProofVotes to count.
     * @example
     * // Count the number of ProofVotes
     * const count = await prisma.proofVote.count({
     *   where: {
     *     // ... the filter for the ProofVotes we want to count
     *   }
     * })
    **/
    count<T extends ProofVoteCountArgs>(
      args?: Subset<T, ProofVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProofVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProofVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProofVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProofVoteAggregateArgs>(args: Subset<T, ProofVoteAggregateArgs>): Prisma.PrismaPromise<GetProofVoteAggregateType<T>>

    /**
     * Group by ProofVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProofVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProofVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProofVoteGroupByArgs['orderBy'] }
        : { orderBy?: ProofVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProofVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProofVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProofVote model
   */
  readonly fields: ProofVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProofVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProofVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proof<T extends HabitProofDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HabitProofDefaultArgs<ExtArgs>>): Prisma__HabitProofClient<$Result.GetResult<Prisma.$HabitProofPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    voter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProofVote model
   */ 
  interface ProofVoteFieldRefs {
    readonly id: FieldRef<"ProofVote", 'String'>
    readonly proofId: FieldRef<"ProofVote", 'String'>
    readonly voterId: FieldRef<"ProofVote", 'String'>
    readonly voteType: FieldRef<"ProofVote", 'String'>
    readonly createdAt: FieldRef<"ProofVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProofVote findUnique
   */
  export type ProofVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    /**
     * Filter, which ProofVote to fetch.
     */
    where: ProofVoteWhereUniqueInput
  }

  /**
   * ProofVote findUniqueOrThrow
   */
  export type ProofVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    /**
     * Filter, which ProofVote to fetch.
     */
    where: ProofVoteWhereUniqueInput
  }

  /**
   * ProofVote findFirst
   */
  export type ProofVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    /**
     * Filter, which ProofVote to fetch.
     */
    where?: ProofVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProofVotes to fetch.
     */
    orderBy?: ProofVoteOrderByWithRelationInput | ProofVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProofVotes.
     */
    cursor?: ProofVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProofVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProofVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProofVotes.
     */
    distinct?: ProofVoteScalarFieldEnum | ProofVoteScalarFieldEnum[]
  }

  /**
   * ProofVote findFirstOrThrow
   */
  export type ProofVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    /**
     * Filter, which ProofVote to fetch.
     */
    where?: ProofVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProofVotes to fetch.
     */
    orderBy?: ProofVoteOrderByWithRelationInput | ProofVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProofVotes.
     */
    cursor?: ProofVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProofVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProofVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProofVotes.
     */
    distinct?: ProofVoteScalarFieldEnum | ProofVoteScalarFieldEnum[]
  }

  /**
   * ProofVote findMany
   */
  export type ProofVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    /**
     * Filter, which ProofVotes to fetch.
     */
    where?: ProofVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProofVotes to fetch.
     */
    orderBy?: ProofVoteOrderByWithRelationInput | ProofVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProofVotes.
     */
    cursor?: ProofVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProofVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProofVotes.
     */
    skip?: number
    distinct?: ProofVoteScalarFieldEnum | ProofVoteScalarFieldEnum[]
  }

  /**
   * ProofVote create
   */
  export type ProofVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ProofVote.
     */
    data: XOR<ProofVoteCreateInput, ProofVoteUncheckedCreateInput>
  }

  /**
   * ProofVote createMany
   */
  export type ProofVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProofVotes.
     */
    data: ProofVoteCreateManyInput | ProofVoteCreateManyInput[]
  }

  /**
   * ProofVote createManyAndReturn
   */
  export type ProofVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProofVotes.
     */
    data: ProofVoteCreateManyInput | ProofVoteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProofVote update
   */
  export type ProofVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ProofVote.
     */
    data: XOR<ProofVoteUpdateInput, ProofVoteUncheckedUpdateInput>
    /**
     * Choose, which ProofVote to update.
     */
    where: ProofVoteWhereUniqueInput
  }

  /**
   * ProofVote updateMany
   */
  export type ProofVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProofVotes.
     */
    data: XOR<ProofVoteUpdateManyMutationInput, ProofVoteUncheckedUpdateManyInput>
    /**
     * Filter which ProofVotes to update
     */
    where?: ProofVoteWhereInput
  }

  /**
   * ProofVote upsert
   */
  export type ProofVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ProofVote to update in case it exists.
     */
    where: ProofVoteWhereUniqueInput
    /**
     * In case the ProofVote found by the `where` argument doesn't exist, create a new ProofVote with this data.
     */
    create: XOR<ProofVoteCreateInput, ProofVoteUncheckedCreateInput>
    /**
     * In case the ProofVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProofVoteUpdateInput, ProofVoteUncheckedUpdateInput>
  }

  /**
   * ProofVote delete
   */
  export type ProofVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
    /**
     * Filter which ProofVote to delete.
     */
    where: ProofVoteWhereUniqueInput
  }

  /**
   * ProofVote deleteMany
   */
  export type ProofVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProofVotes to delete
     */
    where?: ProofVoteWhereInput
  }

  /**
   * ProofVote without action
   */
  export type ProofVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProofVote
     */
    select?: ProofVoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProofVoteInclude<ExtArgs> | null
  }


  /**
   * Model Friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    userId: string | null
    friendId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    friendId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    userId: number
    friendId: number
    status: number
    createdAt: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    userId?: true
    friendId?: true
    status?: true
    createdAt?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    userId?: true
    friendId?: true
    status?: true
    createdAt?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    userId?: true
    friendId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendship to aggregate.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type FriendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithAggregationInput | FriendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: FriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    userId: string
    friendId: string
    status: string
    createdAt: Date
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends FriendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type FriendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    friendId?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    friend?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    friendId?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    friend?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectScalar = {
    id?: boolean
    userId?: boolean
    friendId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type FriendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    friend?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    friend?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FriendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friendship"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      friend: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      friendId: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type FriendshipGetPayload<S extends boolean | null | undefined | FriendshipDefaultArgs> = $Result.GetResult<Prisma.$FriendshipPayload, S>

  type FriendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FriendshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface FriendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friendship'], meta: { name: 'Friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {FriendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendshipFindUniqueArgs>(args: SelectSubset<T, FriendshipFindUniqueArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FriendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendshipFindFirstArgs>(args?: SelectSubset<T, FriendshipFindFirstArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendshipFindManyArgs>(args?: SelectSubset<T, FriendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Friendship.
     * @param {FriendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends FriendshipCreateArgs>(args: SelectSubset<T, FriendshipCreateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Friendships.
     * @param {FriendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendshipCreateManyArgs>(args?: SelectSubset<T, FriendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {FriendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Friendship.
     * @param {FriendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends FriendshipDeleteArgs>(args: SelectSubset<T, FriendshipDeleteArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Friendship.
     * @param {FriendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendshipUpdateArgs>(args: SelectSubset<T, FriendshipUpdateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Friendships.
     * @param {FriendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendshipDeleteManyArgs>(args?: SelectSubset<T, FriendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendshipUpdateManyArgs>(args: SelectSubset<T, FriendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Friendship.
     * @param {FriendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends FriendshipUpsertArgs>(args: SelectSubset<T, FriendshipUpsertArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends FriendshipCountArgs>(
      args?: Subset<T, FriendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendshipGroupByArgs['orderBy'] }
        : { orderBy?: FriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friendship model
   */
  readonly fields: FriendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    friend<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friendship model
   */ 
  interface FriendshipFieldRefs {
    readonly id: FieldRef<"Friendship", 'String'>
    readonly userId: FieldRef<"Friendship", 'String'>
    readonly friendId: FieldRef<"Friendship", 'String'>
    readonly status: FieldRef<"Friendship", 'String'>
    readonly createdAt: FieldRef<"Friendship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Friendship findUnique
   */
  export type FriendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findUniqueOrThrow
   */
  export type FriendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findFirst
   */
  export type FriendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findFirstOrThrow
   */
  export type FriendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findMany
   */
  export type FriendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendships to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship create
   */
  export type FriendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Friendship.
     */
    data: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
  }

  /**
   * Friendship createMany
   */
  export type FriendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
  }

  /**
   * Friendship createManyAndReturn
   */
  export type FriendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship update
   */
  export type FriendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Friendship.
     */
    data: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
    /**
     * Choose, which Friendship to update.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship updateMany
   */
  export type FriendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship upsert
   */
  export type FriendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Friendship to update in case it exists.
     */
    where: FriendshipWhereUniqueInput
    /**
     * In case the Friendship found by the `where` argument doesn't exist, create a new Friendship with this data.
     */
    create: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
    /**
     * In case the Friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
  }

  /**
   * Friendship delete
   */
  export type FriendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter which Friendship to delete.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship deleteMany
   */
  export type FriendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendships to delete
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship without action
   */
  export type FriendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    followerId: string
    followingId: string
    createdAt: Date
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
  }

  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingId: string
      createdAt: Date
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */ 
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly followerId: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
  }

  /**
   * Follow createManyAndReturn
   */
  export type FollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model HabitInvite
   */

  export type AggregateHabitInvite = {
    _count: HabitInviteCountAggregateOutputType | null
    _min: HabitInviteMinAggregateOutputType | null
    _max: HabitInviteMaxAggregateOutputType | null
  }

  export type HabitInviteMinAggregateOutputType = {
    id: string | null
    code: string | null
    habitId: string | null
    inviterId: string | null
    inviteePhone: string | null
    expiresAt: Date | null
    usedById: string | null
    createdAt: Date | null
  }

  export type HabitInviteMaxAggregateOutputType = {
    id: string | null
    code: string | null
    habitId: string | null
    inviterId: string | null
    inviteePhone: string | null
    expiresAt: Date | null
    usedById: string | null
    createdAt: Date | null
  }

  export type HabitInviteCountAggregateOutputType = {
    id: number
    code: number
    habitId: number
    inviterId: number
    inviteePhone: number
    expiresAt: number
    usedById: number
    createdAt: number
    _all: number
  }


  export type HabitInviteMinAggregateInputType = {
    id?: true
    code?: true
    habitId?: true
    inviterId?: true
    inviteePhone?: true
    expiresAt?: true
    usedById?: true
    createdAt?: true
  }

  export type HabitInviteMaxAggregateInputType = {
    id?: true
    code?: true
    habitId?: true
    inviterId?: true
    inviteePhone?: true
    expiresAt?: true
    usedById?: true
    createdAt?: true
  }

  export type HabitInviteCountAggregateInputType = {
    id?: true
    code?: true
    habitId?: true
    inviterId?: true
    inviteePhone?: true
    expiresAt?: true
    usedById?: true
    createdAt?: true
    _all?: true
  }

  export type HabitInviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HabitInvite to aggregate.
     */
    where?: HabitInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitInvites to fetch.
     */
    orderBy?: HabitInviteOrderByWithRelationInput | HabitInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HabitInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HabitInvites
    **/
    _count?: true | HabitInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HabitInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HabitInviteMaxAggregateInputType
  }

  export type GetHabitInviteAggregateType<T extends HabitInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateHabitInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabitInvite[P]>
      : GetScalarType<T[P], AggregateHabitInvite[P]>
  }




  export type HabitInviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HabitInviteWhereInput
    orderBy?: HabitInviteOrderByWithAggregationInput | HabitInviteOrderByWithAggregationInput[]
    by: HabitInviteScalarFieldEnum[] | HabitInviteScalarFieldEnum
    having?: HabitInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HabitInviteCountAggregateInputType | true
    _min?: HabitInviteMinAggregateInputType
    _max?: HabitInviteMaxAggregateInputType
  }

  export type HabitInviteGroupByOutputType = {
    id: string
    code: string
    habitId: string | null
    inviterId: string
    inviteePhone: string | null
    expiresAt: Date
    usedById: string | null
    createdAt: Date
    _count: HabitInviteCountAggregateOutputType | null
    _min: HabitInviteMinAggregateOutputType | null
    _max: HabitInviteMaxAggregateOutputType | null
  }

  type GetHabitInviteGroupByPayload<T extends HabitInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HabitInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HabitInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HabitInviteGroupByOutputType[P]>
            : GetScalarType<T[P], HabitInviteGroupByOutputType[P]>
        }
      >
    >


  export type HabitInviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    habitId?: boolean
    inviterId?: boolean
    inviteePhone?: boolean
    expiresAt?: boolean
    usedById?: boolean
    createdAt?: boolean
    habit?: boolean | HabitInvite$habitArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habitInvite"]>

  export type HabitInviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    habitId?: boolean
    inviterId?: boolean
    inviteePhone?: boolean
    expiresAt?: boolean
    usedById?: boolean
    createdAt?: boolean
    habit?: boolean | HabitInvite$habitArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habitInvite"]>

  export type HabitInviteSelectScalar = {
    id?: boolean
    code?: boolean
    habitId?: boolean
    inviterId?: boolean
    inviteePhone?: boolean
    expiresAt?: boolean
    usedById?: boolean
    createdAt?: boolean
  }

  export type HabitInviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habit?: boolean | HabitInvite$habitArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HabitInviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habit?: boolean | HabitInvite$habitArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HabitInvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HabitInvite"
    objects: {
      habit: Prisma.$HabitPayload<ExtArgs> | null
      inviter: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      habitId: string | null
      inviterId: string
      inviteePhone: string | null
      expiresAt: Date
      usedById: string | null
      createdAt: Date
    }, ExtArgs["result"]["habitInvite"]>
    composites: {}
  }

  type HabitInviteGetPayload<S extends boolean | null | undefined | HabitInviteDefaultArgs> = $Result.GetResult<Prisma.$HabitInvitePayload, S>

  type HabitInviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HabitInviteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HabitInviteCountAggregateInputType | true
    }

  export interface HabitInviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HabitInvite'], meta: { name: 'HabitInvite' } }
    /**
     * Find zero or one HabitInvite that matches the filter.
     * @param {HabitInviteFindUniqueArgs} args - Arguments to find a HabitInvite
     * @example
     * // Get one HabitInvite
     * const habitInvite = await prisma.habitInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HabitInviteFindUniqueArgs>(args: SelectSubset<T, HabitInviteFindUniqueArgs<ExtArgs>>): Prisma__HabitInviteClient<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HabitInvite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HabitInviteFindUniqueOrThrowArgs} args - Arguments to find a HabitInvite
     * @example
     * // Get one HabitInvite
     * const habitInvite = await prisma.habitInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HabitInviteFindUniqueOrThrowArgs>(args: SelectSubset<T, HabitInviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HabitInviteClient<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HabitInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitInviteFindFirstArgs} args - Arguments to find a HabitInvite
     * @example
     * // Get one HabitInvite
     * const habitInvite = await prisma.habitInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HabitInviteFindFirstArgs>(args?: SelectSubset<T, HabitInviteFindFirstArgs<ExtArgs>>): Prisma__HabitInviteClient<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HabitInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitInviteFindFirstOrThrowArgs} args - Arguments to find a HabitInvite
     * @example
     * // Get one HabitInvite
     * const habitInvite = await prisma.habitInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HabitInviteFindFirstOrThrowArgs>(args?: SelectSubset<T, HabitInviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__HabitInviteClient<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HabitInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitInviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HabitInvites
     * const habitInvites = await prisma.habitInvite.findMany()
     * 
     * // Get first 10 HabitInvites
     * const habitInvites = await prisma.habitInvite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const habitInviteWithIdOnly = await prisma.habitInvite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HabitInviteFindManyArgs>(args?: SelectSubset<T, HabitInviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HabitInvite.
     * @param {HabitInviteCreateArgs} args - Arguments to create a HabitInvite.
     * @example
     * // Create one HabitInvite
     * const HabitInvite = await prisma.habitInvite.create({
     *   data: {
     *     // ... data to create a HabitInvite
     *   }
     * })
     * 
     */
    create<T extends HabitInviteCreateArgs>(args: SelectSubset<T, HabitInviteCreateArgs<ExtArgs>>): Prisma__HabitInviteClient<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HabitInvites.
     * @param {HabitInviteCreateManyArgs} args - Arguments to create many HabitInvites.
     * @example
     * // Create many HabitInvites
     * const habitInvite = await prisma.habitInvite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HabitInviteCreateManyArgs>(args?: SelectSubset<T, HabitInviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HabitInvites and returns the data saved in the database.
     * @param {HabitInviteCreateManyAndReturnArgs} args - Arguments to create many HabitInvites.
     * @example
     * // Create many HabitInvites
     * const habitInvite = await prisma.habitInvite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HabitInvites and only return the `id`
     * const habitInviteWithIdOnly = await prisma.habitInvite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HabitInviteCreateManyAndReturnArgs>(args?: SelectSubset<T, HabitInviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HabitInvite.
     * @param {HabitInviteDeleteArgs} args - Arguments to delete one HabitInvite.
     * @example
     * // Delete one HabitInvite
     * const HabitInvite = await prisma.habitInvite.delete({
     *   where: {
     *     // ... filter to delete one HabitInvite
     *   }
     * })
     * 
     */
    delete<T extends HabitInviteDeleteArgs>(args: SelectSubset<T, HabitInviteDeleteArgs<ExtArgs>>): Prisma__HabitInviteClient<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HabitInvite.
     * @param {HabitInviteUpdateArgs} args - Arguments to update one HabitInvite.
     * @example
     * // Update one HabitInvite
     * const habitInvite = await prisma.habitInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HabitInviteUpdateArgs>(args: SelectSubset<T, HabitInviteUpdateArgs<ExtArgs>>): Prisma__HabitInviteClient<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HabitInvites.
     * @param {HabitInviteDeleteManyArgs} args - Arguments to filter HabitInvites to delete.
     * @example
     * // Delete a few HabitInvites
     * const { count } = await prisma.habitInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HabitInviteDeleteManyArgs>(args?: SelectSubset<T, HabitInviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HabitInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HabitInvites
     * const habitInvite = await prisma.habitInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HabitInviteUpdateManyArgs>(args: SelectSubset<T, HabitInviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HabitInvite.
     * @param {HabitInviteUpsertArgs} args - Arguments to update or create a HabitInvite.
     * @example
     * // Update or create a HabitInvite
     * const habitInvite = await prisma.habitInvite.upsert({
     *   create: {
     *     // ... data to create a HabitInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HabitInvite we want to update
     *   }
     * })
     */
    upsert<T extends HabitInviteUpsertArgs>(args: SelectSubset<T, HabitInviteUpsertArgs<ExtArgs>>): Prisma__HabitInviteClient<$Result.GetResult<Prisma.$HabitInvitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HabitInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitInviteCountArgs} args - Arguments to filter HabitInvites to count.
     * @example
     * // Count the number of HabitInvites
     * const count = await prisma.habitInvite.count({
     *   where: {
     *     // ... the filter for the HabitInvites we want to count
     *   }
     * })
    **/
    count<T extends HabitInviteCountArgs>(
      args?: Subset<T, HabitInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HabitInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HabitInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HabitInviteAggregateArgs>(args: Subset<T, HabitInviteAggregateArgs>): Prisma.PrismaPromise<GetHabitInviteAggregateType<T>>

    /**
     * Group by HabitInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HabitInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HabitInviteGroupByArgs['orderBy'] }
        : { orderBy?: HabitInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HabitInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabitInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HabitInvite model
   */
  readonly fields: HabitInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HabitInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HabitInviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    habit<T extends HabitInvite$habitArgs<ExtArgs> = {}>(args?: Subset<T, HabitInvite$habitArgs<ExtArgs>>): Prisma__HabitClient<$Result.GetResult<Prisma.$HabitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HabitInvite model
   */ 
  interface HabitInviteFieldRefs {
    readonly id: FieldRef<"HabitInvite", 'String'>
    readonly code: FieldRef<"HabitInvite", 'String'>
    readonly habitId: FieldRef<"HabitInvite", 'String'>
    readonly inviterId: FieldRef<"HabitInvite", 'String'>
    readonly inviteePhone: FieldRef<"HabitInvite", 'String'>
    readonly expiresAt: FieldRef<"HabitInvite", 'DateTime'>
    readonly usedById: FieldRef<"HabitInvite", 'String'>
    readonly createdAt: FieldRef<"HabitInvite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HabitInvite findUnique
   */
  export type HabitInviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    /**
     * Filter, which HabitInvite to fetch.
     */
    where: HabitInviteWhereUniqueInput
  }

  /**
   * HabitInvite findUniqueOrThrow
   */
  export type HabitInviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    /**
     * Filter, which HabitInvite to fetch.
     */
    where: HabitInviteWhereUniqueInput
  }

  /**
   * HabitInvite findFirst
   */
  export type HabitInviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    /**
     * Filter, which HabitInvite to fetch.
     */
    where?: HabitInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitInvites to fetch.
     */
    orderBy?: HabitInviteOrderByWithRelationInput | HabitInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HabitInvites.
     */
    cursor?: HabitInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HabitInvites.
     */
    distinct?: HabitInviteScalarFieldEnum | HabitInviteScalarFieldEnum[]
  }

  /**
   * HabitInvite findFirstOrThrow
   */
  export type HabitInviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    /**
     * Filter, which HabitInvite to fetch.
     */
    where?: HabitInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitInvites to fetch.
     */
    orderBy?: HabitInviteOrderByWithRelationInput | HabitInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HabitInvites.
     */
    cursor?: HabitInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HabitInvites.
     */
    distinct?: HabitInviteScalarFieldEnum | HabitInviteScalarFieldEnum[]
  }

  /**
   * HabitInvite findMany
   */
  export type HabitInviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    /**
     * Filter, which HabitInvites to fetch.
     */
    where?: HabitInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HabitInvites to fetch.
     */
    orderBy?: HabitInviteOrderByWithRelationInput | HabitInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HabitInvites.
     */
    cursor?: HabitInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HabitInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HabitInvites.
     */
    skip?: number
    distinct?: HabitInviteScalarFieldEnum | HabitInviteScalarFieldEnum[]
  }

  /**
   * HabitInvite create
   */
  export type HabitInviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    /**
     * The data needed to create a HabitInvite.
     */
    data: XOR<HabitInviteCreateInput, HabitInviteUncheckedCreateInput>
  }

  /**
   * HabitInvite createMany
   */
  export type HabitInviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HabitInvites.
     */
    data: HabitInviteCreateManyInput | HabitInviteCreateManyInput[]
  }

  /**
   * HabitInvite createManyAndReturn
   */
  export type HabitInviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HabitInvites.
     */
    data: HabitInviteCreateManyInput | HabitInviteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HabitInvite update
   */
  export type HabitInviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    /**
     * The data needed to update a HabitInvite.
     */
    data: XOR<HabitInviteUpdateInput, HabitInviteUncheckedUpdateInput>
    /**
     * Choose, which HabitInvite to update.
     */
    where: HabitInviteWhereUniqueInput
  }

  /**
   * HabitInvite updateMany
   */
  export type HabitInviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HabitInvites.
     */
    data: XOR<HabitInviteUpdateManyMutationInput, HabitInviteUncheckedUpdateManyInput>
    /**
     * Filter which HabitInvites to update
     */
    where?: HabitInviteWhereInput
  }

  /**
   * HabitInvite upsert
   */
  export type HabitInviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    /**
     * The filter to search for the HabitInvite to update in case it exists.
     */
    where: HabitInviteWhereUniqueInput
    /**
     * In case the HabitInvite found by the `where` argument doesn't exist, create a new HabitInvite with this data.
     */
    create: XOR<HabitInviteCreateInput, HabitInviteUncheckedCreateInput>
    /**
     * In case the HabitInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HabitInviteUpdateInput, HabitInviteUncheckedUpdateInput>
  }

  /**
   * HabitInvite delete
   */
  export type HabitInviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
    /**
     * Filter which HabitInvite to delete.
     */
    where: HabitInviteWhereUniqueInput
  }

  /**
   * HabitInvite deleteMany
   */
  export type HabitInviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HabitInvites to delete
     */
    where?: HabitInviteWhereInput
  }

  /**
   * HabitInvite.habit
   */
  export type HabitInvite$habitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Habit
     */
    select?: HabitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInclude<ExtArgs> | null
    where?: HabitWhereInput
  }

  /**
   * HabitInvite without action
   */
  export type HabitInviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitInvite
     */
    select?: HabitInviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HabitInviteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    username: 'username',
    password: 'password',
    email: 'email',
    gender: 'gender',
    birthday: 'birthday',
    bio: 'bio',
    avatarUrl: 'avatarUrl',
    otp: 'otp',
    otpExpiresAt: 'otpExpiresAt',
    isPublic: 'isPublic',
    xp: 'xp',
    level: 'level',
    coins: 'coins',
    totalAchievements: 'totalAchievements',
    currentMountainId: 'currentMountainId',
    currentAltitude: 'currentAltitude',
    lastActive: 'lastActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserInventoryItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itemId: 'itemId'
  };

  export type UserInventoryItemScalarFieldEnum = (typeof UserInventoryItemScalarFieldEnum)[keyof typeof UserInventoryItemScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    avatarUrl: 'avatarUrl',
    inviteCode: 'inviteCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    teamId: 'teamId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    category: 'category',
    targetGoal: 'targetGoal',
    thresholdPct: 'thresholdPct',
    maxHearts: 'maxHearts',
    startDate: 'startDate',
    endDate: 'endDate',
    creatorId: 'creatorId',
    teamId: 'teamId',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const ChallengeParticipantScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    challengeId: 'challengeId',
    currentValue: 'currentValue',
    heartsLeft: 'heartsLeft',
    isEliminated: 'isEliminated',
    relayOrder: 'relayOrder',
    relayCompleted: 'relayCompleted',
    joinedAt: 'joinedAt'
  };

  export type ChallengeParticipantScalarFieldEnum = (typeof ChallengeParticipantScalarFieldEnum)[keyof typeof ChallengeParticipantScalarFieldEnum]


  export const ProgressLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    challengeId: 'challengeId',
    value: 'value',
    isSuccess: 'isSuccess',
    note: 'note',
    date: 'date',
    createdAt: 'createdAt'
  };

  export type ProgressLogScalarFieldEnum = (typeof ProgressLogScalarFieldEnum)[keyof typeof ProgressLogScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    iconUrl: 'iconUrl',
    xpReward: 'xpReward'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    badgeId: 'badgeId',
    earnedAt: 'earnedAt'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const HabitCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    biomeType: 'biomeType',
    mountainIcon: 'mountainIcon',
    mountainImage: 'mountainImage',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HabitCategoryScalarFieldEnum = (typeof HabitCategoryScalarFieldEnum)[keyof typeof HabitCategoryScalarFieldEnum]


  export const HabitScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    title: 'title',
    difficulty: 'difficulty',
    description: 'description',
    rating: 'rating',
    maturity: 'maturity',
    submissionType: 'submissionType',
    tips: 'tips',
    preChallengeGuide: 'preChallengeGuide',
    incentives: 'incentives',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HabitScalarFieldEnum = (typeof HabitScalarFieldEnum)[keyof typeof HabitScalarFieldEnum]


  export const HabitUserSettingsScalarFieldEnum: {
    userId: 'userId',
    habitId: 'habitId',
    isFavorite: 'isFavorite',
    notifyMe: 'notifyMe',
    rating: 'rating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HabitUserSettingsScalarFieldEnum = (typeof HabitUserSettingsScalarFieldEnum)[keyof typeof HabitUserSettingsScalarFieldEnum]


  export const HabitProofScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    habitId: 'habitId',
    imageUrl: 'imageUrl',
    round: 'round',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HabitProofScalarFieldEnum = (typeof HabitProofScalarFieldEnum)[keyof typeof HabitProofScalarFieldEnum]


  export const ProofVoteScalarFieldEnum: {
    id: 'id',
    proofId: 'proofId',
    voterId: 'voterId',
    voteType: 'voteType',
    createdAt: 'createdAt'
  };

  export type ProofVoteScalarFieldEnum = (typeof ProofVoteScalarFieldEnum)[keyof typeof ProofVoteScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    friendId: 'friendId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const HabitInviteScalarFieldEnum: {
    id: 'id',
    code: 'code',
    habitId: 'habitId',
    inviterId: 'inviterId',
    inviteePhone: 'inviteePhone',
    expiresAt: 'expiresAt',
    usedById: 'usedById',
    createdAt: 'createdAt'
  };

  export type HabitInviteScalarFieldEnum = (typeof HabitInviteScalarFieldEnum)[keyof typeof HabitInviteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    birthday?: DateTimeNullableFilter<"User"> | Date | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isPublic?: BoolFilter<"User"> | boolean
    xp?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    coins?: IntFilter<"User"> | number
    totalAchievements?: IntFilter<"User"> | number
    currentMountainId?: StringNullableFilter<"User"> | string | null
    currentAltitude?: FloatFilter<"User"> | number
    lastActive?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    currentMountain?: XOR<HabitCategoryNullableRelationFilter, HabitCategoryWhereInput> | null
    inventory?: UserInventoryItemListRelationFilter
    teamMembers?: TeamMemberListRelationFilter
    participations?: ChallengeParticipantListRelationFilter
    progressLogs?: ProgressLogListRelationFilter
    badges?: UserBadgeListRelationFilter
    createdChallenges?: ChallengeListRelationFilter
    joinedHabits?: HabitListRelationFilter
    habitProofs?: HabitProofListRelationFilter
    proofVotes?: ProofVoteListRelationFilter
    friends?: FriendshipListRelationFilter
    friendOf?: FriendshipListRelationFilter
    habitInvites?: HabitInviteListRelationFilter
    habitSettings?: HabitUserSettingsListRelationFilter
    followers?: FollowListRelationFilter
    following?: FollowListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    coins?: SortOrder
    totalAchievements?: SortOrder
    currentMountainId?: SortOrderInput | SortOrder
    currentAltitude?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMountain?: HabitCategoryOrderByWithRelationInput
    inventory?: UserInventoryItemOrderByRelationAggregateInput
    teamMembers?: TeamMemberOrderByRelationAggregateInput
    participations?: ChallengeParticipantOrderByRelationAggregateInput
    progressLogs?: ProgressLogOrderByRelationAggregateInput
    badges?: UserBadgeOrderByRelationAggregateInput
    createdChallenges?: ChallengeOrderByRelationAggregateInput
    joinedHabits?: HabitOrderByRelationAggregateInput
    habitProofs?: HabitProofOrderByRelationAggregateInput
    proofVotes?: ProofVoteOrderByRelationAggregateInput
    friends?: FriendshipOrderByRelationAggregateInput
    friendOf?: FriendshipOrderByRelationAggregateInput
    habitInvites?: HabitInviteOrderByRelationAggregateInput
    habitSettings?: HabitUserSettingsOrderByRelationAggregateInput
    followers?: FollowOrderByRelationAggregateInput
    following?: FollowOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phoneNumber?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    birthday?: DateTimeNullableFilter<"User"> | Date | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isPublic?: BoolFilter<"User"> | boolean
    xp?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    coins?: IntFilter<"User"> | number
    totalAchievements?: IntFilter<"User"> | number
    currentMountainId?: StringNullableFilter<"User"> | string | null
    currentAltitude?: FloatFilter<"User"> | number
    lastActive?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    currentMountain?: XOR<HabitCategoryNullableRelationFilter, HabitCategoryWhereInput> | null
    inventory?: UserInventoryItemListRelationFilter
    teamMembers?: TeamMemberListRelationFilter
    participations?: ChallengeParticipantListRelationFilter
    progressLogs?: ProgressLogListRelationFilter
    badges?: UserBadgeListRelationFilter
    createdChallenges?: ChallengeListRelationFilter
    joinedHabits?: HabitListRelationFilter
    habitProofs?: HabitProofListRelationFilter
    proofVotes?: ProofVoteListRelationFilter
    friends?: FriendshipListRelationFilter
    friendOf?: FriendshipListRelationFilter
    habitInvites?: HabitInviteListRelationFilter
    habitSettings?: HabitUserSettingsListRelationFilter
    followers?: FollowListRelationFilter
    following?: FollowListRelationFilter
  }, "id" | "phoneNumber" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    coins?: SortOrder
    totalAchievements?: SortOrder
    currentMountainId?: SortOrderInput | SortOrder
    currentAltitude?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthday?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    otp?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isPublic?: BoolWithAggregatesFilter<"User"> | boolean
    xp?: IntWithAggregatesFilter<"User"> | number
    level?: IntWithAggregatesFilter<"User"> | number
    coins?: IntWithAggregatesFilter<"User"> | number
    totalAchievements?: IntWithAggregatesFilter<"User"> | number
    currentMountainId?: StringNullableWithAggregatesFilter<"User"> | string | null
    currentAltitude?: FloatWithAggregatesFilter<"User"> | number
    lastActive?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserInventoryItemWhereInput = {
    AND?: UserInventoryItemWhereInput | UserInventoryItemWhereInput[]
    OR?: UserInventoryItemWhereInput[]
    NOT?: UserInventoryItemWhereInput | UserInventoryItemWhereInput[]
    id?: StringFilter<"UserInventoryItem"> | string
    userId?: StringFilter<"UserInventoryItem"> | string
    itemId?: StringFilter<"UserInventoryItem"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserInventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserInventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserInventoryItemWhereInput | UserInventoryItemWhereInput[]
    OR?: UserInventoryItemWhereInput[]
    NOT?: UserInventoryItemWhereInput | UserInventoryItemWhereInput[]
    userId?: StringFilter<"UserInventoryItem"> | string
    itemId?: StringFilter<"UserInventoryItem"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserInventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
    _count?: UserInventoryItemCountOrderByAggregateInput
    _max?: UserInventoryItemMaxOrderByAggregateInput
    _min?: UserInventoryItemMinOrderByAggregateInput
  }

  export type UserInventoryItemScalarWhereWithAggregatesInput = {
    AND?: UserInventoryItemScalarWhereWithAggregatesInput | UserInventoryItemScalarWhereWithAggregatesInput[]
    OR?: UserInventoryItemScalarWhereWithAggregatesInput[]
    NOT?: UserInventoryItemScalarWhereWithAggregatesInput | UserInventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserInventoryItem"> | string
    userId?: StringWithAggregatesFilter<"UserInventoryItem"> | string
    itemId?: StringWithAggregatesFilter<"UserInventoryItem"> | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    avatarUrl?: StringNullableFilter<"Team"> | string | null
    inviteCode?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    members?: TeamMemberListRelationFilter
    challenges?: ChallengeListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    inviteCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: TeamMemberOrderByRelationAggregateInput
    challenges?: ChallengeOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inviteCode?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    avatarUrl?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    members?: TeamMemberListRelationFilter
    challenges?: ChallengeListRelationFilter
  }, "id" | "inviteCode">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    inviteCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Team"> | string | null
    inviteCode?: StringWithAggregatesFilter<"Team"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_teamId?: TeamMemberUserIdTeamIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    userId?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }, "id" | "userId_teamId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    userId?: StringWithAggregatesFilter<"TeamMember"> | string
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string
    role?: StringWithAggregatesFilter<"TeamMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    id?: StringFilter<"Challenge"> | string
    title?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    type?: StringFilter<"Challenge"> | string
    category?: StringFilter<"Challenge"> | string
    targetGoal?: FloatFilter<"Challenge"> | number
    thresholdPct?: FloatNullableFilter<"Challenge"> | number | null
    maxHearts?: IntNullableFilter<"Challenge"> | number | null
    startDate?: DateTimeFilter<"Challenge"> | Date | string
    endDate?: DateTimeFilter<"Challenge"> | Date | string
    creatorId?: StringFilter<"Challenge"> | string
    teamId?: StringNullableFilter<"Challenge"> | string | null
    isPublic?: BoolFilter<"Challenge"> | boolean
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    participants?: ChallengeParticipantListRelationFilter
    progressLogs?: ProgressLogListRelationFilter
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    targetGoal?: SortOrder
    thresholdPct?: SortOrderInput | SortOrder
    maxHearts?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    participants?: ChallengeParticipantOrderByRelationAggregateInput
    progressLogs?: ProgressLogOrderByRelationAggregateInput
  }

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    title?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    type?: StringFilter<"Challenge"> | string
    category?: StringFilter<"Challenge"> | string
    targetGoal?: FloatFilter<"Challenge"> | number
    thresholdPct?: FloatNullableFilter<"Challenge"> | number | null
    maxHearts?: IntNullableFilter<"Challenge"> | number | null
    startDate?: DateTimeFilter<"Challenge"> | Date | string
    endDate?: DateTimeFilter<"Challenge"> | Date | string
    creatorId?: StringFilter<"Challenge"> | string
    teamId?: StringNullableFilter<"Challenge"> | string | null
    isPublic?: BoolFilter<"Challenge"> | boolean
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    participants?: ChallengeParticipantListRelationFilter
    progressLogs?: ProgressLogListRelationFilter
  }, "id">

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    targetGoal?: SortOrder
    thresholdPct?: SortOrderInput | SortOrder
    maxHearts?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _avg?: ChallengeAvgOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
    _sum?: ChallengeSumOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    OR?: ChallengeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Challenge"> | string
    title?: StringWithAggregatesFilter<"Challenge"> | string
    description?: StringWithAggregatesFilter<"Challenge"> | string
    type?: StringWithAggregatesFilter<"Challenge"> | string
    category?: StringWithAggregatesFilter<"Challenge"> | string
    targetGoal?: FloatWithAggregatesFilter<"Challenge"> | number
    thresholdPct?: FloatNullableWithAggregatesFilter<"Challenge"> | number | null
    maxHearts?: IntNullableWithAggregatesFilter<"Challenge"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Challenge"> | string
    teamId?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Challenge"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
  }

  export type ChallengeParticipantWhereInput = {
    AND?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    OR?: ChallengeParticipantWhereInput[]
    NOT?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    id?: StringFilter<"ChallengeParticipant"> | string
    userId?: StringFilter<"ChallengeParticipant"> | string
    challengeId?: StringFilter<"ChallengeParticipant"> | string
    currentValue?: FloatFilter<"ChallengeParticipant"> | number
    heartsLeft?: IntNullableFilter<"ChallengeParticipant"> | number | null
    isEliminated?: BoolFilter<"ChallengeParticipant"> | boolean
    relayOrder?: IntNullableFilter<"ChallengeParticipant"> | number | null
    relayCompleted?: BoolFilter<"ChallengeParticipant"> | boolean
    joinedAt?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeParticipantOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    currentValue?: SortOrder
    heartsLeft?: SortOrderInput | SortOrder
    isEliminated?: SortOrder
    relayOrder?: SortOrderInput | SortOrder
    relayCompleted?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type ChallengeParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_challengeId?: ChallengeParticipantUserIdChallengeIdCompoundUniqueInput
    AND?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    OR?: ChallengeParticipantWhereInput[]
    NOT?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    userId?: StringFilter<"ChallengeParticipant"> | string
    challengeId?: StringFilter<"ChallengeParticipant"> | string
    currentValue?: FloatFilter<"ChallengeParticipant"> | number
    heartsLeft?: IntNullableFilter<"ChallengeParticipant"> | number | null
    isEliminated?: BoolFilter<"ChallengeParticipant"> | boolean
    relayOrder?: IntNullableFilter<"ChallengeParticipant"> | number | null
    relayCompleted?: BoolFilter<"ChallengeParticipant"> | boolean
    joinedAt?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
  }, "id" | "userId_challengeId">

  export type ChallengeParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    currentValue?: SortOrder
    heartsLeft?: SortOrderInput | SortOrder
    isEliminated?: SortOrder
    relayOrder?: SortOrderInput | SortOrder
    relayCompleted?: SortOrder
    joinedAt?: SortOrder
    _count?: ChallengeParticipantCountOrderByAggregateInput
    _avg?: ChallengeParticipantAvgOrderByAggregateInput
    _max?: ChallengeParticipantMaxOrderByAggregateInput
    _min?: ChallengeParticipantMinOrderByAggregateInput
    _sum?: ChallengeParticipantSumOrderByAggregateInput
  }

  export type ChallengeParticipantScalarWhereWithAggregatesInput = {
    AND?: ChallengeParticipantScalarWhereWithAggregatesInput | ChallengeParticipantScalarWhereWithAggregatesInput[]
    OR?: ChallengeParticipantScalarWhereWithAggregatesInput[]
    NOT?: ChallengeParticipantScalarWhereWithAggregatesInput | ChallengeParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeParticipant"> | string
    userId?: StringWithAggregatesFilter<"ChallengeParticipant"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeParticipant"> | string
    currentValue?: FloatWithAggregatesFilter<"ChallengeParticipant"> | number
    heartsLeft?: IntNullableWithAggregatesFilter<"ChallengeParticipant"> | number | null
    isEliminated?: BoolWithAggregatesFilter<"ChallengeParticipant"> | boolean
    relayOrder?: IntNullableWithAggregatesFilter<"ChallengeParticipant"> | number | null
    relayCompleted?: BoolWithAggregatesFilter<"ChallengeParticipant"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"ChallengeParticipant"> | Date | string
  }

  export type ProgressLogWhereInput = {
    AND?: ProgressLogWhereInput | ProgressLogWhereInput[]
    OR?: ProgressLogWhereInput[]
    NOT?: ProgressLogWhereInput | ProgressLogWhereInput[]
    id?: StringFilter<"ProgressLog"> | string
    userId?: StringFilter<"ProgressLog"> | string
    challengeId?: StringFilter<"ProgressLog"> | string
    value?: FloatFilter<"ProgressLog"> | number
    isSuccess?: BoolFilter<"ProgressLog"> | boolean
    note?: StringNullableFilter<"ProgressLog"> | string | null
    date?: DateTimeFilter<"ProgressLog"> | Date | string
    createdAt?: DateTimeFilter<"ProgressLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
  }

  export type ProgressLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    value?: SortOrder
    isSuccess?: SortOrder
    note?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type ProgressLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_challengeId_date?: ProgressLogUserIdChallengeIdDateCompoundUniqueInput
    AND?: ProgressLogWhereInput | ProgressLogWhereInput[]
    OR?: ProgressLogWhereInput[]
    NOT?: ProgressLogWhereInput | ProgressLogWhereInput[]
    userId?: StringFilter<"ProgressLog"> | string
    challengeId?: StringFilter<"ProgressLog"> | string
    value?: FloatFilter<"ProgressLog"> | number
    isSuccess?: BoolFilter<"ProgressLog"> | boolean
    note?: StringNullableFilter<"ProgressLog"> | string | null
    date?: DateTimeFilter<"ProgressLog"> | Date | string
    createdAt?: DateTimeFilter<"ProgressLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
  }, "id" | "userId_challengeId_date">

  export type ProgressLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    value?: SortOrder
    isSuccess?: SortOrder
    note?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    _count?: ProgressLogCountOrderByAggregateInput
    _avg?: ProgressLogAvgOrderByAggregateInput
    _max?: ProgressLogMaxOrderByAggregateInput
    _min?: ProgressLogMinOrderByAggregateInput
    _sum?: ProgressLogSumOrderByAggregateInput
  }

  export type ProgressLogScalarWhereWithAggregatesInput = {
    AND?: ProgressLogScalarWhereWithAggregatesInput | ProgressLogScalarWhereWithAggregatesInput[]
    OR?: ProgressLogScalarWhereWithAggregatesInput[]
    NOT?: ProgressLogScalarWhereWithAggregatesInput | ProgressLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgressLog"> | string
    userId?: StringWithAggregatesFilter<"ProgressLog"> | string
    challengeId?: StringWithAggregatesFilter<"ProgressLog"> | string
    value?: FloatWithAggregatesFilter<"ProgressLog"> | number
    isSuccess?: BoolWithAggregatesFilter<"ProgressLog"> | boolean
    note?: StringNullableWithAggregatesFilter<"ProgressLog"> | string | null
    date?: DateTimeWithAggregatesFilter<"ProgressLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ProgressLog"> | Date | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    iconUrl?: StringNullableFilter<"Badge"> | string | null
    xpReward?: IntFilter<"Badge"> | number
    users?: UserBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrderInput | SortOrder
    xpReward?: SortOrder
    users?: UserBadgeOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    description?: StringFilter<"Badge"> | string
    iconUrl?: StringNullableFilter<"Badge"> | string | null
    xpReward?: IntFilter<"Badge"> | number
    users?: UserBadgeListRelationFilter
  }, "id" | "name">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrderInput | SortOrder
    xpReward?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringWithAggregatesFilter<"Badge"> | string
    iconUrl?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    xpReward?: IntWithAggregatesFilter<"Badge"> | number
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    badge?: XOR<BadgeRelationFilter, BadgeWhereInput>
  }

  export type UserBadgeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_badgeId?: UserBadgeUserIdBadgeIdCompoundUniqueInput
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    badge?: XOR<BadgeRelationFilter, BadgeWhereInput>
  }, "id" | "userId_badgeId">

  export type UserBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBadge"> | string
    userId?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeId?: StringWithAggregatesFilter<"UserBadge"> | string
    earnedAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
  }

  export type HabitCategoryWhereInput = {
    AND?: HabitCategoryWhereInput | HabitCategoryWhereInput[]
    OR?: HabitCategoryWhereInput[]
    NOT?: HabitCategoryWhereInput | HabitCategoryWhereInput[]
    id?: StringFilter<"HabitCategory"> | string
    name?: StringFilter<"HabitCategory"> | string
    biomeType?: StringFilter<"HabitCategory"> | string
    mountainIcon?: StringFilter<"HabitCategory"> | string
    mountainImage?: StringNullableFilter<"HabitCategory"> | string | null
    primaryColor?: StringFilter<"HabitCategory"> | string
    secondaryColor?: StringFilter<"HabitCategory"> | string
    createdAt?: DateTimeFilter<"HabitCategory"> | Date | string
    updatedAt?: DateTimeFilter<"HabitCategory"> | Date | string
    habits?: HabitListRelationFilter
    activeClimbers?: UserListRelationFilter
  }

  export type HabitCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    biomeType?: SortOrder
    mountainIcon?: SortOrder
    mountainImage?: SortOrderInput | SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    habits?: HabitOrderByRelationAggregateInput
    activeClimbers?: UserOrderByRelationAggregateInput
  }

  export type HabitCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HabitCategoryWhereInput | HabitCategoryWhereInput[]
    OR?: HabitCategoryWhereInput[]
    NOT?: HabitCategoryWhereInput | HabitCategoryWhereInput[]
    name?: StringFilter<"HabitCategory"> | string
    biomeType?: StringFilter<"HabitCategory"> | string
    mountainIcon?: StringFilter<"HabitCategory"> | string
    mountainImage?: StringNullableFilter<"HabitCategory"> | string | null
    primaryColor?: StringFilter<"HabitCategory"> | string
    secondaryColor?: StringFilter<"HabitCategory"> | string
    createdAt?: DateTimeFilter<"HabitCategory"> | Date | string
    updatedAt?: DateTimeFilter<"HabitCategory"> | Date | string
    habits?: HabitListRelationFilter
    activeClimbers?: UserListRelationFilter
  }, "id">

  export type HabitCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    biomeType?: SortOrder
    mountainIcon?: SortOrder
    mountainImage?: SortOrderInput | SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HabitCategoryCountOrderByAggregateInput
    _max?: HabitCategoryMaxOrderByAggregateInput
    _min?: HabitCategoryMinOrderByAggregateInput
  }

  export type HabitCategoryScalarWhereWithAggregatesInput = {
    AND?: HabitCategoryScalarWhereWithAggregatesInput | HabitCategoryScalarWhereWithAggregatesInput[]
    OR?: HabitCategoryScalarWhereWithAggregatesInput[]
    NOT?: HabitCategoryScalarWhereWithAggregatesInput | HabitCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HabitCategory"> | string
    name?: StringWithAggregatesFilter<"HabitCategory"> | string
    biomeType?: StringWithAggregatesFilter<"HabitCategory"> | string
    mountainIcon?: StringWithAggregatesFilter<"HabitCategory"> | string
    mountainImage?: StringNullableWithAggregatesFilter<"HabitCategory"> | string | null
    primaryColor?: StringWithAggregatesFilter<"HabitCategory"> | string
    secondaryColor?: StringWithAggregatesFilter<"HabitCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HabitCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HabitCategory"> | Date | string
  }

  export type HabitWhereInput = {
    AND?: HabitWhereInput | HabitWhereInput[]
    OR?: HabitWhereInput[]
    NOT?: HabitWhereInput | HabitWhereInput[]
    id?: StringFilter<"Habit"> | string
    categoryId?: StringFilter<"Habit"> | string
    title?: StringFilter<"Habit"> | string
    difficulty?: StringFilter<"Habit"> | string
    description?: StringNullableFilter<"Habit"> | string | null
    rating?: FloatFilter<"Habit"> | number
    maturity?: StringNullableFilter<"Habit"> | string | null
    submissionType?: StringFilter<"Habit"> | string
    tips?: StringNullableFilter<"Habit"> | string | null
    preChallengeGuide?: StringNullableFilter<"Habit"> | string | null
    incentives?: StringNullableFilter<"Habit"> | string | null
    createdAt?: DateTimeFilter<"Habit"> | Date | string
    updatedAt?: DateTimeFilter<"Habit"> | Date | string
    category?: XOR<HabitCategoryRelationFilter, HabitCategoryWhereInput>
    joinedUsers?: UserListRelationFilter
    proofs?: HabitProofListRelationFilter
    invites?: HabitInviteListRelationFilter
    userSettings?: HabitUserSettingsListRelationFilter
  }

  export type HabitOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    difficulty?: SortOrder
    description?: SortOrderInput | SortOrder
    rating?: SortOrder
    maturity?: SortOrderInput | SortOrder
    submissionType?: SortOrder
    tips?: SortOrderInput | SortOrder
    preChallengeGuide?: SortOrderInput | SortOrder
    incentives?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: HabitCategoryOrderByWithRelationInput
    joinedUsers?: UserOrderByRelationAggregateInput
    proofs?: HabitProofOrderByRelationAggregateInput
    invites?: HabitInviteOrderByRelationAggregateInput
    userSettings?: HabitUserSettingsOrderByRelationAggregateInput
  }

  export type HabitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HabitWhereInput | HabitWhereInput[]
    OR?: HabitWhereInput[]
    NOT?: HabitWhereInput | HabitWhereInput[]
    categoryId?: StringFilter<"Habit"> | string
    title?: StringFilter<"Habit"> | string
    difficulty?: StringFilter<"Habit"> | string
    description?: StringNullableFilter<"Habit"> | string | null
    rating?: FloatFilter<"Habit"> | number
    maturity?: StringNullableFilter<"Habit"> | string | null
    submissionType?: StringFilter<"Habit"> | string
    tips?: StringNullableFilter<"Habit"> | string | null
    preChallengeGuide?: StringNullableFilter<"Habit"> | string | null
    incentives?: StringNullableFilter<"Habit"> | string | null
    createdAt?: DateTimeFilter<"Habit"> | Date | string
    updatedAt?: DateTimeFilter<"Habit"> | Date | string
    category?: XOR<HabitCategoryRelationFilter, HabitCategoryWhereInput>
    joinedUsers?: UserListRelationFilter
    proofs?: HabitProofListRelationFilter
    invites?: HabitInviteListRelationFilter
    userSettings?: HabitUserSettingsListRelationFilter
  }, "id">

  export type HabitOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    difficulty?: SortOrder
    description?: SortOrderInput | SortOrder
    rating?: SortOrder
    maturity?: SortOrderInput | SortOrder
    submissionType?: SortOrder
    tips?: SortOrderInput | SortOrder
    preChallengeGuide?: SortOrderInput | SortOrder
    incentives?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HabitCountOrderByAggregateInput
    _avg?: HabitAvgOrderByAggregateInput
    _max?: HabitMaxOrderByAggregateInput
    _min?: HabitMinOrderByAggregateInput
    _sum?: HabitSumOrderByAggregateInput
  }

  export type HabitScalarWhereWithAggregatesInput = {
    AND?: HabitScalarWhereWithAggregatesInput | HabitScalarWhereWithAggregatesInput[]
    OR?: HabitScalarWhereWithAggregatesInput[]
    NOT?: HabitScalarWhereWithAggregatesInput | HabitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Habit"> | string
    categoryId?: StringWithAggregatesFilter<"Habit"> | string
    title?: StringWithAggregatesFilter<"Habit"> | string
    difficulty?: StringWithAggregatesFilter<"Habit"> | string
    description?: StringNullableWithAggregatesFilter<"Habit"> | string | null
    rating?: FloatWithAggregatesFilter<"Habit"> | number
    maturity?: StringNullableWithAggregatesFilter<"Habit"> | string | null
    submissionType?: StringWithAggregatesFilter<"Habit"> | string
    tips?: StringNullableWithAggregatesFilter<"Habit"> | string | null
    preChallengeGuide?: StringNullableWithAggregatesFilter<"Habit"> | string | null
    incentives?: StringNullableWithAggregatesFilter<"Habit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Habit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Habit"> | Date | string
  }

  export type HabitUserSettingsWhereInput = {
    AND?: HabitUserSettingsWhereInput | HabitUserSettingsWhereInput[]
    OR?: HabitUserSettingsWhereInput[]
    NOT?: HabitUserSettingsWhereInput | HabitUserSettingsWhereInput[]
    userId?: StringFilter<"HabitUserSettings"> | string
    habitId?: StringFilter<"HabitUserSettings"> | string
    isFavorite?: BoolFilter<"HabitUserSettings"> | boolean
    notifyMe?: BoolFilter<"HabitUserSettings"> | boolean
    rating?: IntNullableFilter<"HabitUserSettings"> | number | null
    createdAt?: DateTimeFilter<"HabitUserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"HabitUserSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    habit?: XOR<HabitRelationFilter, HabitWhereInput>
  }

  export type HabitUserSettingsOrderByWithRelationInput = {
    userId?: SortOrder
    habitId?: SortOrder
    isFavorite?: SortOrder
    notifyMe?: SortOrder
    rating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    habit?: HabitOrderByWithRelationInput
  }

  export type HabitUserSettingsWhereUniqueInput = Prisma.AtLeast<{
    userId_habitId?: HabitUserSettingsUserIdHabitIdCompoundUniqueInput
    AND?: HabitUserSettingsWhereInput | HabitUserSettingsWhereInput[]
    OR?: HabitUserSettingsWhereInput[]
    NOT?: HabitUserSettingsWhereInput | HabitUserSettingsWhereInput[]
    userId?: StringFilter<"HabitUserSettings"> | string
    habitId?: StringFilter<"HabitUserSettings"> | string
    isFavorite?: BoolFilter<"HabitUserSettings"> | boolean
    notifyMe?: BoolFilter<"HabitUserSettings"> | boolean
    rating?: IntNullableFilter<"HabitUserSettings"> | number | null
    createdAt?: DateTimeFilter<"HabitUserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"HabitUserSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    habit?: XOR<HabitRelationFilter, HabitWhereInput>
  }, "userId_habitId">

  export type HabitUserSettingsOrderByWithAggregationInput = {
    userId?: SortOrder
    habitId?: SortOrder
    isFavorite?: SortOrder
    notifyMe?: SortOrder
    rating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HabitUserSettingsCountOrderByAggregateInput
    _avg?: HabitUserSettingsAvgOrderByAggregateInput
    _max?: HabitUserSettingsMaxOrderByAggregateInput
    _min?: HabitUserSettingsMinOrderByAggregateInput
    _sum?: HabitUserSettingsSumOrderByAggregateInput
  }

  export type HabitUserSettingsScalarWhereWithAggregatesInput = {
    AND?: HabitUserSettingsScalarWhereWithAggregatesInput | HabitUserSettingsScalarWhereWithAggregatesInput[]
    OR?: HabitUserSettingsScalarWhereWithAggregatesInput[]
    NOT?: HabitUserSettingsScalarWhereWithAggregatesInput | HabitUserSettingsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"HabitUserSettings"> | string
    habitId?: StringWithAggregatesFilter<"HabitUserSettings"> | string
    isFavorite?: BoolWithAggregatesFilter<"HabitUserSettings"> | boolean
    notifyMe?: BoolWithAggregatesFilter<"HabitUserSettings"> | boolean
    rating?: IntNullableWithAggregatesFilter<"HabitUserSettings"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"HabitUserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HabitUserSettings"> | Date | string
  }

  export type HabitProofWhereInput = {
    AND?: HabitProofWhereInput | HabitProofWhereInput[]
    OR?: HabitProofWhereInput[]
    NOT?: HabitProofWhereInput | HabitProofWhereInput[]
    id?: StringFilter<"HabitProof"> | string
    userId?: StringFilter<"HabitProof"> | string
    habitId?: StringFilter<"HabitProof"> | string
    imageUrl?: StringFilter<"HabitProof"> | string
    round?: IntFilter<"HabitProof"> | number
    status?: StringFilter<"HabitProof"> | string
    createdAt?: DateTimeFilter<"HabitProof"> | Date | string
    updatedAt?: DateTimeFilter<"HabitProof"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    habit?: XOR<HabitRelationFilter, HabitWhereInput>
    votes?: ProofVoteListRelationFilter
  }

  export type HabitProofOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    habitId?: SortOrder
    imageUrl?: SortOrder
    round?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    habit?: HabitOrderByWithRelationInput
    votes?: ProofVoteOrderByRelationAggregateInput
  }

  export type HabitProofWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HabitProofWhereInput | HabitProofWhereInput[]
    OR?: HabitProofWhereInput[]
    NOT?: HabitProofWhereInput | HabitProofWhereInput[]
    userId?: StringFilter<"HabitProof"> | string
    habitId?: StringFilter<"HabitProof"> | string
    imageUrl?: StringFilter<"HabitProof"> | string
    round?: IntFilter<"HabitProof"> | number
    status?: StringFilter<"HabitProof"> | string
    createdAt?: DateTimeFilter<"HabitProof"> | Date | string
    updatedAt?: DateTimeFilter<"HabitProof"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    habit?: XOR<HabitRelationFilter, HabitWhereInput>
    votes?: ProofVoteListRelationFilter
  }, "id">

  export type HabitProofOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    habitId?: SortOrder
    imageUrl?: SortOrder
    round?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HabitProofCountOrderByAggregateInput
    _avg?: HabitProofAvgOrderByAggregateInput
    _max?: HabitProofMaxOrderByAggregateInput
    _min?: HabitProofMinOrderByAggregateInput
    _sum?: HabitProofSumOrderByAggregateInput
  }

  export type HabitProofScalarWhereWithAggregatesInput = {
    AND?: HabitProofScalarWhereWithAggregatesInput | HabitProofScalarWhereWithAggregatesInput[]
    OR?: HabitProofScalarWhereWithAggregatesInput[]
    NOT?: HabitProofScalarWhereWithAggregatesInput | HabitProofScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HabitProof"> | string
    userId?: StringWithAggregatesFilter<"HabitProof"> | string
    habitId?: StringWithAggregatesFilter<"HabitProof"> | string
    imageUrl?: StringWithAggregatesFilter<"HabitProof"> | string
    round?: IntWithAggregatesFilter<"HabitProof"> | number
    status?: StringWithAggregatesFilter<"HabitProof"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HabitProof"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HabitProof"> | Date | string
  }

  export type ProofVoteWhereInput = {
    AND?: ProofVoteWhereInput | ProofVoteWhereInput[]
    OR?: ProofVoteWhereInput[]
    NOT?: ProofVoteWhereInput | ProofVoteWhereInput[]
    id?: StringFilter<"ProofVote"> | string
    proofId?: StringFilter<"ProofVote"> | string
    voterId?: StringFilter<"ProofVote"> | string
    voteType?: StringFilter<"ProofVote"> | string
    createdAt?: DateTimeFilter<"ProofVote"> | Date | string
    proof?: XOR<HabitProofRelationFilter, HabitProofWhereInput>
    voter?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProofVoteOrderByWithRelationInput = {
    id?: SortOrder
    proofId?: SortOrder
    voterId?: SortOrder
    voteType?: SortOrder
    createdAt?: SortOrder
    proof?: HabitProofOrderByWithRelationInput
    voter?: UserOrderByWithRelationInput
  }

  export type ProofVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    proofId_voterId?: ProofVoteProofIdVoterIdCompoundUniqueInput
    AND?: ProofVoteWhereInput | ProofVoteWhereInput[]
    OR?: ProofVoteWhereInput[]
    NOT?: ProofVoteWhereInput | ProofVoteWhereInput[]
    proofId?: StringFilter<"ProofVote"> | string
    voterId?: StringFilter<"ProofVote"> | string
    voteType?: StringFilter<"ProofVote"> | string
    createdAt?: DateTimeFilter<"ProofVote"> | Date | string
    proof?: XOR<HabitProofRelationFilter, HabitProofWhereInput>
    voter?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "proofId_voterId">

  export type ProofVoteOrderByWithAggregationInput = {
    id?: SortOrder
    proofId?: SortOrder
    voterId?: SortOrder
    voteType?: SortOrder
    createdAt?: SortOrder
    _count?: ProofVoteCountOrderByAggregateInput
    _max?: ProofVoteMaxOrderByAggregateInput
    _min?: ProofVoteMinOrderByAggregateInput
  }

  export type ProofVoteScalarWhereWithAggregatesInput = {
    AND?: ProofVoteScalarWhereWithAggregatesInput | ProofVoteScalarWhereWithAggregatesInput[]
    OR?: ProofVoteScalarWhereWithAggregatesInput[]
    NOT?: ProofVoteScalarWhereWithAggregatesInput | ProofVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProofVote"> | string
    proofId?: StringWithAggregatesFilter<"ProofVote"> | string
    voterId?: StringWithAggregatesFilter<"ProofVote"> | string
    voteType?: StringWithAggregatesFilter<"ProofVote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProofVote"> | Date | string
  }

  export type FriendshipWhereInput = {
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    id?: StringFilter<"Friendship"> | string
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    status?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    friend?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FriendshipOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    friend?: UserOrderByWithRelationInput
  }

  export type FriendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_friendId?: FriendshipUserIdFriendIdCompoundUniqueInput
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    status?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    friend?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_friendId">

  export type FriendshipOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: FriendshipCountOrderByAggregateInput
    _max?: FriendshipMaxOrderByAggregateInput
    _min?: FriendshipMinOrderByAggregateInput
  }

  export type FriendshipScalarWhereWithAggregatesInput = {
    AND?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    OR?: FriendshipScalarWhereWithAggregatesInput[]
    NOT?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Friendship"> | string
    userId?: StringWithAggregatesFilter<"Friendship"> | string
    friendId?: StringWithAggregatesFilter<"Friendship"> | string
    status?: StringWithAggregatesFilter<"Friendship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingId?: FollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "followerId_followingId">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Follow"> | string
    followerId?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
  }

  export type HabitInviteWhereInput = {
    AND?: HabitInviteWhereInput | HabitInviteWhereInput[]
    OR?: HabitInviteWhereInput[]
    NOT?: HabitInviteWhereInput | HabitInviteWhereInput[]
    id?: StringFilter<"HabitInvite"> | string
    code?: StringFilter<"HabitInvite"> | string
    habitId?: StringNullableFilter<"HabitInvite"> | string | null
    inviterId?: StringFilter<"HabitInvite"> | string
    inviteePhone?: StringNullableFilter<"HabitInvite"> | string | null
    expiresAt?: DateTimeFilter<"HabitInvite"> | Date | string
    usedById?: StringNullableFilter<"HabitInvite"> | string | null
    createdAt?: DateTimeFilter<"HabitInvite"> | Date | string
    habit?: XOR<HabitNullableRelationFilter, HabitWhereInput> | null
    inviter?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HabitInviteOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    habitId?: SortOrderInput | SortOrder
    inviterId?: SortOrder
    inviteePhone?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    usedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    habit?: HabitOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
  }

  export type HabitInviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: HabitInviteWhereInput | HabitInviteWhereInput[]
    OR?: HabitInviteWhereInput[]
    NOT?: HabitInviteWhereInput | HabitInviteWhereInput[]
    habitId?: StringNullableFilter<"HabitInvite"> | string | null
    inviterId?: StringFilter<"HabitInvite"> | string
    inviteePhone?: StringNullableFilter<"HabitInvite"> | string | null
    expiresAt?: DateTimeFilter<"HabitInvite"> | Date | string
    usedById?: StringNullableFilter<"HabitInvite"> | string | null
    createdAt?: DateTimeFilter<"HabitInvite"> | Date | string
    habit?: XOR<HabitNullableRelationFilter, HabitWhereInput> | null
    inviter?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type HabitInviteOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    habitId?: SortOrderInput | SortOrder
    inviterId?: SortOrder
    inviteePhone?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    usedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: HabitInviteCountOrderByAggregateInput
    _max?: HabitInviteMaxOrderByAggregateInput
    _min?: HabitInviteMinOrderByAggregateInput
  }

  export type HabitInviteScalarWhereWithAggregatesInput = {
    AND?: HabitInviteScalarWhereWithAggregatesInput | HabitInviteScalarWhereWithAggregatesInput[]
    OR?: HabitInviteScalarWhereWithAggregatesInput[]
    NOT?: HabitInviteScalarWhereWithAggregatesInput | HabitInviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HabitInvite"> | string
    code?: StringWithAggregatesFilter<"HabitInvite"> | string
    habitId?: StringNullableWithAggregatesFilter<"HabitInvite"> | string | null
    inviterId?: StringWithAggregatesFilter<"HabitInvite"> | string
    inviteePhone?: StringNullableWithAggregatesFilter<"HabitInvite"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"HabitInvite"> | Date | string
    usedById?: StringNullableWithAggregatesFilter<"HabitInvite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HabitInvite"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryItemCreateInput = {
    id?: string
    itemId: string
    user: UserCreateNestedOneWithoutInventoryInput
  }

  export type UserInventoryItemUncheckedCreateInput = {
    id?: string
    userId: string
    itemId: string
  }

  export type UserInventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type UserInventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type UserInventoryItemCreateManyInput = {
    id?: string
    userId: string
    itemId: string
  }

  export type UserInventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type UserInventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    inviteCode?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    challenges?: ChallengeCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    inviteCode?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    challenges?: ChallengeUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    inviteCode?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutTeamMembersInput
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    userId: string
    teamId: string
    role?: string
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamMembersNestedInput
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    userId: string
    teamId: string
    role?: string
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeCreateInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedChallengesInput
    team?: TeamCreateNestedOneWithoutChallengesInput
    participants?: ChallengeParticipantCreateNestedManyWithoutChallengeInput
    progressLogs?: ProgressLogCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    teamId?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedChallengesNestedInput
    team?: TeamUpdateOneWithoutChallengesNestedInput
    participants?: ChallengeParticipantUpdateManyWithoutChallengeNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateManyInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    teamId?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantCreateInput = {
    id?: string
    currentValue?: number
    heartsLeft?: number | null
    isEliminated?: boolean
    relayOrder?: number | null
    relayCompleted?: boolean
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutParticipationsInput
    challenge: ChallengeCreateNestedOneWithoutParticipantsInput
  }

  export type ChallengeParticipantUncheckedCreateInput = {
    id?: string
    userId: string
    challengeId: string
    currentValue?: number
    heartsLeft?: number | null
    isEliminated?: boolean
    relayOrder?: number | null
    relayCompleted?: boolean
    joinedAt?: Date | string
  }

  export type ChallengeParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    heartsLeft?: NullableIntFieldUpdateOperationsInput | number | null
    isEliminated?: BoolFieldUpdateOperationsInput | boolean
    relayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    relayCompleted?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParticipationsNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ChallengeParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    heartsLeft?: NullableIntFieldUpdateOperationsInput | number | null
    isEliminated?: BoolFieldUpdateOperationsInput | boolean
    relayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    relayCompleted?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantCreateManyInput = {
    id?: string
    userId: string
    challengeId: string
    currentValue?: number
    heartsLeft?: number | null
    isEliminated?: boolean
    relayOrder?: number | null
    relayCompleted?: boolean
    joinedAt?: Date | string
  }

  export type ChallengeParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    heartsLeft?: NullableIntFieldUpdateOperationsInput | number | null
    isEliminated?: BoolFieldUpdateOperationsInput | boolean
    relayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    relayCompleted?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    heartsLeft?: NullableIntFieldUpdateOperationsInput | number | null
    isEliminated?: BoolFieldUpdateOperationsInput | boolean
    relayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    relayCompleted?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressLogCreateInput = {
    id?: string
    value: number
    isSuccess?: boolean
    note?: string | null
    date?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProgressLogsInput
    challenge: ChallengeCreateNestedOneWithoutProgressLogsInput
  }

  export type ProgressLogUncheckedCreateInput = {
    id?: string
    userId: string
    challengeId: string
    value: number
    isSuccess?: boolean
    note?: string | null
    date?: Date | string
    createdAt?: Date | string
  }

  export type ProgressLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgressLogsNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutProgressLogsNestedInput
  }

  export type ProgressLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressLogCreateManyInput = {
    id?: string
    userId: string
    challengeId: string
    value: number
    isSuccess?: boolean
    note?: string | null
    date?: Date | string
    createdAt?: Date | string
  }

  export type ProgressLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateInput = {
    id?: string
    name: string
    description: string
    iconUrl?: string | null
    xpReward?: number
    users?: UserBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    iconUrl?: string | null
    xpReward?: number
    users?: UserBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xpReward?: IntFieldUpdateOperationsInput | number
    users?: UserBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xpReward?: IntFieldUpdateOperationsInput | number
    users?: UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    name: string
    description: string
    iconUrl?: string | null
    xpReward?: number
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xpReward?: IntFieldUpdateOperationsInput | number
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xpReward?: IntFieldUpdateOperationsInput | number
  }

  export type UserBadgeCreateInput = {
    id?: string
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateInput = {
    id?: string
    userId: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyInput = {
    id?: string
    userId: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitCategoryCreateInput = {
    id?: string
    name: string
    biomeType: string
    mountainIcon: string
    mountainImage?: string | null
    primaryColor: string
    secondaryColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitCreateNestedManyWithoutCategoryInput
    activeClimbers?: UserCreateNestedManyWithoutCurrentMountainInput
  }

  export type HabitCategoryUncheckedCreateInput = {
    id?: string
    name: string
    biomeType: string
    mountainIcon: string
    mountainImage?: string | null
    primaryColor: string
    secondaryColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitUncheckedCreateNestedManyWithoutCategoryInput
    activeClimbers?: UserUncheckedCreateNestedManyWithoutCurrentMountainInput
  }

  export type HabitCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biomeType?: StringFieldUpdateOperationsInput | string
    mountainIcon?: StringFieldUpdateOperationsInput | string
    mountainImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUpdateManyWithoutCategoryNestedInput
    activeClimbers?: UserUpdateManyWithoutCurrentMountainNestedInput
  }

  export type HabitCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biomeType?: StringFieldUpdateOperationsInput | string
    mountainIcon?: StringFieldUpdateOperationsInput | string
    mountainImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUncheckedUpdateManyWithoutCategoryNestedInput
    activeClimbers?: UserUncheckedUpdateManyWithoutCurrentMountainNestedInput
  }

  export type HabitCategoryCreateManyInput = {
    id?: string
    name: string
    biomeType: string
    mountainIcon: string
    mountainImage?: string | null
    primaryColor: string
    secondaryColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biomeType?: StringFieldUpdateOperationsInput | string
    mountainIcon?: StringFieldUpdateOperationsInput | string
    mountainImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biomeType?: StringFieldUpdateOperationsInput | string
    mountainIcon?: StringFieldUpdateOperationsInput | string
    mountainImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitCreateInput = {
    id?: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: HabitCategoryCreateNestedOneWithoutHabitsInput
    joinedUsers?: UserCreateNestedManyWithoutJoinedHabitsInput
    proofs?: HabitProofCreateNestedManyWithoutHabitInput
    invites?: HabitInviteCreateNestedManyWithoutHabitInput
    userSettings?: HabitUserSettingsCreateNestedManyWithoutHabitInput
  }

  export type HabitUncheckedCreateInput = {
    id?: string
    categoryId: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    joinedUsers?: UserUncheckedCreateNestedManyWithoutJoinedHabitsInput
    proofs?: HabitProofUncheckedCreateNestedManyWithoutHabitInput
    invites?: HabitInviteUncheckedCreateNestedManyWithoutHabitInput
    userSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutHabitInput
  }

  export type HabitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: HabitCategoryUpdateOneRequiredWithoutHabitsNestedInput
    joinedUsers?: UserUpdateManyWithoutJoinedHabitsNestedInput
    proofs?: HabitProofUpdateManyWithoutHabitNestedInput
    invites?: HabitInviteUpdateManyWithoutHabitNestedInput
    userSettings?: HabitUserSettingsUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedUsers?: UserUncheckedUpdateManyWithoutJoinedHabitsNestedInput
    proofs?: HabitProofUncheckedUpdateManyWithoutHabitNestedInput
    invites?: HabitInviteUncheckedUpdateManyWithoutHabitNestedInput
    userSettings?: HabitUserSettingsUncheckedUpdateManyWithoutHabitNestedInput
  }

  export type HabitCreateManyInput = {
    id?: string
    categoryId: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUserSettingsCreateInput = {
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHabitSettingsInput
    habit: HabitCreateNestedOneWithoutUserSettingsInput
  }

  export type HabitUserSettingsUncheckedCreateInput = {
    userId: string
    habitId: string
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUserSettingsUpdateInput = {
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notifyMe?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHabitSettingsNestedInput
    habit?: HabitUpdateOneRequiredWithoutUserSettingsNestedInput
  }

  export type HabitUserSettingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notifyMe?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUserSettingsCreateManyInput = {
    userId: string
    habitId: string
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUserSettingsUpdateManyMutationInput = {
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notifyMe?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUserSettingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notifyMe?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitProofCreateInput = {
    id?: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHabitProofsInput
    habit: HabitCreateNestedOneWithoutProofsInput
    votes?: ProofVoteCreateNestedManyWithoutProofInput
  }

  export type HabitProofUncheckedCreateInput = {
    id?: string
    userId: string
    habitId: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ProofVoteUncheckedCreateNestedManyWithoutProofInput
  }

  export type HabitProofUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHabitProofsNestedInput
    habit?: HabitUpdateOneRequiredWithoutProofsNestedInput
    votes?: ProofVoteUpdateManyWithoutProofNestedInput
  }

  export type HabitProofUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ProofVoteUncheckedUpdateManyWithoutProofNestedInput
  }

  export type HabitProofCreateManyInput = {
    id?: string
    userId: string
    habitId: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitProofUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitProofUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProofVoteCreateInput = {
    id?: string
    voteType: string
    createdAt?: Date | string
    proof: HabitProofCreateNestedOneWithoutVotesInput
    voter: UserCreateNestedOneWithoutProofVotesInput
  }

  export type ProofVoteUncheckedCreateInput = {
    id?: string
    proofId: string
    voterId: string
    voteType: string
    createdAt?: Date | string
  }

  export type ProofVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proof?: HabitProofUpdateOneRequiredWithoutVotesNestedInput
    voter?: UserUpdateOneRequiredWithoutProofVotesNestedInput
  }

  export type ProofVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proofId?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProofVoteCreateManyInput = {
    id?: string
    proofId: string
    voterId: string
    voteType: string
    createdAt?: Date | string
  }

  export type ProofVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProofVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proofId?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFriendsInput
    friend: UserCreateNestedOneWithoutFriendOfInput
  }

  export type FriendshipUncheckedCreateInput = {
    id?: string
    userId: string
    friendId: string
    status?: string
    createdAt?: Date | string
  }

  export type FriendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFriendsNestedInput
    friend?: UserUpdateOneRequiredWithoutFriendOfNestedInput
  }

  export type FriendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateManyInput = {
    id?: string
    userId: string
    friendId: string
    status?: string
    createdAt?: Date | string
  }

  export type FriendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingInput
    following: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
    following?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateManyInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitInviteCreateInput = {
    id?: string
    code: string
    inviteePhone?: string | null
    expiresAt: Date | string
    usedById?: string | null
    createdAt?: Date | string
    habit?: HabitCreateNestedOneWithoutInvitesInput
    inviter: UserCreateNestedOneWithoutHabitInvitesInput
  }

  export type HabitInviteUncheckedCreateInput = {
    id?: string
    code: string
    habitId?: string | null
    inviterId: string
    inviteePhone?: string | null
    expiresAt: Date | string
    usedById?: string | null
    createdAt?: Date | string
  }

  export type HabitInviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habit?: HabitUpdateOneWithoutInvitesNestedInput
    inviter?: UserUpdateOneRequiredWithoutHabitInvitesNestedInput
  }

  export type HabitInviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    habitId?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitInviteCreateManyInput = {
    id?: string
    code: string
    habitId?: string | null
    inviterId: string
    inviteePhone?: string | null
    expiresAt: Date | string
    usedById?: string | null
    createdAt?: Date | string
  }

  export type HabitInviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitInviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    habitId?: NullableStringFieldUpdateOperationsInput | string | null
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type HabitCategoryNullableRelationFilter = {
    is?: HabitCategoryWhereInput | null
    isNot?: HabitCategoryWhereInput | null
  }

  export type UserInventoryItemListRelationFilter = {
    every?: UserInventoryItemWhereInput
    some?: UserInventoryItemWhereInput
    none?: UserInventoryItemWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type ChallengeParticipantListRelationFilter = {
    every?: ChallengeParticipantWhereInput
    some?: ChallengeParticipantWhereInput
    none?: ChallengeParticipantWhereInput
  }

  export type ProgressLogListRelationFilter = {
    every?: ProgressLogWhereInput
    some?: ProgressLogWhereInput
    none?: ProgressLogWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: UserBadgeWhereInput
    some?: UserBadgeWhereInput
    none?: UserBadgeWhereInput
  }

  export type ChallengeListRelationFilter = {
    every?: ChallengeWhereInput
    some?: ChallengeWhereInput
    none?: ChallengeWhereInput
  }

  export type HabitListRelationFilter = {
    every?: HabitWhereInput
    some?: HabitWhereInput
    none?: HabitWhereInput
  }

  export type HabitProofListRelationFilter = {
    every?: HabitProofWhereInput
    some?: HabitProofWhereInput
    none?: HabitProofWhereInput
  }

  export type ProofVoteListRelationFilter = {
    every?: ProofVoteWhereInput
    some?: ProofVoteWhereInput
    none?: ProofVoteWhereInput
  }

  export type FriendshipListRelationFilter = {
    every?: FriendshipWhereInput
    some?: FriendshipWhereInput
    none?: FriendshipWhereInput
  }

  export type HabitInviteListRelationFilter = {
    every?: HabitInviteWhereInput
    some?: HabitInviteWhereInput
    none?: HabitInviteWhereInput
  }

  export type HabitUserSettingsListRelationFilter = {
    every?: HabitUserSettingsWhereInput
    some?: HabitUserSettingsWhereInput
    none?: HabitUserSettingsWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserInventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgressLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HabitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HabitProofOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProofVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HabitInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HabitUserSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    gender?: SortOrder
    birthday?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    isPublic?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    coins?: SortOrder
    totalAchievements?: SortOrder
    currentMountainId?: SortOrder
    currentAltitude?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    xp?: SortOrder
    level?: SortOrder
    coins?: SortOrder
    totalAchievements?: SortOrder
    currentAltitude?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    gender?: SortOrder
    birthday?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    isPublic?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    coins?: SortOrder
    totalAchievements?: SortOrder
    currentMountainId?: SortOrder
    currentAltitude?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    gender?: SortOrder
    birthday?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    isPublic?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    coins?: SortOrder
    totalAchievements?: SortOrder
    currentMountainId?: SortOrder
    currentAltitude?: SortOrder
    lastActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    xp?: SortOrder
    level?: SortOrder
    coins?: SortOrder
    totalAchievements?: SortOrder
    currentAltitude?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserInventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
  }

  export type UserInventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
  }

  export type UserInventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itemId?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatarUrl?: SortOrder
    inviteCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatarUrl?: SortOrder
    inviteCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    avatarUrl?: SortOrder
    inviteCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamMemberUserIdTeamIdCompoundUniqueInput = {
    userId: string
    teamId: string
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TeamNullableRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    targetGoal?: SortOrder
    thresholdPct?: SortOrder
    maxHearts?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    teamId?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeAvgOrderByAggregateInput = {
    targetGoal?: SortOrder
    thresholdPct?: SortOrder
    maxHearts?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    targetGoal?: SortOrder
    thresholdPct?: SortOrder
    maxHearts?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    teamId?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    targetGoal?: SortOrder
    thresholdPct?: SortOrder
    maxHearts?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    teamId?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeSumOrderByAggregateInput = {
    targetGoal?: SortOrder
    thresholdPct?: SortOrder
    maxHearts?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ChallengeRelationFilter = {
    is?: ChallengeWhereInput
    isNot?: ChallengeWhereInput
  }

  export type ChallengeParticipantUserIdChallengeIdCompoundUniqueInput = {
    userId: string
    challengeId: string
  }

  export type ChallengeParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    currentValue?: SortOrder
    heartsLeft?: SortOrder
    isEliminated?: SortOrder
    relayOrder?: SortOrder
    relayCompleted?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChallengeParticipantAvgOrderByAggregateInput = {
    currentValue?: SortOrder
    heartsLeft?: SortOrder
    relayOrder?: SortOrder
  }

  export type ChallengeParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    currentValue?: SortOrder
    heartsLeft?: SortOrder
    isEliminated?: SortOrder
    relayOrder?: SortOrder
    relayCompleted?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChallengeParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    currentValue?: SortOrder
    heartsLeft?: SortOrder
    isEliminated?: SortOrder
    relayOrder?: SortOrder
    relayCompleted?: SortOrder
    joinedAt?: SortOrder
  }

  export type ChallengeParticipantSumOrderByAggregateInput = {
    currentValue?: SortOrder
    heartsLeft?: SortOrder
    relayOrder?: SortOrder
  }

  export type ProgressLogUserIdChallengeIdDateCompoundUniqueInput = {
    userId: string
    challengeId: string
    date: Date | string
  }

  export type ProgressLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    value?: SortOrder
    isSuccess?: SortOrder
    note?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgressLogAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type ProgressLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    value?: SortOrder
    isSuccess?: SortOrder
    note?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgressLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    value?: SortOrder
    isSuccess?: SortOrder
    note?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgressLogSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    xpReward?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    xpReward?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    xpReward?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    xpReward?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    xpReward?: SortOrder
  }

  export type BadgeRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type UserBadgeUserIdBadgeIdCompoundUniqueInput = {
    userId: string
    badgeId: string
  }

  export type UserBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HabitCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    biomeType?: SortOrder
    mountainIcon?: SortOrder
    mountainImage?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    biomeType?: SortOrder
    mountainIcon?: SortOrder
    mountainImage?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    biomeType?: SortOrder
    mountainIcon?: SortOrder
    mountainImage?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitCategoryRelationFilter = {
    is?: HabitCategoryWhereInput
    isNot?: HabitCategoryWhereInput
  }

  export type HabitCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    difficulty?: SortOrder
    description?: SortOrder
    rating?: SortOrder
    maturity?: SortOrder
    submissionType?: SortOrder
    tips?: SortOrder
    preChallengeGuide?: SortOrder
    incentives?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type HabitMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    difficulty?: SortOrder
    description?: SortOrder
    rating?: SortOrder
    maturity?: SortOrder
    submissionType?: SortOrder
    tips?: SortOrder
    preChallengeGuide?: SortOrder
    incentives?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    difficulty?: SortOrder
    description?: SortOrder
    rating?: SortOrder
    maturity?: SortOrder
    submissionType?: SortOrder
    tips?: SortOrder
    preChallengeGuide?: SortOrder
    incentives?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type HabitRelationFilter = {
    is?: HabitWhereInput
    isNot?: HabitWhereInput
  }

  export type HabitUserSettingsUserIdHabitIdCompoundUniqueInput = {
    userId: string
    habitId: string
  }

  export type HabitUserSettingsCountOrderByAggregateInput = {
    userId?: SortOrder
    habitId?: SortOrder
    isFavorite?: SortOrder
    notifyMe?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitUserSettingsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type HabitUserSettingsMaxOrderByAggregateInput = {
    userId?: SortOrder
    habitId?: SortOrder
    isFavorite?: SortOrder
    notifyMe?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitUserSettingsMinOrderByAggregateInput = {
    userId?: SortOrder
    habitId?: SortOrder
    isFavorite?: SortOrder
    notifyMe?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitUserSettingsSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type HabitProofCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    habitId?: SortOrder
    imageUrl?: SortOrder
    round?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitProofAvgOrderByAggregateInput = {
    round?: SortOrder
  }

  export type HabitProofMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    habitId?: SortOrder
    imageUrl?: SortOrder
    round?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitProofMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    habitId?: SortOrder
    imageUrl?: SortOrder
    round?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HabitProofSumOrderByAggregateInput = {
    round?: SortOrder
  }

  export type HabitProofRelationFilter = {
    is?: HabitProofWhereInput
    isNot?: HabitProofWhereInput
  }

  export type ProofVoteProofIdVoterIdCompoundUniqueInput = {
    proofId: string
    voterId: string
  }

  export type ProofVoteCountOrderByAggregateInput = {
    id?: SortOrder
    proofId?: SortOrder
    voterId?: SortOrder
    voteType?: SortOrder
    createdAt?: SortOrder
  }

  export type ProofVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    proofId?: SortOrder
    voterId?: SortOrder
    voteType?: SortOrder
    createdAt?: SortOrder
  }

  export type ProofVoteMinOrderByAggregateInput = {
    id?: SortOrder
    proofId?: SortOrder
    voterId?: SortOrder
    voteType?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipUserIdFriendIdCompoundUniqueInput = {
    userId: string
    friendId: string
  }

  export type FriendshipCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type HabitNullableRelationFilter = {
    is?: HabitWhereInput | null
    isNot?: HabitWhereInput | null
  }

  export type HabitInviteCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    habitId?: SortOrder
    inviterId?: SortOrder
    inviteePhone?: SortOrder
    expiresAt?: SortOrder
    usedById?: SortOrder
    createdAt?: SortOrder
  }

  export type HabitInviteMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    habitId?: SortOrder
    inviterId?: SortOrder
    inviteePhone?: SortOrder
    expiresAt?: SortOrder
    usedById?: SortOrder
    createdAt?: SortOrder
  }

  export type HabitInviteMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    habitId?: SortOrder
    inviterId?: SortOrder
    inviteePhone?: SortOrder
    expiresAt?: SortOrder
    usedById?: SortOrder
    createdAt?: SortOrder
  }

  export type HabitCategoryCreateNestedOneWithoutActiveClimbersInput = {
    create?: XOR<HabitCategoryCreateWithoutActiveClimbersInput, HabitCategoryUncheckedCreateWithoutActiveClimbersInput>
    connectOrCreate?: HabitCategoryCreateOrConnectWithoutActiveClimbersInput
    connect?: HabitCategoryWhereUniqueInput
  }

  export type UserInventoryItemCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput> | UserInventoryItemCreateWithoutUserInput[] | UserInventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutUserInput | UserInventoryItemCreateOrConnectWithoutUserInput[]
    createMany?: UserInventoryItemCreateManyUserInputEnvelope
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type ChallengeParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type ProgressLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgressLogCreateWithoutUserInput, ProgressLogUncheckedCreateWithoutUserInput> | ProgressLogCreateWithoutUserInput[] | ProgressLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressLogCreateOrConnectWithoutUserInput | ProgressLogCreateOrConnectWithoutUserInput[]
    createMany?: ProgressLogCreateManyUserInputEnvelope
    connect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
  }

  export type UserBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type ChallengeCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput> | ChallengeCreateWithoutCreatorInput[] | ChallengeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutCreatorInput | ChallengeCreateOrConnectWithoutCreatorInput[]
    createMany?: ChallengeCreateManyCreatorInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type HabitCreateNestedManyWithoutJoinedUsersInput = {
    create?: XOR<HabitCreateWithoutJoinedUsersInput, HabitUncheckedCreateWithoutJoinedUsersInput> | HabitCreateWithoutJoinedUsersInput[] | HabitUncheckedCreateWithoutJoinedUsersInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutJoinedUsersInput | HabitCreateOrConnectWithoutJoinedUsersInput[]
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
  }

  export type HabitProofCreateNestedManyWithoutUserInput = {
    create?: XOR<HabitProofCreateWithoutUserInput, HabitProofUncheckedCreateWithoutUserInput> | HabitProofCreateWithoutUserInput[] | HabitProofUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitProofCreateOrConnectWithoutUserInput | HabitProofCreateOrConnectWithoutUserInput[]
    createMany?: HabitProofCreateManyUserInputEnvelope
    connect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
  }

  export type ProofVoteCreateNestedManyWithoutVoterInput = {
    create?: XOR<ProofVoteCreateWithoutVoterInput, ProofVoteUncheckedCreateWithoutVoterInput> | ProofVoteCreateWithoutVoterInput[] | ProofVoteUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: ProofVoteCreateOrConnectWithoutVoterInput | ProofVoteCreateOrConnectWithoutVoterInput[]
    createMany?: ProofVoteCreateManyVoterInputEnvelope
    connect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutUserInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutFriendInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type HabitInviteCreateNestedManyWithoutInviterInput = {
    create?: XOR<HabitInviteCreateWithoutInviterInput, HabitInviteUncheckedCreateWithoutInviterInput> | HabitInviteCreateWithoutInviterInput[] | HabitInviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: HabitInviteCreateOrConnectWithoutInviterInput | HabitInviteCreateOrConnectWithoutInviterInput[]
    createMany?: HabitInviteCreateManyInviterInputEnvelope
    connect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
  }

  export type HabitUserSettingsCreateNestedManyWithoutUserInput = {
    create?: XOR<HabitUserSettingsCreateWithoutUserInput, HabitUserSettingsUncheckedCreateWithoutUserInput> | HabitUserSettingsCreateWithoutUserInput[] | HabitUserSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitUserSettingsCreateOrConnectWithoutUserInput | HabitUserSettingsCreateOrConnectWithoutUserInput[]
    createMany?: HabitUserSettingsCreateManyUserInputEnvelope
    connect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type UserInventoryItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput> | UserInventoryItemCreateWithoutUserInput[] | UserInventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutUserInput | UserInventoryItemCreateOrConnectWithoutUserInput[]
    createMany?: UserInventoryItemCreateManyUserInputEnvelope
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type ProgressLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgressLogCreateWithoutUserInput, ProgressLogUncheckedCreateWithoutUserInput> | ProgressLogCreateWithoutUserInput[] | ProgressLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressLogCreateOrConnectWithoutUserInput | ProgressLogCreateOrConnectWithoutUserInput[]
    createMany?: ProgressLogCreateManyUserInputEnvelope
    connect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type ChallengeUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput> | ChallengeCreateWithoutCreatorInput[] | ChallengeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutCreatorInput | ChallengeCreateOrConnectWithoutCreatorInput[]
    createMany?: ChallengeCreateManyCreatorInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type HabitUncheckedCreateNestedManyWithoutJoinedUsersInput = {
    create?: XOR<HabitCreateWithoutJoinedUsersInput, HabitUncheckedCreateWithoutJoinedUsersInput> | HabitCreateWithoutJoinedUsersInput[] | HabitUncheckedCreateWithoutJoinedUsersInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutJoinedUsersInput | HabitCreateOrConnectWithoutJoinedUsersInput[]
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
  }

  export type HabitProofUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HabitProofCreateWithoutUserInput, HabitProofUncheckedCreateWithoutUserInput> | HabitProofCreateWithoutUserInput[] | HabitProofUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitProofCreateOrConnectWithoutUserInput | HabitProofCreateOrConnectWithoutUserInput[]
    createMany?: HabitProofCreateManyUserInputEnvelope
    connect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
  }

  export type ProofVoteUncheckedCreateNestedManyWithoutVoterInput = {
    create?: XOR<ProofVoteCreateWithoutVoterInput, ProofVoteUncheckedCreateWithoutVoterInput> | ProofVoteCreateWithoutVoterInput[] | ProofVoteUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: ProofVoteCreateOrConnectWithoutVoterInput | ProofVoteCreateOrConnectWithoutVoterInput[]
    createMany?: ProofVoteCreateManyVoterInputEnvelope
    connect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutFriendInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type HabitInviteUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<HabitInviteCreateWithoutInviterInput, HabitInviteUncheckedCreateWithoutInviterInput> | HabitInviteCreateWithoutInviterInput[] | HabitInviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: HabitInviteCreateOrConnectWithoutInviterInput | HabitInviteCreateOrConnectWithoutInviterInput[]
    createMany?: HabitInviteCreateManyInviterInputEnvelope
    connect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
  }

  export type HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HabitUserSettingsCreateWithoutUserInput, HabitUserSettingsUncheckedCreateWithoutUserInput> | HabitUserSettingsCreateWithoutUserInput[] | HabitUserSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitUserSettingsCreateOrConnectWithoutUserInput | HabitUserSettingsCreateOrConnectWithoutUserInput[]
    createMany?: HabitUserSettingsCreateManyUserInputEnvelope
    connect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type HabitCategoryUpdateOneWithoutActiveClimbersNestedInput = {
    create?: XOR<HabitCategoryCreateWithoutActiveClimbersInput, HabitCategoryUncheckedCreateWithoutActiveClimbersInput>
    connectOrCreate?: HabitCategoryCreateOrConnectWithoutActiveClimbersInput
    upsert?: HabitCategoryUpsertWithoutActiveClimbersInput
    disconnect?: HabitCategoryWhereInput | boolean
    delete?: HabitCategoryWhereInput | boolean
    connect?: HabitCategoryWhereUniqueInput
    update?: XOR<XOR<HabitCategoryUpdateToOneWithWhereWithoutActiveClimbersInput, HabitCategoryUpdateWithoutActiveClimbersInput>, HabitCategoryUncheckedUpdateWithoutActiveClimbersInput>
  }

  export type UserInventoryItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput> | UserInventoryItemCreateWithoutUserInput[] | UserInventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutUserInput | UserInventoryItemCreateOrConnectWithoutUserInput[]
    upsert?: UserInventoryItemUpsertWithWhereUniqueWithoutUserInput | UserInventoryItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInventoryItemCreateManyUserInputEnvelope
    set?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    disconnect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    delete?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    update?: UserInventoryItemUpdateWithWhereUniqueWithoutUserInput | UserInventoryItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInventoryItemUpdateManyWithWhereWithoutUserInput | UserInventoryItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInventoryItemScalarWhereInput | UserInventoryItemScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type ChallengeParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput | ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput | ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutUserInput | ChallengeParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type ProgressLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgressLogCreateWithoutUserInput, ProgressLogUncheckedCreateWithoutUserInput> | ProgressLogCreateWithoutUserInput[] | ProgressLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressLogCreateOrConnectWithoutUserInput | ProgressLogCreateOrConnectWithoutUserInput[]
    upsert?: ProgressLogUpsertWithWhereUniqueWithoutUserInput | ProgressLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgressLogCreateManyUserInputEnvelope
    set?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    disconnect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    delete?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    connect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    update?: ProgressLogUpdateWithWhereUniqueWithoutUserInput | ProgressLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgressLogUpdateManyWithWhereWithoutUserInput | ProgressLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgressLogScalarWhereInput | ProgressLogScalarWhereInput[]
  }

  export type UserBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type ChallengeUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput> | ChallengeCreateWithoutCreatorInput[] | ChallengeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutCreatorInput | ChallengeCreateOrConnectWithoutCreatorInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutCreatorInput | ChallengeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ChallengeCreateManyCreatorInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutCreatorInput | ChallengeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutCreatorInput | ChallengeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type HabitUpdateManyWithoutJoinedUsersNestedInput = {
    create?: XOR<HabitCreateWithoutJoinedUsersInput, HabitUncheckedCreateWithoutJoinedUsersInput> | HabitCreateWithoutJoinedUsersInput[] | HabitUncheckedCreateWithoutJoinedUsersInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutJoinedUsersInput | HabitCreateOrConnectWithoutJoinedUsersInput[]
    upsert?: HabitUpsertWithWhereUniqueWithoutJoinedUsersInput | HabitUpsertWithWhereUniqueWithoutJoinedUsersInput[]
    set?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    disconnect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    delete?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    update?: HabitUpdateWithWhereUniqueWithoutJoinedUsersInput | HabitUpdateWithWhereUniqueWithoutJoinedUsersInput[]
    updateMany?: HabitUpdateManyWithWhereWithoutJoinedUsersInput | HabitUpdateManyWithWhereWithoutJoinedUsersInput[]
    deleteMany?: HabitScalarWhereInput | HabitScalarWhereInput[]
  }

  export type HabitProofUpdateManyWithoutUserNestedInput = {
    create?: XOR<HabitProofCreateWithoutUserInput, HabitProofUncheckedCreateWithoutUserInput> | HabitProofCreateWithoutUserInput[] | HabitProofUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitProofCreateOrConnectWithoutUserInput | HabitProofCreateOrConnectWithoutUserInput[]
    upsert?: HabitProofUpsertWithWhereUniqueWithoutUserInput | HabitProofUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HabitProofCreateManyUserInputEnvelope
    set?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    disconnect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    delete?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    connect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    update?: HabitProofUpdateWithWhereUniqueWithoutUserInput | HabitProofUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HabitProofUpdateManyWithWhereWithoutUserInput | HabitProofUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HabitProofScalarWhereInput | HabitProofScalarWhereInput[]
  }

  export type ProofVoteUpdateManyWithoutVoterNestedInput = {
    create?: XOR<ProofVoteCreateWithoutVoterInput, ProofVoteUncheckedCreateWithoutVoterInput> | ProofVoteCreateWithoutVoterInput[] | ProofVoteUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: ProofVoteCreateOrConnectWithoutVoterInput | ProofVoteCreateOrConnectWithoutVoterInput[]
    upsert?: ProofVoteUpsertWithWhereUniqueWithoutVoterInput | ProofVoteUpsertWithWhereUniqueWithoutVoterInput[]
    createMany?: ProofVoteCreateManyVoterInputEnvelope
    set?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    disconnect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    delete?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    connect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    update?: ProofVoteUpdateWithWhereUniqueWithoutVoterInput | ProofVoteUpdateWithWhereUniqueWithoutVoterInput[]
    updateMany?: ProofVoteUpdateManyWithWhereWithoutVoterInput | ProofVoteUpdateManyWithWhereWithoutVoterInput[]
    deleteMany?: ProofVoteScalarWhereInput | ProofVoteScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutUserNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserInput | FriendshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserInput | FriendshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserInput | FriendshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutFriendNestedInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutFriendInput | FriendshipUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutFriendInput | FriendshipUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutFriendInput | FriendshipUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type HabitInviteUpdateManyWithoutInviterNestedInput = {
    create?: XOR<HabitInviteCreateWithoutInviterInput, HabitInviteUncheckedCreateWithoutInviterInput> | HabitInviteCreateWithoutInviterInput[] | HabitInviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: HabitInviteCreateOrConnectWithoutInviterInput | HabitInviteCreateOrConnectWithoutInviterInput[]
    upsert?: HabitInviteUpsertWithWhereUniqueWithoutInviterInput | HabitInviteUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: HabitInviteCreateManyInviterInputEnvelope
    set?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    disconnect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    delete?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    connect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    update?: HabitInviteUpdateWithWhereUniqueWithoutInviterInput | HabitInviteUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: HabitInviteUpdateManyWithWhereWithoutInviterInput | HabitInviteUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: HabitInviteScalarWhereInput | HabitInviteScalarWhereInput[]
  }

  export type HabitUserSettingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<HabitUserSettingsCreateWithoutUserInput, HabitUserSettingsUncheckedCreateWithoutUserInput> | HabitUserSettingsCreateWithoutUserInput[] | HabitUserSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitUserSettingsCreateOrConnectWithoutUserInput | HabitUserSettingsCreateOrConnectWithoutUserInput[]
    upsert?: HabitUserSettingsUpsertWithWhereUniqueWithoutUserInput | HabitUserSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HabitUserSettingsCreateManyUserInputEnvelope
    set?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    disconnect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    delete?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    connect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    update?: HabitUserSettingsUpdateWithWhereUniqueWithoutUserInput | HabitUserSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HabitUserSettingsUpdateManyWithWhereWithoutUserInput | HabitUserSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HabitUserSettingsScalarWhereInput | HabitUserSettingsScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput> | UserInventoryItemCreateWithoutUserInput[] | UserInventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutUserInput | UserInventoryItemCreateOrConnectWithoutUserInput[]
    upsert?: UserInventoryItemUpsertWithWhereUniqueWithoutUserInput | UserInventoryItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInventoryItemCreateManyUserInputEnvelope
    set?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    disconnect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    delete?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    update?: UserInventoryItemUpdateWithWhereUniqueWithoutUserInput | UserInventoryItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInventoryItemUpdateManyWithWhereWithoutUserInput | UserInventoryItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInventoryItemScalarWhereInput | UserInventoryItemScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput | ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput | ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutUserInput | ChallengeParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type ProgressLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgressLogCreateWithoutUserInput, ProgressLogUncheckedCreateWithoutUserInput> | ProgressLogCreateWithoutUserInput[] | ProgressLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgressLogCreateOrConnectWithoutUserInput | ProgressLogCreateOrConnectWithoutUserInput[]
    upsert?: ProgressLogUpsertWithWhereUniqueWithoutUserInput | ProgressLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgressLogCreateManyUserInputEnvelope
    set?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    disconnect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    delete?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    connect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    update?: ProgressLogUpdateWithWhereUniqueWithoutUserInput | ProgressLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgressLogUpdateManyWithWhereWithoutUserInput | ProgressLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgressLogScalarWhereInput | ProgressLogScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type ChallengeUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput> | ChallengeCreateWithoutCreatorInput[] | ChallengeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutCreatorInput | ChallengeCreateOrConnectWithoutCreatorInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutCreatorInput | ChallengeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ChallengeCreateManyCreatorInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutCreatorInput | ChallengeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutCreatorInput | ChallengeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput = {
    create?: XOR<HabitCreateWithoutJoinedUsersInput, HabitUncheckedCreateWithoutJoinedUsersInput> | HabitCreateWithoutJoinedUsersInput[] | HabitUncheckedCreateWithoutJoinedUsersInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutJoinedUsersInput | HabitCreateOrConnectWithoutJoinedUsersInput[]
    upsert?: HabitUpsertWithWhereUniqueWithoutJoinedUsersInput | HabitUpsertWithWhereUniqueWithoutJoinedUsersInput[]
    set?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    disconnect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    delete?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    update?: HabitUpdateWithWhereUniqueWithoutJoinedUsersInput | HabitUpdateWithWhereUniqueWithoutJoinedUsersInput[]
    updateMany?: HabitUpdateManyWithWhereWithoutJoinedUsersInput | HabitUpdateManyWithWhereWithoutJoinedUsersInput[]
    deleteMany?: HabitScalarWhereInput | HabitScalarWhereInput[]
  }

  export type HabitProofUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HabitProofCreateWithoutUserInput, HabitProofUncheckedCreateWithoutUserInput> | HabitProofCreateWithoutUserInput[] | HabitProofUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitProofCreateOrConnectWithoutUserInput | HabitProofCreateOrConnectWithoutUserInput[]
    upsert?: HabitProofUpsertWithWhereUniqueWithoutUserInput | HabitProofUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HabitProofCreateManyUserInputEnvelope
    set?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    disconnect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    delete?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    connect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    update?: HabitProofUpdateWithWhereUniqueWithoutUserInput | HabitProofUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HabitProofUpdateManyWithWhereWithoutUserInput | HabitProofUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HabitProofScalarWhereInput | HabitProofScalarWhereInput[]
  }

  export type ProofVoteUncheckedUpdateManyWithoutVoterNestedInput = {
    create?: XOR<ProofVoteCreateWithoutVoterInput, ProofVoteUncheckedCreateWithoutVoterInput> | ProofVoteCreateWithoutVoterInput[] | ProofVoteUncheckedCreateWithoutVoterInput[]
    connectOrCreate?: ProofVoteCreateOrConnectWithoutVoterInput | ProofVoteCreateOrConnectWithoutVoterInput[]
    upsert?: ProofVoteUpsertWithWhereUniqueWithoutVoterInput | ProofVoteUpsertWithWhereUniqueWithoutVoterInput[]
    createMany?: ProofVoteCreateManyVoterInputEnvelope
    set?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    disconnect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    delete?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    connect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    update?: ProofVoteUpdateWithWhereUniqueWithoutVoterInput | ProofVoteUpdateWithWhereUniqueWithoutVoterInput[]
    updateMany?: ProofVoteUpdateManyWithWhereWithoutVoterInput | ProofVoteUpdateManyWithWhereWithoutVoterInput[]
    deleteMany?: ProofVoteScalarWhereInput | ProofVoteScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserInput | FriendshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserInput | FriendshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserInput | FriendshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutFriendNestedInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutFriendInput | FriendshipUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutFriendInput | FriendshipUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutFriendInput | FriendshipUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type HabitInviteUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<HabitInviteCreateWithoutInviterInput, HabitInviteUncheckedCreateWithoutInviterInput> | HabitInviteCreateWithoutInviterInput[] | HabitInviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: HabitInviteCreateOrConnectWithoutInviterInput | HabitInviteCreateOrConnectWithoutInviterInput[]
    upsert?: HabitInviteUpsertWithWhereUniqueWithoutInviterInput | HabitInviteUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: HabitInviteCreateManyInviterInputEnvelope
    set?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    disconnect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    delete?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    connect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    update?: HabitInviteUpdateWithWhereUniqueWithoutInviterInput | HabitInviteUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: HabitInviteUpdateManyWithWhereWithoutInviterInput | HabitInviteUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: HabitInviteScalarWhereInput | HabitInviteScalarWhereInput[]
  }

  export type HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HabitUserSettingsCreateWithoutUserInput, HabitUserSettingsUncheckedCreateWithoutUserInput> | HabitUserSettingsCreateWithoutUserInput[] | HabitUserSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HabitUserSettingsCreateOrConnectWithoutUserInput | HabitUserSettingsCreateOrConnectWithoutUserInput[]
    upsert?: HabitUserSettingsUpsertWithWhereUniqueWithoutUserInput | HabitUserSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HabitUserSettingsCreateManyUserInputEnvelope
    set?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    disconnect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    delete?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    connect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    update?: HabitUserSettingsUpdateWithWhereUniqueWithoutUserInput | HabitUserSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HabitUserSettingsUpdateManyWithWhereWithoutUserInput | HabitUserSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HabitUserSettingsScalarWhereInput | HabitUserSettingsScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInventoryInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    upsert?: UserUpsertWithoutInventoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryInput, UserUpdateWithoutInventoryInput>, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type ChallengeCreateNestedManyWithoutTeamInput = {
    create?: XOR<ChallengeCreateWithoutTeamInput, ChallengeUncheckedCreateWithoutTeamInput> | ChallengeCreateWithoutTeamInput[] | ChallengeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTeamInput | ChallengeCreateOrConnectWithoutTeamInput[]
    createMany?: ChallengeCreateManyTeamInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type ChallengeUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ChallengeCreateWithoutTeamInput, ChallengeUncheckedCreateWithoutTeamInput> | ChallengeCreateWithoutTeamInput[] | ChallengeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTeamInput | ChallengeCreateOrConnectWithoutTeamInput[]
    createMany?: ChallengeCreateManyTeamInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type ChallengeUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ChallengeCreateWithoutTeamInput, ChallengeUncheckedCreateWithoutTeamInput> | ChallengeCreateWithoutTeamInput[] | ChallengeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTeamInput | ChallengeCreateOrConnectWithoutTeamInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutTeamInput | ChallengeUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ChallengeCreateManyTeamInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutTeamInput | ChallengeUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutTeamInput | ChallengeUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type ChallengeUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ChallengeCreateWithoutTeamInput, ChallengeUncheckedCreateWithoutTeamInput> | ChallengeCreateWithoutTeamInput[] | ChallengeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutTeamInput | ChallengeCreateOrConnectWithoutTeamInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutTeamInput | ChallengeUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ChallengeCreateManyTeamInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutTeamInput | ChallengeUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutTeamInput | ChallengeUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTeamMembersInput = {
    create?: XOR<UserCreateWithoutTeamMembersInput, UserUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembersInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTeamMembersNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembersInput, UserUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembersInput
    upsert?: UserUpsertWithoutTeamMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembersInput, UserUpdateWithoutTeamMembersInput>, UserUncheckedUpdateWithoutTeamMembersInput>
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserCreateNestedOneWithoutCreatedChallengesInput = {
    create?: XOR<UserCreateWithoutCreatedChallengesInput, UserUncheckedCreateWithoutCreatedChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutChallengesInput = {
    create?: XOR<TeamCreateWithoutChallengesInput, TeamUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutChallengesInput
    connect?: TeamWhereUniqueInput
  }

  export type ChallengeParticipantCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type ProgressLogCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ProgressLogCreateWithoutChallengeInput, ProgressLogUncheckedCreateWithoutChallengeInput> | ProgressLogCreateWithoutChallengeInput[] | ProgressLogUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ProgressLogCreateOrConnectWithoutChallengeInput | ProgressLogCreateOrConnectWithoutChallengeInput[]
    createMany?: ProgressLogCreateManyChallengeInputEnvelope
    connect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
  }

  export type ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type ProgressLogUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ProgressLogCreateWithoutChallengeInput, ProgressLogUncheckedCreateWithoutChallengeInput> | ProgressLogCreateWithoutChallengeInput[] | ProgressLogUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ProgressLogCreateOrConnectWithoutChallengeInput | ProgressLogCreateOrConnectWithoutChallengeInput[]
    createMany?: ProgressLogCreateManyChallengeInputEnvelope
    connect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCreatedChallengesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedChallengesInput, UserUncheckedCreateWithoutCreatedChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedChallengesInput
    upsert?: UserUpsertWithoutCreatedChallengesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedChallengesInput, UserUpdateWithoutCreatedChallengesInput>, UserUncheckedUpdateWithoutCreatedChallengesInput>
  }

  export type TeamUpdateOneWithoutChallengesNestedInput = {
    create?: XOR<TeamCreateWithoutChallengesInput, TeamUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutChallengesInput
    upsert?: TeamUpsertWithoutChallengesInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutChallengesInput, TeamUpdateWithoutChallengesInput>, TeamUncheckedUpdateWithoutChallengesInput>
  }

  export type ChallengeParticipantUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput | ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type ProgressLogUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ProgressLogCreateWithoutChallengeInput, ProgressLogUncheckedCreateWithoutChallengeInput> | ProgressLogCreateWithoutChallengeInput[] | ProgressLogUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ProgressLogCreateOrConnectWithoutChallengeInput | ProgressLogCreateOrConnectWithoutChallengeInput[]
    upsert?: ProgressLogUpsertWithWhereUniqueWithoutChallengeInput | ProgressLogUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ProgressLogCreateManyChallengeInputEnvelope
    set?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    disconnect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    delete?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    connect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    update?: ProgressLogUpdateWithWhereUniqueWithoutChallengeInput | ProgressLogUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ProgressLogUpdateManyWithWhereWithoutChallengeInput | ProgressLogUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ProgressLogScalarWhereInput | ProgressLogScalarWhereInput[]
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput | ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type ProgressLogUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ProgressLogCreateWithoutChallengeInput, ProgressLogUncheckedCreateWithoutChallengeInput> | ProgressLogCreateWithoutChallengeInput[] | ProgressLogUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ProgressLogCreateOrConnectWithoutChallengeInput | ProgressLogCreateOrConnectWithoutChallengeInput[]
    upsert?: ProgressLogUpsertWithWhereUniqueWithoutChallengeInput | ProgressLogUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ProgressLogCreateManyChallengeInputEnvelope
    set?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    disconnect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    delete?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    connect?: ProgressLogWhereUniqueInput | ProgressLogWhereUniqueInput[]
    update?: ProgressLogUpdateWithWhereUniqueWithoutChallengeInput | ProgressLogUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ProgressLogUpdateManyWithWhereWithoutChallengeInput | ProgressLogUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ProgressLogScalarWhereInput | ProgressLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<UserCreateWithoutParticipationsInput, UserUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipationsInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ChallengeCreateWithoutParticipantsInput, ChallengeUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutParticipantsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<UserCreateWithoutParticipationsInput, UserUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipationsInput
    upsert?: UserUpsertWithoutParticipationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParticipationsInput, UserUpdateWithoutParticipationsInput>, UserUncheckedUpdateWithoutParticipationsInput>
  }

  export type ChallengeUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ChallengeCreateWithoutParticipantsInput, ChallengeUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutParticipantsInput
    upsert?: ChallengeUpsertWithoutParticipantsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutParticipantsInput, ChallengeUpdateWithoutParticipantsInput>, ChallengeUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserCreateNestedOneWithoutProgressLogsInput = {
    create?: XOR<UserCreateWithoutProgressLogsInput, UserUncheckedCreateWithoutProgressLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeCreateNestedOneWithoutProgressLogsInput = {
    create?: XOR<ChallengeCreateWithoutProgressLogsInput, ChallengeUncheckedCreateWithoutProgressLogsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutProgressLogsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProgressLogsNestedInput = {
    create?: XOR<UserCreateWithoutProgressLogsInput, UserUncheckedCreateWithoutProgressLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressLogsInput
    upsert?: UserUpsertWithoutProgressLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgressLogsInput, UserUpdateWithoutProgressLogsInput>, UserUncheckedUpdateWithoutProgressLogsInput>
  }

  export type ChallengeUpdateOneRequiredWithoutProgressLogsNestedInput = {
    create?: XOR<ChallengeCreateWithoutProgressLogsInput, ChallengeUncheckedCreateWithoutProgressLogsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutProgressLogsInput
    upsert?: ChallengeUpsertWithoutProgressLogsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutProgressLogsInput, ChallengeUpdateWithoutProgressLogsInput>, ChallengeUncheckedUpdateWithoutProgressLogsInput>
  }

  export type UserBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBadgesInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutUsersInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    connect?: BadgeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    upsert?: UserUpsertWithoutBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBadgesInput, UserUpdateWithoutBadgesInput>, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    upsert?: BadgeUpsertWithoutUsersInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutUsersInput, BadgeUpdateWithoutUsersInput>, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type HabitCreateNestedManyWithoutCategoryInput = {
    create?: XOR<HabitCreateWithoutCategoryInput, HabitUncheckedCreateWithoutCategoryInput> | HabitCreateWithoutCategoryInput[] | HabitUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutCategoryInput | HabitCreateOrConnectWithoutCategoryInput[]
    createMany?: HabitCreateManyCategoryInputEnvelope
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCurrentMountainInput = {
    create?: XOR<UserCreateWithoutCurrentMountainInput, UserUncheckedCreateWithoutCurrentMountainInput> | UserCreateWithoutCurrentMountainInput[] | UserUncheckedCreateWithoutCurrentMountainInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCurrentMountainInput | UserCreateOrConnectWithoutCurrentMountainInput[]
    createMany?: UserCreateManyCurrentMountainInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HabitUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<HabitCreateWithoutCategoryInput, HabitUncheckedCreateWithoutCategoryInput> | HabitCreateWithoutCategoryInput[] | HabitUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutCategoryInput | HabitCreateOrConnectWithoutCategoryInput[]
    createMany?: HabitCreateManyCategoryInputEnvelope
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCurrentMountainInput = {
    create?: XOR<UserCreateWithoutCurrentMountainInput, UserUncheckedCreateWithoutCurrentMountainInput> | UserCreateWithoutCurrentMountainInput[] | UserUncheckedCreateWithoutCurrentMountainInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCurrentMountainInput | UserCreateOrConnectWithoutCurrentMountainInput[]
    createMany?: UserCreateManyCurrentMountainInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HabitUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<HabitCreateWithoutCategoryInput, HabitUncheckedCreateWithoutCategoryInput> | HabitCreateWithoutCategoryInput[] | HabitUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutCategoryInput | HabitCreateOrConnectWithoutCategoryInput[]
    upsert?: HabitUpsertWithWhereUniqueWithoutCategoryInput | HabitUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: HabitCreateManyCategoryInputEnvelope
    set?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    disconnect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    delete?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    update?: HabitUpdateWithWhereUniqueWithoutCategoryInput | HabitUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: HabitUpdateManyWithWhereWithoutCategoryInput | HabitUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: HabitScalarWhereInput | HabitScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCurrentMountainNestedInput = {
    create?: XOR<UserCreateWithoutCurrentMountainInput, UserUncheckedCreateWithoutCurrentMountainInput> | UserCreateWithoutCurrentMountainInput[] | UserUncheckedCreateWithoutCurrentMountainInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCurrentMountainInput | UserCreateOrConnectWithoutCurrentMountainInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCurrentMountainInput | UserUpsertWithWhereUniqueWithoutCurrentMountainInput[]
    createMany?: UserCreateManyCurrentMountainInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCurrentMountainInput | UserUpdateWithWhereUniqueWithoutCurrentMountainInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCurrentMountainInput | UserUpdateManyWithWhereWithoutCurrentMountainInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HabitUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<HabitCreateWithoutCategoryInput, HabitUncheckedCreateWithoutCategoryInput> | HabitCreateWithoutCategoryInput[] | HabitUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: HabitCreateOrConnectWithoutCategoryInput | HabitCreateOrConnectWithoutCategoryInput[]
    upsert?: HabitUpsertWithWhereUniqueWithoutCategoryInput | HabitUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: HabitCreateManyCategoryInputEnvelope
    set?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    disconnect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    delete?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    connect?: HabitWhereUniqueInput | HabitWhereUniqueInput[]
    update?: HabitUpdateWithWhereUniqueWithoutCategoryInput | HabitUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: HabitUpdateManyWithWhereWithoutCategoryInput | HabitUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: HabitScalarWhereInput | HabitScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCurrentMountainNestedInput = {
    create?: XOR<UserCreateWithoutCurrentMountainInput, UserUncheckedCreateWithoutCurrentMountainInput> | UserCreateWithoutCurrentMountainInput[] | UserUncheckedCreateWithoutCurrentMountainInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCurrentMountainInput | UserCreateOrConnectWithoutCurrentMountainInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCurrentMountainInput | UserUpsertWithWhereUniqueWithoutCurrentMountainInput[]
    createMany?: UserCreateManyCurrentMountainInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCurrentMountainInput | UserUpdateWithWhereUniqueWithoutCurrentMountainInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCurrentMountainInput | UserUpdateManyWithWhereWithoutCurrentMountainInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HabitCategoryCreateNestedOneWithoutHabitsInput = {
    create?: XOR<HabitCategoryCreateWithoutHabitsInput, HabitCategoryUncheckedCreateWithoutHabitsInput>
    connectOrCreate?: HabitCategoryCreateOrConnectWithoutHabitsInput
    connect?: HabitCategoryWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutJoinedHabitsInput = {
    create?: XOR<UserCreateWithoutJoinedHabitsInput, UserUncheckedCreateWithoutJoinedHabitsInput> | UserCreateWithoutJoinedHabitsInput[] | UserUncheckedCreateWithoutJoinedHabitsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutJoinedHabitsInput | UserCreateOrConnectWithoutJoinedHabitsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HabitProofCreateNestedManyWithoutHabitInput = {
    create?: XOR<HabitProofCreateWithoutHabitInput, HabitProofUncheckedCreateWithoutHabitInput> | HabitProofCreateWithoutHabitInput[] | HabitProofUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitProofCreateOrConnectWithoutHabitInput | HabitProofCreateOrConnectWithoutHabitInput[]
    createMany?: HabitProofCreateManyHabitInputEnvelope
    connect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
  }

  export type HabitInviteCreateNestedManyWithoutHabitInput = {
    create?: XOR<HabitInviteCreateWithoutHabitInput, HabitInviteUncheckedCreateWithoutHabitInput> | HabitInviteCreateWithoutHabitInput[] | HabitInviteUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitInviteCreateOrConnectWithoutHabitInput | HabitInviteCreateOrConnectWithoutHabitInput[]
    createMany?: HabitInviteCreateManyHabitInputEnvelope
    connect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
  }

  export type HabitUserSettingsCreateNestedManyWithoutHabitInput = {
    create?: XOR<HabitUserSettingsCreateWithoutHabitInput, HabitUserSettingsUncheckedCreateWithoutHabitInput> | HabitUserSettingsCreateWithoutHabitInput[] | HabitUserSettingsUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitUserSettingsCreateOrConnectWithoutHabitInput | HabitUserSettingsCreateOrConnectWithoutHabitInput[]
    createMany?: HabitUserSettingsCreateManyHabitInputEnvelope
    connect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutJoinedHabitsInput = {
    create?: XOR<UserCreateWithoutJoinedHabitsInput, UserUncheckedCreateWithoutJoinedHabitsInput> | UserCreateWithoutJoinedHabitsInput[] | UserUncheckedCreateWithoutJoinedHabitsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutJoinedHabitsInput | UserCreateOrConnectWithoutJoinedHabitsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HabitProofUncheckedCreateNestedManyWithoutHabitInput = {
    create?: XOR<HabitProofCreateWithoutHabitInput, HabitProofUncheckedCreateWithoutHabitInput> | HabitProofCreateWithoutHabitInput[] | HabitProofUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitProofCreateOrConnectWithoutHabitInput | HabitProofCreateOrConnectWithoutHabitInput[]
    createMany?: HabitProofCreateManyHabitInputEnvelope
    connect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
  }

  export type HabitInviteUncheckedCreateNestedManyWithoutHabitInput = {
    create?: XOR<HabitInviteCreateWithoutHabitInput, HabitInviteUncheckedCreateWithoutHabitInput> | HabitInviteCreateWithoutHabitInput[] | HabitInviteUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitInviteCreateOrConnectWithoutHabitInput | HabitInviteCreateOrConnectWithoutHabitInput[]
    createMany?: HabitInviteCreateManyHabitInputEnvelope
    connect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
  }

  export type HabitUserSettingsUncheckedCreateNestedManyWithoutHabitInput = {
    create?: XOR<HabitUserSettingsCreateWithoutHabitInput, HabitUserSettingsUncheckedCreateWithoutHabitInput> | HabitUserSettingsCreateWithoutHabitInput[] | HabitUserSettingsUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitUserSettingsCreateOrConnectWithoutHabitInput | HabitUserSettingsCreateOrConnectWithoutHabitInput[]
    createMany?: HabitUserSettingsCreateManyHabitInputEnvelope
    connect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
  }

  export type HabitCategoryUpdateOneRequiredWithoutHabitsNestedInput = {
    create?: XOR<HabitCategoryCreateWithoutHabitsInput, HabitCategoryUncheckedCreateWithoutHabitsInput>
    connectOrCreate?: HabitCategoryCreateOrConnectWithoutHabitsInput
    upsert?: HabitCategoryUpsertWithoutHabitsInput
    connect?: HabitCategoryWhereUniqueInput
    update?: XOR<XOR<HabitCategoryUpdateToOneWithWhereWithoutHabitsInput, HabitCategoryUpdateWithoutHabitsInput>, HabitCategoryUncheckedUpdateWithoutHabitsInput>
  }

  export type UserUpdateManyWithoutJoinedHabitsNestedInput = {
    create?: XOR<UserCreateWithoutJoinedHabitsInput, UserUncheckedCreateWithoutJoinedHabitsInput> | UserCreateWithoutJoinedHabitsInput[] | UserUncheckedCreateWithoutJoinedHabitsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutJoinedHabitsInput | UserCreateOrConnectWithoutJoinedHabitsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutJoinedHabitsInput | UserUpsertWithWhereUniqueWithoutJoinedHabitsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutJoinedHabitsInput | UserUpdateWithWhereUniqueWithoutJoinedHabitsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutJoinedHabitsInput | UserUpdateManyWithWhereWithoutJoinedHabitsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HabitProofUpdateManyWithoutHabitNestedInput = {
    create?: XOR<HabitProofCreateWithoutHabitInput, HabitProofUncheckedCreateWithoutHabitInput> | HabitProofCreateWithoutHabitInput[] | HabitProofUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitProofCreateOrConnectWithoutHabitInput | HabitProofCreateOrConnectWithoutHabitInput[]
    upsert?: HabitProofUpsertWithWhereUniqueWithoutHabitInput | HabitProofUpsertWithWhereUniqueWithoutHabitInput[]
    createMany?: HabitProofCreateManyHabitInputEnvelope
    set?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    disconnect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    delete?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    connect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    update?: HabitProofUpdateWithWhereUniqueWithoutHabitInput | HabitProofUpdateWithWhereUniqueWithoutHabitInput[]
    updateMany?: HabitProofUpdateManyWithWhereWithoutHabitInput | HabitProofUpdateManyWithWhereWithoutHabitInput[]
    deleteMany?: HabitProofScalarWhereInput | HabitProofScalarWhereInput[]
  }

  export type HabitInviteUpdateManyWithoutHabitNestedInput = {
    create?: XOR<HabitInviteCreateWithoutHabitInput, HabitInviteUncheckedCreateWithoutHabitInput> | HabitInviteCreateWithoutHabitInput[] | HabitInviteUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitInviteCreateOrConnectWithoutHabitInput | HabitInviteCreateOrConnectWithoutHabitInput[]
    upsert?: HabitInviteUpsertWithWhereUniqueWithoutHabitInput | HabitInviteUpsertWithWhereUniqueWithoutHabitInput[]
    createMany?: HabitInviteCreateManyHabitInputEnvelope
    set?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    disconnect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    delete?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    connect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    update?: HabitInviteUpdateWithWhereUniqueWithoutHabitInput | HabitInviteUpdateWithWhereUniqueWithoutHabitInput[]
    updateMany?: HabitInviteUpdateManyWithWhereWithoutHabitInput | HabitInviteUpdateManyWithWhereWithoutHabitInput[]
    deleteMany?: HabitInviteScalarWhereInput | HabitInviteScalarWhereInput[]
  }

  export type HabitUserSettingsUpdateManyWithoutHabitNestedInput = {
    create?: XOR<HabitUserSettingsCreateWithoutHabitInput, HabitUserSettingsUncheckedCreateWithoutHabitInput> | HabitUserSettingsCreateWithoutHabitInput[] | HabitUserSettingsUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitUserSettingsCreateOrConnectWithoutHabitInput | HabitUserSettingsCreateOrConnectWithoutHabitInput[]
    upsert?: HabitUserSettingsUpsertWithWhereUniqueWithoutHabitInput | HabitUserSettingsUpsertWithWhereUniqueWithoutHabitInput[]
    createMany?: HabitUserSettingsCreateManyHabitInputEnvelope
    set?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    disconnect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    delete?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    connect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    update?: HabitUserSettingsUpdateWithWhereUniqueWithoutHabitInput | HabitUserSettingsUpdateWithWhereUniqueWithoutHabitInput[]
    updateMany?: HabitUserSettingsUpdateManyWithWhereWithoutHabitInput | HabitUserSettingsUpdateManyWithWhereWithoutHabitInput[]
    deleteMany?: HabitUserSettingsScalarWhereInput | HabitUserSettingsScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutJoinedHabitsNestedInput = {
    create?: XOR<UserCreateWithoutJoinedHabitsInput, UserUncheckedCreateWithoutJoinedHabitsInput> | UserCreateWithoutJoinedHabitsInput[] | UserUncheckedCreateWithoutJoinedHabitsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutJoinedHabitsInput | UserCreateOrConnectWithoutJoinedHabitsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutJoinedHabitsInput | UserUpsertWithWhereUniqueWithoutJoinedHabitsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutJoinedHabitsInput | UserUpdateWithWhereUniqueWithoutJoinedHabitsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutJoinedHabitsInput | UserUpdateManyWithWhereWithoutJoinedHabitsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HabitProofUncheckedUpdateManyWithoutHabitNestedInput = {
    create?: XOR<HabitProofCreateWithoutHabitInput, HabitProofUncheckedCreateWithoutHabitInput> | HabitProofCreateWithoutHabitInput[] | HabitProofUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitProofCreateOrConnectWithoutHabitInput | HabitProofCreateOrConnectWithoutHabitInput[]
    upsert?: HabitProofUpsertWithWhereUniqueWithoutHabitInput | HabitProofUpsertWithWhereUniqueWithoutHabitInput[]
    createMany?: HabitProofCreateManyHabitInputEnvelope
    set?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    disconnect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    delete?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    connect?: HabitProofWhereUniqueInput | HabitProofWhereUniqueInput[]
    update?: HabitProofUpdateWithWhereUniqueWithoutHabitInput | HabitProofUpdateWithWhereUniqueWithoutHabitInput[]
    updateMany?: HabitProofUpdateManyWithWhereWithoutHabitInput | HabitProofUpdateManyWithWhereWithoutHabitInput[]
    deleteMany?: HabitProofScalarWhereInput | HabitProofScalarWhereInput[]
  }

  export type HabitInviteUncheckedUpdateManyWithoutHabitNestedInput = {
    create?: XOR<HabitInviteCreateWithoutHabitInput, HabitInviteUncheckedCreateWithoutHabitInput> | HabitInviteCreateWithoutHabitInput[] | HabitInviteUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitInviteCreateOrConnectWithoutHabitInput | HabitInviteCreateOrConnectWithoutHabitInput[]
    upsert?: HabitInviteUpsertWithWhereUniqueWithoutHabitInput | HabitInviteUpsertWithWhereUniqueWithoutHabitInput[]
    createMany?: HabitInviteCreateManyHabitInputEnvelope
    set?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    disconnect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    delete?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    connect?: HabitInviteWhereUniqueInput | HabitInviteWhereUniqueInput[]
    update?: HabitInviteUpdateWithWhereUniqueWithoutHabitInput | HabitInviteUpdateWithWhereUniqueWithoutHabitInput[]
    updateMany?: HabitInviteUpdateManyWithWhereWithoutHabitInput | HabitInviteUpdateManyWithWhereWithoutHabitInput[]
    deleteMany?: HabitInviteScalarWhereInput | HabitInviteScalarWhereInput[]
  }

  export type HabitUserSettingsUncheckedUpdateManyWithoutHabitNestedInput = {
    create?: XOR<HabitUserSettingsCreateWithoutHabitInput, HabitUserSettingsUncheckedCreateWithoutHabitInput> | HabitUserSettingsCreateWithoutHabitInput[] | HabitUserSettingsUncheckedCreateWithoutHabitInput[]
    connectOrCreate?: HabitUserSettingsCreateOrConnectWithoutHabitInput | HabitUserSettingsCreateOrConnectWithoutHabitInput[]
    upsert?: HabitUserSettingsUpsertWithWhereUniqueWithoutHabitInput | HabitUserSettingsUpsertWithWhereUniqueWithoutHabitInput[]
    createMany?: HabitUserSettingsCreateManyHabitInputEnvelope
    set?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    disconnect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    delete?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    connect?: HabitUserSettingsWhereUniqueInput | HabitUserSettingsWhereUniqueInput[]
    update?: HabitUserSettingsUpdateWithWhereUniqueWithoutHabitInput | HabitUserSettingsUpdateWithWhereUniqueWithoutHabitInput[]
    updateMany?: HabitUserSettingsUpdateManyWithWhereWithoutHabitInput | HabitUserSettingsUpdateManyWithWhereWithoutHabitInput[]
    deleteMany?: HabitUserSettingsScalarWhereInput | HabitUserSettingsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHabitSettingsInput = {
    create?: XOR<UserCreateWithoutHabitSettingsInput, UserUncheckedCreateWithoutHabitSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHabitSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type HabitCreateNestedOneWithoutUserSettingsInput = {
    create?: XOR<HabitCreateWithoutUserSettingsInput, HabitUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: HabitCreateOrConnectWithoutUserSettingsInput
    connect?: HabitWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutHabitSettingsNestedInput = {
    create?: XOR<UserCreateWithoutHabitSettingsInput, UserUncheckedCreateWithoutHabitSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHabitSettingsInput
    upsert?: UserUpsertWithoutHabitSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHabitSettingsInput, UserUpdateWithoutHabitSettingsInput>, UserUncheckedUpdateWithoutHabitSettingsInput>
  }

  export type HabitUpdateOneRequiredWithoutUserSettingsNestedInput = {
    create?: XOR<HabitCreateWithoutUserSettingsInput, HabitUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: HabitCreateOrConnectWithoutUserSettingsInput
    upsert?: HabitUpsertWithoutUserSettingsInput
    connect?: HabitWhereUniqueInput
    update?: XOR<XOR<HabitUpdateToOneWithWhereWithoutUserSettingsInput, HabitUpdateWithoutUserSettingsInput>, HabitUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserCreateNestedOneWithoutHabitProofsInput = {
    create?: XOR<UserCreateWithoutHabitProofsInput, UserUncheckedCreateWithoutHabitProofsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHabitProofsInput
    connect?: UserWhereUniqueInput
  }

  export type HabitCreateNestedOneWithoutProofsInput = {
    create?: XOR<HabitCreateWithoutProofsInput, HabitUncheckedCreateWithoutProofsInput>
    connectOrCreate?: HabitCreateOrConnectWithoutProofsInput
    connect?: HabitWhereUniqueInput
  }

  export type ProofVoteCreateNestedManyWithoutProofInput = {
    create?: XOR<ProofVoteCreateWithoutProofInput, ProofVoteUncheckedCreateWithoutProofInput> | ProofVoteCreateWithoutProofInput[] | ProofVoteUncheckedCreateWithoutProofInput[]
    connectOrCreate?: ProofVoteCreateOrConnectWithoutProofInput | ProofVoteCreateOrConnectWithoutProofInput[]
    createMany?: ProofVoteCreateManyProofInputEnvelope
    connect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
  }

  export type ProofVoteUncheckedCreateNestedManyWithoutProofInput = {
    create?: XOR<ProofVoteCreateWithoutProofInput, ProofVoteUncheckedCreateWithoutProofInput> | ProofVoteCreateWithoutProofInput[] | ProofVoteUncheckedCreateWithoutProofInput[]
    connectOrCreate?: ProofVoteCreateOrConnectWithoutProofInput | ProofVoteCreateOrConnectWithoutProofInput[]
    createMany?: ProofVoteCreateManyProofInputEnvelope
    connect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutHabitProofsNestedInput = {
    create?: XOR<UserCreateWithoutHabitProofsInput, UserUncheckedCreateWithoutHabitProofsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHabitProofsInput
    upsert?: UserUpsertWithoutHabitProofsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHabitProofsInput, UserUpdateWithoutHabitProofsInput>, UserUncheckedUpdateWithoutHabitProofsInput>
  }

  export type HabitUpdateOneRequiredWithoutProofsNestedInput = {
    create?: XOR<HabitCreateWithoutProofsInput, HabitUncheckedCreateWithoutProofsInput>
    connectOrCreate?: HabitCreateOrConnectWithoutProofsInput
    upsert?: HabitUpsertWithoutProofsInput
    connect?: HabitWhereUniqueInput
    update?: XOR<XOR<HabitUpdateToOneWithWhereWithoutProofsInput, HabitUpdateWithoutProofsInput>, HabitUncheckedUpdateWithoutProofsInput>
  }

  export type ProofVoteUpdateManyWithoutProofNestedInput = {
    create?: XOR<ProofVoteCreateWithoutProofInput, ProofVoteUncheckedCreateWithoutProofInput> | ProofVoteCreateWithoutProofInput[] | ProofVoteUncheckedCreateWithoutProofInput[]
    connectOrCreate?: ProofVoteCreateOrConnectWithoutProofInput | ProofVoteCreateOrConnectWithoutProofInput[]
    upsert?: ProofVoteUpsertWithWhereUniqueWithoutProofInput | ProofVoteUpsertWithWhereUniqueWithoutProofInput[]
    createMany?: ProofVoteCreateManyProofInputEnvelope
    set?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    disconnect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    delete?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    connect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    update?: ProofVoteUpdateWithWhereUniqueWithoutProofInput | ProofVoteUpdateWithWhereUniqueWithoutProofInput[]
    updateMany?: ProofVoteUpdateManyWithWhereWithoutProofInput | ProofVoteUpdateManyWithWhereWithoutProofInput[]
    deleteMany?: ProofVoteScalarWhereInput | ProofVoteScalarWhereInput[]
  }

  export type ProofVoteUncheckedUpdateManyWithoutProofNestedInput = {
    create?: XOR<ProofVoteCreateWithoutProofInput, ProofVoteUncheckedCreateWithoutProofInput> | ProofVoteCreateWithoutProofInput[] | ProofVoteUncheckedCreateWithoutProofInput[]
    connectOrCreate?: ProofVoteCreateOrConnectWithoutProofInput | ProofVoteCreateOrConnectWithoutProofInput[]
    upsert?: ProofVoteUpsertWithWhereUniqueWithoutProofInput | ProofVoteUpsertWithWhereUniqueWithoutProofInput[]
    createMany?: ProofVoteCreateManyProofInputEnvelope
    set?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    disconnect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    delete?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    connect?: ProofVoteWhereUniqueInput | ProofVoteWhereUniqueInput[]
    update?: ProofVoteUpdateWithWhereUniqueWithoutProofInput | ProofVoteUpdateWithWhereUniqueWithoutProofInput[]
    updateMany?: ProofVoteUpdateManyWithWhereWithoutProofInput | ProofVoteUpdateManyWithWhereWithoutProofInput[]
    deleteMany?: ProofVoteScalarWhereInput | ProofVoteScalarWhereInput[]
  }

  export type HabitProofCreateNestedOneWithoutVotesInput = {
    create?: XOR<HabitProofCreateWithoutVotesInput, HabitProofUncheckedCreateWithoutVotesInput>
    connectOrCreate?: HabitProofCreateOrConnectWithoutVotesInput
    connect?: HabitProofWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProofVotesInput = {
    create?: XOR<UserCreateWithoutProofVotesInput, UserUncheckedCreateWithoutProofVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProofVotesInput
    connect?: UserWhereUniqueInput
  }

  export type HabitProofUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<HabitProofCreateWithoutVotesInput, HabitProofUncheckedCreateWithoutVotesInput>
    connectOrCreate?: HabitProofCreateOrConnectWithoutVotesInput
    upsert?: HabitProofUpsertWithoutVotesInput
    connect?: HabitProofWhereUniqueInput
    update?: XOR<XOR<HabitProofUpdateToOneWithWhereWithoutVotesInput, HabitProofUpdateWithoutVotesInput>, HabitProofUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutProofVotesNestedInput = {
    create?: XOR<UserCreateWithoutProofVotesInput, UserUncheckedCreateWithoutProofVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProofVotesInput
    upsert?: UserUpsertWithoutProofVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProofVotesInput, UserUpdateWithoutProofVotesInput>, UserUncheckedUpdateWithoutProofVotesInput>
  }

  export type UserCreateNestedOneWithoutFriendsInput = {
    create?: XOR<UserCreateWithoutFriendsInput, UserUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFriendOfInput = {
    create?: XOR<UserCreateWithoutFriendOfInput, UserUncheckedCreateWithoutFriendOfInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendOfInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFriendsNestedInput = {
    create?: XOR<UserCreateWithoutFriendsInput, UserUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendsInput
    upsert?: UserUpsertWithoutFriendsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendsInput, UserUpdateWithoutFriendsInput>, UserUncheckedUpdateWithoutFriendsInput>
  }

  export type UserUpdateOneRequiredWithoutFriendOfNestedInput = {
    create?: XOR<UserCreateWithoutFriendOfInput, UserUncheckedCreateWithoutFriendOfInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendOfInput
    upsert?: UserUpsertWithoutFriendOfInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendOfInput, UserUpdateWithoutFriendOfInput>, UserUncheckedUpdateWithoutFriendOfInput>
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type HabitCreateNestedOneWithoutInvitesInput = {
    create?: XOR<HabitCreateWithoutInvitesInput, HabitUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: HabitCreateOrConnectWithoutInvitesInput
    connect?: HabitWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHabitInvitesInput = {
    create?: XOR<UserCreateWithoutHabitInvitesInput, UserUncheckedCreateWithoutHabitInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHabitInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type HabitUpdateOneWithoutInvitesNestedInput = {
    create?: XOR<HabitCreateWithoutInvitesInput, HabitUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: HabitCreateOrConnectWithoutInvitesInput
    upsert?: HabitUpsertWithoutInvitesInput
    disconnect?: HabitWhereInput | boolean
    delete?: HabitWhereInput | boolean
    connect?: HabitWhereUniqueInput
    update?: XOR<XOR<HabitUpdateToOneWithWhereWithoutInvitesInput, HabitUpdateWithoutInvitesInput>, HabitUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateOneRequiredWithoutHabitInvitesNestedInput = {
    create?: XOR<UserCreateWithoutHabitInvitesInput, UserUncheckedCreateWithoutHabitInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHabitInvitesInput
    upsert?: UserUpsertWithoutHabitInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHabitInvitesInput, UserUpdateWithoutHabitInvitesInput>, UserUncheckedUpdateWithoutHabitInvitesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type HabitCategoryCreateWithoutActiveClimbersInput = {
    id?: string
    name: string
    biomeType: string
    mountainIcon: string
    mountainImage?: string | null
    primaryColor: string
    secondaryColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitCreateNestedManyWithoutCategoryInput
  }

  export type HabitCategoryUncheckedCreateWithoutActiveClimbersInput = {
    id?: string
    name: string
    biomeType: string
    mountainIcon: string
    mountainImage?: string | null
    primaryColor: string
    secondaryColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    habits?: HabitUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type HabitCategoryCreateOrConnectWithoutActiveClimbersInput = {
    where: HabitCategoryWhereUniqueInput
    create: XOR<HabitCategoryCreateWithoutActiveClimbersInput, HabitCategoryUncheckedCreateWithoutActiveClimbersInput>
  }

  export type UserInventoryItemCreateWithoutUserInput = {
    id?: string
    itemId: string
  }

  export type UserInventoryItemUncheckedCreateWithoutUserInput = {
    id?: string
    itemId: string
  }

  export type UserInventoryItemCreateOrConnectWithoutUserInput = {
    where: UserInventoryItemWhereUniqueInput
    create: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput>
  }

  export type UserInventoryItemCreateManyUserInputEnvelope = {
    data: UserInventoryItemCreateManyUserInput | UserInventoryItemCreateManyUserInput[]
  }

  export type TeamMemberCreateWithoutUserInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    role?: string
    joinedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
  }

  export type ChallengeParticipantCreateWithoutUserInput = {
    id?: string
    currentValue?: number
    heartsLeft?: number | null
    isEliminated?: boolean
    relayOrder?: number | null
    relayCompleted?: boolean
    joinedAt?: Date | string
    challenge: ChallengeCreateNestedOneWithoutParticipantsInput
  }

  export type ChallengeParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    challengeId: string
    currentValue?: number
    heartsLeft?: number | null
    isEliminated?: boolean
    relayOrder?: number | null
    relayCompleted?: boolean
    joinedAt?: Date | string
  }

  export type ChallengeParticipantCreateOrConnectWithoutUserInput = {
    where: ChallengeParticipantWhereUniqueInput
    create: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput>
  }

  export type ChallengeParticipantCreateManyUserInputEnvelope = {
    data: ChallengeParticipantCreateManyUserInput | ChallengeParticipantCreateManyUserInput[]
  }

  export type ProgressLogCreateWithoutUserInput = {
    id?: string
    value: number
    isSuccess?: boolean
    note?: string | null
    date?: Date | string
    createdAt?: Date | string
    challenge: ChallengeCreateNestedOneWithoutProgressLogsInput
  }

  export type ProgressLogUncheckedCreateWithoutUserInput = {
    id?: string
    challengeId: string
    value: number
    isSuccess?: boolean
    note?: string | null
    date?: Date | string
    createdAt?: Date | string
  }

  export type ProgressLogCreateOrConnectWithoutUserInput = {
    where: ProgressLogWhereUniqueInput
    create: XOR<ProgressLogCreateWithoutUserInput, ProgressLogUncheckedCreateWithoutUserInput>
  }

  export type ProgressLogCreateManyUserInputEnvelope = {
    data: ProgressLogCreateManyUserInput | ProgressLogCreateManyUserInput[]
  }

  export type UserBadgeCreateWithoutUserInput = {
    id?: string
    earnedAt?: Date | string
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateWithoutUserInput = {
    id?: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeCreateManyUserInputEnvelope = {
    data: UserBadgeCreateManyUserInput | UserBadgeCreateManyUserInput[]
  }

  export type ChallengeCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutChallengesInput
    participants?: ChallengeParticipantCreateNestedManyWithoutChallengeInput
    progressLogs?: ProgressLogCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    teamId?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutCreatorInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput>
  }

  export type ChallengeCreateManyCreatorInputEnvelope = {
    data: ChallengeCreateManyCreatorInput | ChallengeCreateManyCreatorInput[]
  }

  export type HabitCreateWithoutJoinedUsersInput = {
    id?: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: HabitCategoryCreateNestedOneWithoutHabitsInput
    proofs?: HabitProofCreateNestedManyWithoutHabitInput
    invites?: HabitInviteCreateNestedManyWithoutHabitInput
    userSettings?: HabitUserSettingsCreateNestedManyWithoutHabitInput
  }

  export type HabitUncheckedCreateWithoutJoinedUsersInput = {
    id?: string
    categoryId: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proofs?: HabitProofUncheckedCreateNestedManyWithoutHabitInput
    invites?: HabitInviteUncheckedCreateNestedManyWithoutHabitInput
    userSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutHabitInput
  }

  export type HabitCreateOrConnectWithoutJoinedUsersInput = {
    where: HabitWhereUniqueInput
    create: XOR<HabitCreateWithoutJoinedUsersInput, HabitUncheckedCreateWithoutJoinedUsersInput>
  }

  export type HabitProofCreateWithoutUserInput = {
    id?: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    habit: HabitCreateNestedOneWithoutProofsInput
    votes?: ProofVoteCreateNestedManyWithoutProofInput
  }

  export type HabitProofUncheckedCreateWithoutUserInput = {
    id?: string
    habitId: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ProofVoteUncheckedCreateNestedManyWithoutProofInput
  }

  export type HabitProofCreateOrConnectWithoutUserInput = {
    where: HabitProofWhereUniqueInput
    create: XOR<HabitProofCreateWithoutUserInput, HabitProofUncheckedCreateWithoutUserInput>
  }

  export type HabitProofCreateManyUserInputEnvelope = {
    data: HabitProofCreateManyUserInput | HabitProofCreateManyUserInput[]
  }

  export type ProofVoteCreateWithoutVoterInput = {
    id?: string
    voteType: string
    createdAt?: Date | string
    proof: HabitProofCreateNestedOneWithoutVotesInput
  }

  export type ProofVoteUncheckedCreateWithoutVoterInput = {
    id?: string
    proofId: string
    voteType: string
    createdAt?: Date | string
  }

  export type ProofVoteCreateOrConnectWithoutVoterInput = {
    where: ProofVoteWhereUniqueInput
    create: XOR<ProofVoteCreateWithoutVoterInput, ProofVoteUncheckedCreateWithoutVoterInput>
  }

  export type ProofVoteCreateManyVoterInputEnvelope = {
    data: ProofVoteCreateManyVoterInput | ProofVoteCreateManyVoterInput[]
  }

  export type FriendshipCreateWithoutUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    friend: UserCreateNestedOneWithoutFriendOfInput
  }

  export type FriendshipUncheckedCreateWithoutUserInput = {
    id?: string
    friendId: string
    status?: string
    createdAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutUserInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput>
  }

  export type FriendshipCreateManyUserInputEnvelope = {
    data: FriendshipCreateManyUserInput | FriendshipCreateManyUserInput[]
  }

  export type FriendshipCreateWithoutFriendInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFriendsInput
  }

  export type FriendshipUncheckedCreateWithoutFriendInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutFriendInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput>
  }

  export type FriendshipCreateManyFriendInputEnvelope = {
    data: FriendshipCreateManyFriendInput | FriendshipCreateManyFriendInput[]
  }

  export type HabitInviteCreateWithoutInviterInput = {
    id?: string
    code: string
    inviteePhone?: string | null
    expiresAt: Date | string
    usedById?: string | null
    createdAt?: Date | string
    habit?: HabitCreateNestedOneWithoutInvitesInput
  }

  export type HabitInviteUncheckedCreateWithoutInviterInput = {
    id?: string
    code: string
    habitId?: string | null
    inviteePhone?: string | null
    expiresAt: Date | string
    usedById?: string | null
    createdAt?: Date | string
  }

  export type HabitInviteCreateOrConnectWithoutInviterInput = {
    where: HabitInviteWhereUniqueInput
    create: XOR<HabitInviteCreateWithoutInviterInput, HabitInviteUncheckedCreateWithoutInviterInput>
  }

  export type HabitInviteCreateManyInviterInputEnvelope = {
    data: HabitInviteCreateManyInviterInput | HabitInviteCreateManyInviterInput[]
  }

  export type HabitUserSettingsCreateWithoutUserInput = {
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    habit: HabitCreateNestedOneWithoutUserSettingsInput
  }

  export type HabitUserSettingsUncheckedCreateWithoutUserInput = {
    habitId: string
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUserSettingsCreateOrConnectWithoutUserInput = {
    where: HabitUserSettingsWhereUniqueInput
    create: XOR<HabitUserSettingsCreateWithoutUserInput, HabitUserSettingsUncheckedCreateWithoutUserInput>
  }

  export type HabitUserSettingsCreateManyUserInputEnvelope = {
    data: HabitUserSettingsCreateManyUserInput | HabitUserSettingsCreateManyUserInput[]
  }

  export type FollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
  }

  export type FollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    following: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
  }

  export type HabitCategoryUpsertWithoutActiveClimbersInput = {
    update: XOR<HabitCategoryUpdateWithoutActiveClimbersInput, HabitCategoryUncheckedUpdateWithoutActiveClimbersInput>
    create: XOR<HabitCategoryCreateWithoutActiveClimbersInput, HabitCategoryUncheckedCreateWithoutActiveClimbersInput>
    where?: HabitCategoryWhereInput
  }

  export type HabitCategoryUpdateToOneWithWhereWithoutActiveClimbersInput = {
    where?: HabitCategoryWhereInput
    data: XOR<HabitCategoryUpdateWithoutActiveClimbersInput, HabitCategoryUncheckedUpdateWithoutActiveClimbersInput>
  }

  export type HabitCategoryUpdateWithoutActiveClimbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biomeType?: StringFieldUpdateOperationsInput | string
    mountainIcon?: StringFieldUpdateOperationsInput | string
    mountainImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUpdateManyWithoutCategoryNestedInput
  }

  export type HabitCategoryUncheckedUpdateWithoutActiveClimbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biomeType?: StringFieldUpdateOperationsInput | string
    mountainIcon?: StringFieldUpdateOperationsInput | string
    mountainImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habits?: HabitUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserInventoryItemUpsertWithWhereUniqueWithoutUserInput = {
    where: UserInventoryItemWhereUniqueInput
    update: XOR<UserInventoryItemUpdateWithoutUserInput, UserInventoryItemUncheckedUpdateWithoutUserInput>
    create: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput>
  }

  export type UserInventoryItemUpdateWithWhereUniqueWithoutUserInput = {
    where: UserInventoryItemWhereUniqueInput
    data: XOR<UserInventoryItemUpdateWithoutUserInput, UserInventoryItemUncheckedUpdateWithoutUserInput>
  }

  export type UserInventoryItemUpdateManyWithWhereWithoutUserInput = {
    where: UserInventoryItemScalarWhereInput
    data: XOR<UserInventoryItemUpdateManyMutationInput, UserInventoryItemUncheckedUpdateManyWithoutUserInput>
  }

  export type UserInventoryItemScalarWhereInput = {
    AND?: UserInventoryItemScalarWhereInput | UserInventoryItemScalarWhereInput[]
    OR?: UserInventoryItemScalarWhereInput[]
    NOT?: UserInventoryItemScalarWhereInput | UserInventoryItemScalarWhereInput[]
    id?: StringFilter<"UserInventoryItem"> | string
    userId?: StringFilter<"UserInventoryItem"> | string
    itemId?: StringFilter<"UserInventoryItem"> | string
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ChallengeParticipantWhereUniqueInput
    update: XOR<ChallengeParticipantUpdateWithoutUserInput, ChallengeParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput>
  }

  export type ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ChallengeParticipantWhereUniqueInput
    data: XOR<ChallengeParticipantUpdateWithoutUserInput, ChallengeParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ChallengeParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ChallengeParticipantScalarWhereInput
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ChallengeParticipantScalarWhereInput = {
    AND?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
    OR?: ChallengeParticipantScalarWhereInput[]
    NOT?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
    id?: StringFilter<"ChallengeParticipant"> | string
    userId?: StringFilter<"ChallengeParticipant"> | string
    challengeId?: StringFilter<"ChallengeParticipant"> | string
    currentValue?: FloatFilter<"ChallengeParticipant"> | number
    heartsLeft?: IntNullableFilter<"ChallengeParticipant"> | number | null
    isEliminated?: BoolFilter<"ChallengeParticipant"> | boolean
    relayOrder?: IntNullableFilter<"ChallengeParticipant"> | number | null
    relayCompleted?: BoolFilter<"ChallengeParticipant"> | boolean
    joinedAt?: DateTimeFilter<"ChallengeParticipant"> | Date | string
  }

  export type ProgressLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ProgressLogWhereUniqueInput
    update: XOR<ProgressLogUpdateWithoutUserInput, ProgressLogUncheckedUpdateWithoutUserInput>
    create: XOR<ProgressLogCreateWithoutUserInput, ProgressLogUncheckedCreateWithoutUserInput>
  }

  export type ProgressLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ProgressLogWhereUniqueInput
    data: XOR<ProgressLogUpdateWithoutUserInput, ProgressLogUncheckedUpdateWithoutUserInput>
  }

  export type ProgressLogUpdateManyWithWhereWithoutUserInput = {
    where: ProgressLogScalarWhereInput
    data: XOR<ProgressLogUpdateManyMutationInput, ProgressLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ProgressLogScalarWhereInput = {
    AND?: ProgressLogScalarWhereInput | ProgressLogScalarWhereInput[]
    OR?: ProgressLogScalarWhereInput[]
    NOT?: ProgressLogScalarWhereInput | ProgressLogScalarWhereInput[]
    id?: StringFilter<"ProgressLog"> | string
    userId?: StringFilter<"ProgressLog"> | string
    challengeId?: StringFilter<"ProgressLog"> | string
    value?: FloatFilter<"ProgressLog"> | number
    isSuccess?: BoolFilter<"ProgressLog"> | boolean
    note?: StringNullableFilter<"ProgressLog"> | string | null
    date?: DateTimeFilter<"ProgressLog"> | Date | string
    createdAt?: DateTimeFilter<"ProgressLog"> | Date | string
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutUserInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBadgeScalarWhereInput = {
    AND?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    OR?: UserBadgeScalarWhereInput[]
    NOT?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
  }

  export type ChallengeUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ChallengeWhereUniqueInput
    update: XOR<ChallengeUpdateWithoutCreatorInput, ChallengeUncheckedUpdateWithoutCreatorInput>
    create: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput>
  }

  export type ChallengeUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ChallengeWhereUniqueInput
    data: XOR<ChallengeUpdateWithoutCreatorInput, ChallengeUncheckedUpdateWithoutCreatorInput>
  }

  export type ChallengeUpdateManyWithWhereWithoutCreatorInput = {
    where: ChallengeScalarWhereInput
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ChallengeScalarWhereInput = {
    AND?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
    OR?: ChallengeScalarWhereInput[]
    NOT?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
    id?: StringFilter<"Challenge"> | string
    title?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    type?: StringFilter<"Challenge"> | string
    category?: StringFilter<"Challenge"> | string
    targetGoal?: FloatFilter<"Challenge"> | number
    thresholdPct?: FloatNullableFilter<"Challenge"> | number | null
    maxHearts?: IntNullableFilter<"Challenge"> | number | null
    startDate?: DateTimeFilter<"Challenge"> | Date | string
    endDate?: DateTimeFilter<"Challenge"> | Date | string
    creatorId?: StringFilter<"Challenge"> | string
    teamId?: StringNullableFilter<"Challenge"> | string | null
    isPublic?: BoolFilter<"Challenge"> | boolean
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
  }

  export type HabitUpsertWithWhereUniqueWithoutJoinedUsersInput = {
    where: HabitWhereUniqueInput
    update: XOR<HabitUpdateWithoutJoinedUsersInput, HabitUncheckedUpdateWithoutJoinedUsersInput>
    create: XOR<HabitCreateWithoutJoinedUsersInput, HabitUncheckedCreateWithoutJoinedUsersInput>
  }

  export type HabitUpdateWithWhereUniqueWithoutJoinedUsersInput = {
    where: HabitWhereUniqueInput
    data: XOR<HabitUpdateWithoutJoinedUsersInput, HabitUncheckedUpdateWithoutJoinedUsersInput>
  }

  export type HabitUpdateManyWithWhereWithoutJoinedUsersInput = {
    where: HabitScalarWhereInput
    data: XOR<HabitUpdateManyMutationInput, HabitUncheckedUpdateManyWithoutJoinedUsersInput>
  }

  export type HabitScalarWhereInput = {
    AND?: HabitScalarWhereInput | HabitScalarWhereInput[]
    OR?: HabitScalarWhereInput[]
    NOT?: HabitScalarWhereInput | HabitScalarWhereInput[]
    id?: StringFilter<"Habit"> | string
    categoryId?: StringFilter<"Habit"> | string
    title?: StringFilter<"Habit"> | string
    difficulty?: StringFilter<"Habit"> | string
    description?: StringNullableFilter<"Habit"> | string | null
    rating?: FloatFilter<"Habit"> | number
    maturity?: StringNullableFilter<"Habit"> | string | null
    submissionType?: StringFilter<"Habit"> | string
    tips?: StringNullableFilter<"Habit"> | string | null
    preChallengeGuide?: StringNullableFilter<"Habit"> | string | null
    incentives?: StringNullableFilter<"Habit"> | string | null
    createdAt?: DateTimeFilter<"Habit"> | Date | string
    updatedAt?: DateTimeFilter<"Habit"> | Date | string
  }

  export type HabitProofUpsertWithWhereUniqueWithoutUserInput = {
    where: HabitProofWhereUniqueInput
    update: XOR<HabitProofUpdateWithoutUserInput, HabitProofUncheckedUpdateWithoutUserInput>
    create: XOR<HabitProofCreateWithoutUserInput, HabitProofUncheckedCreateWithoutUserInput>
  }

  export type HabitProofUpdateWithWhereUniqueWithoutUserInput = {
    where: HabitProofWhereUniqueInput
    data: XOR<HabitProofUpdateWithoutUserInput, HabitProofUncheckedUpdateWithoutUserInput>
  }

  export type HabitProofUpdateManyWithWhereWithoutUserInput = {
    where: HabitProofScalarWhereInput
    data: XOR<HabitProofUpdateManyMutationInput, HabitProofUncheckedUpdateManyWithoutUserInput>
  }

  export type HabitProofScalarWhereInput = {
    AND?: HabitProofScalarWhereInput | HabitProofScalarWhereInput[]
    OR?: HabitProofScalarWhereInput[]
    NOT?: HabitProofScalarWhereInput | HabitProofScalarWhereInput[]
    id?: StringFilter<"HabitProof"> | string
    userId?: StringFilter<"HabitProof"> | string
    habitId?: StringFilter<"HabitProof"> | string
    imageUrl?: StringFilter<"HabitProof"> | string
    round?: IntFilter<"HabitProof"> | number
    status?: StringFilter<"HabitProof"> | string
    createdAt?: DateTimeFilter<"HabitProof"> | Date | string
    updatedAt?: DateTimeFilter<"HabitProof"> | Date | string
  }

  export type ProofVoteUpsertWithWhereUniqueWithoutVoterInput = {
    where: ProofVoteWhereUniqueInput
    update: XOR<ProofVoteUpdateWithoutVoterInput, ProofVoteUncheckedUpdateWithoutVoterInput>
    create: XOR<ProofVoteCreateWithoutVoterInput, ProofVoteUncheckedCreateWithoutVoterInput>
  }

  export type ProofVoteUpdateWithWhereUniqueWithoutVoterInput = {
    where: ProofVoteWhereUniqueInput
    data: XOR<ProofVoteUpdateWithoutVoterInput, ProofVoteUncheckedUpdateWithoutVoterInput>
  }

  export type ProofVoteUpdateManyWithWhereWithoutVoterInput = {
    where: ProofVoteScalarWhereInput
    data: XOR<ProofVoteUpdateManyMutationInput, ProofVoteUncheckedUpdateManyWithoutVoterInput>
  }

  export type ProofVoteScalarWhereInput = {
    AND?: ProofVoteScalarWhereInput | ProofVoteScalarWhereInput[]
    OR?: ProofVoteScalarWhereInput[]
    NOT?: ProofVoteScalarWhereInput | ProofVoteScalarWhereInput[]
    id?: StringFilter<"ProofVote"> | string
    proofId?: StringFilter<"ProofVote"> | string
    voterId?: StringFilter<"ProofVote"> | string
    voteType?: StringFilter<"ProofVote"> | string
    createdAt?: DateTimeFilter<"ProofVote"> | Date | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutUserInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutUserInput, FriendshipUncheckedUpdateWithoutUserInput>
    create: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutUserInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutUserInput, FriendshipUncheckedUpdateWithoutUserInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutUserInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutUserInput>
  }

  export type FriendshipScalarWhereInput = {
    AND?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    OR?: FriendshipScalarWhereInput[]
    NOT?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    id?: StringFilter<"Friendship"> | string
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    status?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutFriendInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutFriendInput, FriendshipUncheckedUpdateWithoutFriendInput>
    create: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutFriendInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutFriendInput, FriendshipUncheckedUpdateWithoutFriendInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutFriendInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutFriendInput>
  }

  export type HabitInviteUpsertWithWhereUniqueWithoutInviterInput = {
    where: HabitInviteWhereUniqueInput
    update: XOR<HabitInviteUpdateWithoutInviterInput, HabitInviteUncheckedUpdateWithoutInviterInput>
    create: XOR<HabitInviteCreateWithoutInviterInput, HabitInviteUncheckedCreateWithoutInviterInput>
  }

  export type HabitInviteUpdateWithWhereUniqueWithoutInviterInput = {
    where: HabitInviteWhereUniqueInput
    data: XOR<HabitInviteUpdateWithoutInviterInput, HabitInviteUncheckedUpdateWithoutInviterInput>
  }

  export type HabitInviteUpdateManyWithWhereWithoutInviterInput = {
    where: HabitInviteScalarWhereInput
    data: XOR<HabitInviteUpdateManyMutationInput, HabitInviteUncheckedUpdateManyWithoutInviterInput>
  }

  export type HabitInviteScalarWhereInput = {
    AND?: HabitInviteScalarWhereInput | HabitInviteScalarWhereInput[]
    OR?: HabitInviteScalarWhereInput[]
    NOT?: HabitInviteScalarWhereInput | HabitInviteScalarWhereInput[]
    id?: StringFilter<"HabitInvite"> | string
    code?: StringFilter<"HabitInvite"> | string
    habitId?: StringNullableFilter<"HabitInvite"> | string | null
    inviterId?: StringFilter<"HabitInvite"> | string
    inviteePhone?: StringNullableFilter<"HabitInvite"> | string | null
    expiresAt?: DateTimeFilter<"HabitInvite"> | Date | string
    usedById?: StringNullableFilter<"HabitInvite"> | string | null
    createdAt?: DateTimeFilter<"HabitInvite"> | Date | string
  }

  export type HabitUserSettingsUpsertWithWhereUniqueWithoutUserInput = {
    where: HabitUserSettingsWhereUniqueInput
    update: XOR<HabitUserSettingsUpdateWithoutUserInput, HabitUserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<HabitUserSettingsCreateWithoutUserInput, HabitUserSettingsUncheckedCreateWithoutUserInput>
  }

  export type HabitUserSettingsUpdateWithWhereUniqueWithoutUserInput = {
    where: HabitUserSettingsWhereUniqueInput
    data: XOR<HabitUserSettingsUpdateWithoutUserInput, HabitUserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type HabitUserSettingsUpdateManyWithWhereWithoutUserInput = {
    where: HabitUserSettingsScalarWhereInput
    data: XOR<HabitUserSettingsUpdateManyMutationInput, HabitUserSettingsUncheckedUpdateManyWithoutUserInput>
  }

  export type HabitUserSettingsScalarWhereInput = {
    AND?: HabitUserSettingsScalarWhereInput | HabitUserSettingsScalarWhereInput[]
    OR?: HabitUserSettingsScalarWhereInput[]
    NOT?: HabitUserSettingsScalarWhereInput | HabitUserSettingsScalarWhereInput[]
    userId?: StringFilter<"HabitUserSettings"> | string
    habitId?: StringFilter<"HabitUserSettings"> | string
    isFavorite?: BoolFilter<"HabitUserSettings"> | boolean
    notifyMe?: BoolFilter<"HabitUserSettings"> | boolean
    rating?: IntNullableFilter<"HabitUserSettings"> | number | null
    createdAt?: DateTimeFilter<"HabitUserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"HabitUserSettings"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type UserCreateWithoutInventoryInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutInventoryInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutInventoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
  }

  export type UserUpsertWithoutInventoryInput = {
    update: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutTeamMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
  }

  export type ChallengeCreateWithoutTeamInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedChallengesInput
    participants?: ChallengeParticipantCreateNestedManyWithoutChallengeInput
    progressLogs?: ProgressLogCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutTeamInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutTeamInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutTeamInput, ChallengeUncheckedCreateWithoutTeamInput>
  }

  export type ChallengeCreateManyTeamInputEnvelope = {
    data: ChallengeCreateManyTeamInput | ChallengeCreateManyTeamInput[]
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type ChallengeUpsertWithWhereUniqueWithoutTeamInput = {
    where: ChallengeWhereUniqueInput
    update: XOR<ChallengeUpdateWithoutTeamInput, ChallengeUncheckedUpdateWithoutTeamInput>
    create: XOR<ChallengeCreateWithoutTeamInput, ChallengeUncheckedCreateWithoutTeamInput>
  }

  export type ChallengeUpdateWithWhereUniqueWithoutTeamInput = {
    where: ChallengeWhereUniqueInput
    data: XOR<ChallengeUpdateWithoutTeamInput, ChallengeUncheckedUpdateWithoutTeamInput>
  }

  export type ChallengeUpdateManyWithWhereWithoutTeamInput = {
    where: ChallengeScalarWhereInput
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserCreateWithoutTeamMembersInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutTeamMembersInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutTeamMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembersInput, UserUncheckedCreateWithoutTeamMembersInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    inviteCode?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    challenges?: ChallengeCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    inviteCode?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    challenges?: ChallengeUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutTeamMembersInput = {
    update: XOR<UserUpdateWithoutTeamMembersInput, UserUncheckedUpdateWithoutTeamMembersInput>
    create: XOR<UserCreateWithoutTeamMembersInput, UserUncheckedCreateWithoutTeamMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembersInput, UserUncheckedUpdateWithoutTeamMembersInput>
  }

  export type UserUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenges?: ChallengeUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenges?: ChallengeUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserCreateWithoutCreatedChallengesInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutCreatedChallengesInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutCreatedChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedChallengesInput, UserUncheckedCreateWithoutCreatedChallengesInput>
  }

  export type TeamCreateWithoutChallengesInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    inviteCode?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutChallengesInput = {
    id?: string
    name: string
    description?: string | null
    avatarUrl?: string | null
    inviteCode?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutChallengesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutChallengesInput, TeamUncheckedCreateWithoutChallengesInput>
  }

  export type ChallengeParticipantCreateWithoutChallengeInput = {
    id?: string
    currentValue?: number
    heartsLeft?: number | null
    isEliminated?: boolean
    relayOrder?: number | null
    relayCompleted?: boolean
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutParticipationsInput
  }

  export type ChallengeParticipantUncheckedCreateWithoutChallengeInput = {
    id?: string
    userId: string
    currentValue?: number
    heartsLeft?: number | null
    isEliminated?: boolean
    relayOrder?: number | null
    relayCompleted?: boolean
    joinedAt?: Date | string
  }

  export type ChallengeParticipantCreateOrConnectWithoutChallengeInput = {
    where: ChallengeParticipantWhereUniqueInput
    create: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeParticipantCreateManyChallengeInputEnvelope = {
    data: ChallengeParticipantCreateManyChallengeInput | ChallengeParticipantCreateManyChallengeInput[]
  }

  export type ProgressLogCreateWithoutChallengeInput = {
    id?: string
    value: number
    isSuccess?: boolean
    note?: string | null
    date?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProgressLogsInput
  }

  export type ProgressLogUncheckedCreateWithoutChallengeInput = {
    id?: string
    userId: string
    value: number
    isSuccess?: boolean
    note?: string | null
    date?: Date | string
    createdAt?: Date | string
  }

  export type ProgressLogCreateOrConnectWithoutChallengeInput = {
    where: ProgressLogWhereUniqueInput
    create: XOR<ProgressLogCreateWithoutChallengeInput, ProgressLogUncheckedCreateWithoutChallengeInput>
  }

  export type ProgressLogCreateManyChallengeInputEnvelope = {
    data: ProgressLogCreateManyChallengeInput | ProgressLogCreateManyChallengeInput[]
  }

  export type UserUpsertWithoutCreatedChallengesInput = {
    update: XOR<UserUpdateWithoutCreatedChallengesInput, UserUncheckedUpdateWithoutCreatedChallengesInput>
    create: XOR<UserCreateWithoutCreatedChallengesInput, UserUncheckedCreateWithoutCreatedChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedChallengesInput, UserUncheckedUpdateWithoutCreatedChallengesInput>
  }

  export type UserUpdateWithoutCreatedChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type TeamUpsertWithoutChallengesInput = {
    update: XOR<TeamUpdateWithoutChallengesInput, TeamUncheckedUpdateWithoutChallengesInput>
    create: XOR<TeamCreateWithoutChallengesInput, TeamUncheckedCreateWithoutChallengesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutChallengesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutChallengesInput, TeamUncheckedUpdateWithoutChallengesInput>
  }

  export type TeamUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeParticipantWhereUniqueInput
    update: XOR<ChallengeParticipantUpdateWithoutChallengeInput, ChallengeParticipantUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeParticipantWhereUniqueInput
    data: XOR<ChallengeParticipantUpdateWithoutChallengeInput, ChallengeParticipantUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeParticipantScalarWhereInput
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ProgressLogUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ProgressLogWhereUniqueInput
    update: XOR<ProgressLogUpdateWithoutChallengeInput, ProgressLogUncheckedUpdateWithoutChallengeInput>
    create: XOR<ProgressLogCreateWithoutChallengeInput, ProgressLogUncheckedCreateWithoutChallengeInput>
  }

  export type ProgressLogUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ProgressLogWhereUniqueInput
    data: XOR<ProgressLogUpdateWithoutChallengeInput, ProgressLogUncheckedUpdateWithoutChallengeInput>
  }

  export type ProgressLogUpdateManyWithWhereWithoutChallengeInput = {
    where: ProgressLogScalarWhereInput
    data: XOR<ProgressLogUpdateManyMutationInput, ProgressLogUncheckedUpdateManyWithoutChallengeInput>
  }

  export type UserCreateWithoutParticipationsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutParticipationsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutParticipationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParticipationsInput, UserUncheckedCreateWithoutParticipationsInput>
  }

  export type ChallengeCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedChallengesInput
    team?: TeamCreateNestedOneWithoutChallengesInput
    progressLogs?: ProgressLogCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    teamId?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutParticipantsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutParticipantsInput, ChallengeUncheckedCreateWithoutParticipantsInput>
  }

  export type UserUpsertWithoutParticipationsInput = {
    update: XOR<UserUpdateWithoutParticipationsInput, UserUncheckedUpdateWithoutParticipationsInput>
    create: XOR<UserCreateWithoutParticipationsInput, UserUncheckedCreateWithoutParticipationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParticipationsInput, UserUncheckedUpdateWithoutParticipationsInput>
  }

  export type UserUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type ChallengeUpsertWithoutParticipantsInput = {
    update: XOR<ChallengeUpdateWithoutParticipantsInput, ChallengeUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ChallengeCreateWithoutParticipantsInput, ChallengeUncheckedCreateWithoutParticipantsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutParticipantsInput, ChallengeUncheckedUpdateWithoutParticipantsInput>
  }

  export type ChallengeUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedChallengesNestedInput
    team?: TeamUpdateOneWithoutChallengesNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type UserCreateWithoutProgressLogsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutProgressLogsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutProgressLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgressLogsInput, UserUncheckedCreateWithoutProgressLogsInput>
  }

  export type ChallengeCreateWithoutProgressLogsInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedChallengesInput
    team?: TeamCreateNestedOneWithoutChallengesInput
    participants?: ChallengeParticipantCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutProgressLogsInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    teamId?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutProgressLogsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutProgressLogsInput, ChallengeUncheckedCreateWithoutProgressLogsInput>
  }

  export type UserUpsertWithoutProgressLogsInput = {
    update: XOR<UserUpdateWithoutProgressLogsInput, UserUncheckedUpdateWithoutProgressLogsInput>
    create: XOR<UserCreateWithoutProgressLogsInput, UserUncheckedCreateWithoutProgressLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgressLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgressLogsInput, UserUncheckedUpdateWithoutProgressLogsInput>
  }

  export type UserUpdateWithoutProgressLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutProgressLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type ChallengeUpsertWithoutProgressLogsInput = {
    update: XOR<ChallengeUpdateWithoutProgressLogsInput, ChallengeUncheckedUpdateWithoutProgressLogsInput>
    create: XOR<ChallengeCreateWithoutProgressLogsInput, ChallengeUncheckedCreateWithoutProgressLogsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutProgressLogsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutProgressLogsInput, ChallengeUncheckedUpdateWithoutProgressLogsInput>
  }

  export type ChallengeUpdateWithoutProgressLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedChallengesNestedInput
    team?: TeamUpdateOneWithoutChallengesNestedInput
    participants?: ChallengeParticipantUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutProgressLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type UserBadgeCreateWithoutBadgeInput = {
    id?: string
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateWithoutBadgeInput = {
    id?: string
    userId: string
    earnedAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeCreateManyBadgeInputEnvelope = {
    data: UserBadgeCreateManyBadgeInput | UserBadgeCreateManyBadgeInput[]
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type UserCreateWithoutBadgesInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutBadgesInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
  }

  export type BadgeCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
    iconUrl?: string | null
    xpReward?: number
  }

  export type BadgeUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
    iconUrl?: string | null
    xpReward?: number
  }

  export type BadgeCreateOrConnectWithoutUsersInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutBadgesInput = {
    update: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type BadgeUpsertWithoutUsersInput = {
    update: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutUsersInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type BadgeUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xpReward?: IntFieldUpdateOperationsInput | number
  }

  export type BadgeUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    xpReward?: IntFieldUpdateOperationsInput | number
  }

  export type HabitCreateWithoutCategoryInput = {
    id?: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    joinedUsers?: UserCreateNestedManyWithoutJoinedHabitsInput
    proofs?: HabitProofCreateNestedManyWithoutHabitInput
    invites?: HabitInviteCreateNestedManyWithoutHabitInput
    userSettings?: HabitUserSettingsCreateNestedManyWithoutHabitInput
  }

  export type HabitUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    joinedUsers?: UserUncheckedCreateNestedManyWithoutJoinedHabitsInput
    proofs?: HabitProofUncheckedCreateNestedManyWithoutHabitInput
    invites?: HabitInviteUncheckedCreateNestedManyWithoutHabitInput
    userSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutHabitInput
  }

  export type HabitCreateOrConnectWithoutCategoryInput = {
    where: HabitWhereUniqueInput
    create: XOR<HabitCreateWithoutCategoryInput, HabitUncheckedCreateWithoutCategoryInput>
  }

  export type HabitCreateManyCategoryInputEnvelope = {
    data: HabitCreateManyCategoryInput | HabitCreateManyCategoryInput[]
  }

  export type UserCreateWithoutCurrentMountainInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutCurrentMountainInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutCurrentMountainInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCurrentMountainInput, UserUncheckedCreateWithoutCurrentMountainInput>
  }

  export type UserCreateManyCurrentMountainInputEnvelope = {
    data: UserCreateManyCurrentMountainInput | UserCreateManyCurrentMountainInput[]
  }

  export type HabitUpsertWithWhereUniqueWithoutCategoryInput = {
    where: HabitWhereUniqueInput
    update: XOR<HabitUpdateWithoutCategoryInput, HabitUncheckedUpdateWithoutCategoryInput>
    create: XOR<HabitCreateWithoutCategoryInput, HabitUncheckedCreateWithoutCategoryInput>
  }

  export type HabitUpdateWithWhereUniqueWithoutCategoryInput = {
    where: HabitWhereUniqueInput
    data: XOR<HabitUpdateWithoutCategoryInput, HabitUncheckedUpdateWithoutCategoryInput>
  }

  export type HabitUpdateManyWithWhereWithoutCategoryInput = {
    where: HabitScalarWhereInput
    data: XOR<HabitUpdateManyMutationInput, HabitUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserUpsertWithWhereUniqueWithoutCurrentMountainInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCurrentMountainInput, UserUncheckedUpdateWithoutCurrentMountainInput>
    create: XOR<UserCreateWithoutCurrentMountainInput, UserUncheckedCreateWithoutCurrentMountainInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCurrentMountainInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCurrentMountainInput, UserUncheckedUpdateWithoutCurrentMountainInput>
  }

  export type UserUpdateManyWithWhereWithoutCurrentMountainInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCurrentMountainInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    birthday?: DateTimeNullableFilter<"User"> | Date | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isPublic?: BoolFilter<"User"> | boolean
    xp?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    coins?: IntFilter<"User"> | number
    totalAchievements?: IntFilter<"User"> | number
    currentMountainId?: StringNullableFilter<"User"> | string | null
    currentAltitude?: FloatFilter<"User"> | number
    lastActive?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type HabitCategoryCreateWithoutHabitsInput = {
    id?: string
    name: string
    biomeType: string
    mountainIcon: string
    mountainImage?: string | null
    primaryColor: string
    secondaryColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activeClimbers?: UserCreateNestedManyWithoutCurrentMountainInput
  }

  export type HabitCategoryUncheckedCreateWithoutHabitsInput = {
    id?: string
    name: string
    biomeType: string
    mountainIcon: string
    mountainImage?: string | null
    primaryColor: string
    secondaryColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activeClimbers?: UserUncheckedCreateNestedManyWithoutCurrentMountainInput
  }

  export type HabitCategoryCreateOrConnectWithoutHabitsInput = {
    where: HabitCategoryWhereUniqueInput
    create: XOR<HabitCategoryCreateWithoutHabitsInput, HabitCategoryUncheckedCreateWithoutHabitsInput>
  }

  export type UserCreateWithoutJoinedHabitsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutJoinedHabitsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutJoinedHabitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJoinedHabitsInput, UserUncheckedCreateWithoutJoinedHabitsInput>
  }

  export type HabitProofCreateWithoutHabitInput = {
    id?: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHabitProofsInput
    votes?: ProofVoteCreateNestedManyWithoutProofInput
  }

  export type HabitProofUncheckedCreateWithoutHabitInput = {
    id?: string
    userId: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ProofVoteUncheckedCreateNestedManyWithoutProofInput
  }

  export type HabitProofCreateOrConnectWithoutHabitInput = {
    where: HabitProofWhereUniqueInput
    create: XOR<HabitProofCreateWithoutHabitInput, HabitProofUncheckedCreateWithoutHabitInput>
  }

  export type HabitProofCreateManyHabitInputEnvelope = {
    data: HabitProofCreateManyHabitInput | HabitProofCreateManyHabitInput[]
  }

  export type HabitInviteCreateWithoutHabitInput = {
    id?: string
    code: string
    inviteePhone?: string | null
    expiresAt: Date | string
    usedById?: string | null
    createdAt?: Date | string
    inviter: UserCreateNestedOneWithoutHabitInvitesInput
  }

  export type HabitInviteUncheckedCreateWithoutHabitInput = {
    id?: string
    code: string
    inviterId: string
    inviteePhone?: string | null
    expiresAt: Date | string
    usedById?: string | null
    createdAt?: Date | string
  }

  export type HabitInviteCreateOrConnectWithoutHabitInput = {
    where: HabitInviteWhereUniqueInput
    create: XOR<HabitInviteCreateWithoutHabitInput, HabitInviteUncheckedCreateWithoutHabitInput>
  }

  export type HabitInviteCreateManyHabitInputEnvelope = {
    data: HabitInviteCreateManyHabitInput | HabitInviteCreateManyHabitInput[]
  }

  export type HabitUserSettingsCreateWithoutHabitInput = {
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHabitSettingsInput
  }

  export type HabitUserSettingsUncheckedCreateWithoutHabitInput = {
    userId: string
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUserSettingsCreateOrConnectWithoutHabitInput = {
    where: HabitUserSettingsWhereUniqueInput
    create: XOR<HabitUserSettingsCreateWithoutHabitInput, HabitUserSettingsUncheckedCreateWithoutHabitInput>
  }

  export type HabitUserSettingsCreateManyHabitInputEnvelope = {
    data: HabitUserSettingsCreateManyHabitInput | HabitUserSettingsCreateManyHabitInput[]
  }

  export type HabitCategoryUpsertWithoutHabitsInput = {
    update: XOR<HabitCategoryUpdateWithoutHabitsInput, HabitCategoryUncheckedUpdateWithoutHabitsInput>
    create: XOR<HabitCategoryCreateWithoutHabitsInput, HabitCategoryUncheckedCreateWithoutHabitsInput>
    where?: HabitCategoryWhereInput
  }

  export type HabitCategoryUpdateToOneWithWhereWithoutHabitsInput = {
    where?: HabitCategoryWhereInput
    data: XOR<HabitCategoryUpdateWithoutHabitsInput, HabitCategoryUncheckedUpdateWithoutHabitsInput>
  }

  export type HabitCategoryUpdateWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biomeType?: StringFieldUpdateOperationsInput | string
    mountainIcon?: StringFieldUpdateOperationsInput | string
    mountainImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeClimbers?: UserUpdateManyWithoutCurrentMountainNestedInput
  }

  export type HabitCategoryUncheckedUpdateWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biomeType?: StringFieldUpdateOperationsInput | string
    mountainIcon?: StringFieldUpdateOperationsInput | string
    mountainImage?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activeClimbers?: UserUncheckedUpdateManyWithoutCurrentMountainNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutJoinedHabitsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutJoinedHabitsInput, UserUncheckedUpdateWithoutJoinedHabitsInput>
    create: XOR<UserCreateWithoutJoinedHabitsInput, UserUncheckedCreateWithoutJoinedHabitsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutJoinedHabitsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutJoinedHabitsInput, UserUncheckedUpdateWithoutJoinedHabitsInput>
  }

  export type UserUpdateManyWithWhereWithoutJoinedHabitsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutJoinedHabitsInput>
  }

  export type HabitProofUpsertWithWhereUniqueWithoutHabitInput = {
    where: HabitProofWhereUniqueInput
    update: XOR<HabitProofUpdateWithoutHabitInput, HabitProofUncheckedUpdateWithoutHabitInput>
    create: XOR<HabitProofCreateWithoutHabitInput, HabitProofUncheckedCreateWithoutHabitInput>
  }

  export type HabitProofUpdateWithWhereUniqueWithoutHabitInput = {
    where: HabitProofWhereUniqueInput
    data: XOR<HabitProofUpdateWithoutHabitInput, HabitProofUncheckedUpdateWithoutHabitInput>
  }

  export type HabitProofUpdateManyWithWhereWithoutHabitInput = {
    where: HabitProofScalarWhereInput
    data: XOR<HabitProofUpdateManyMutationInput, HabitProofUncheckedUpdateManyWithoutHabitInput>
  }

  export type HabitInviteUpsertWithWhereUniqueWithoutHabitInput = {
    where: HabitInviteWhereUniqueInput
    update: XOR<HabitInviteUpdateWithoutHabitInput, HabitInviteUncheckedUpdateWithoutHabitInput>
    create: XOR<HabitInviteCreateWithoutHabitInput, HabitInviteUncheckedCreateWithoutHabitInput>
  }

  export type HabitInviteUpdateWithWhereUniqueWithoutHabitInput = {
    where: HabitInviteWhereUniqueInput
    data: XOR<HabitInviteUpdateWithoutHabitInput, HabitInviteUncheckedUpdateWithoutHabitInput>
  }

  export type HabitInviteUpdateManyWithWhereWithoutHabitInput = {
    where: HabitInviteScalarWhereInput
    data: XOR<HabitInviteUpdateManyMutationInput, HabitInviteUncheckedUpdateManyWithoutHabitInput>
  }

  export type HabitUserSettingsUpsertWithWhereUniqueWithoutHabitInput = {
    where: HabitUserSettingsWhereUniqueInput
    update: XOR<HabitUserSettingsUpdateWithoutHabitInput, HabitUserSettingsUncheckedUpdateWithoutHabitInput>
    create: XOR<HabitUserSettingsCreateWithoutHabitInput, HabitUserSettingsUncheckedCreateWithoutHabitInput>
  }

  export type HabitUserSettingsUpdateWithWhereUniqueWithoutHabitInput = {
    where: HabitUserSettingsWhereUniqueInput
    data: XOR<HabitUserSettingsUpdateWithoutHabitInput, HabitUserSettingsUncheckedUpdateWithoutHabitInput>
  }

  export type HabitUserSettingsUpdateManyWithWhereWithoutHabitInput = {
    where: HabitUserSettingsScalarWhereInput
    data: XOR<HabitUserSettingsUpdateManyMutationInput, HabitUserSettingsUncheckedUpdateManyWithoutHabitInput>
  }

  export type UserCreateWithoutHabitSettingsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutHabitSettingsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutHabitSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHabitSettingsInput, UserUncheckedCreateWithoutHabitSettingsInput>
  }

  export type HabitCreateWithoutUserSettingsInput = {
    id?: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: HabitCategoryCreateNestedOneWithoutHabitsInput
    joinedUsers?: UserCreateNestedManyWithoutJoinedHabitsInput
    proofs?: HabitProofCreateNestedManyWithoutHabitInput
    invites?: HabitInviteCreateNestedManyWithoutHabitInput
  }

  export type HabitUncheckedCreateWithoutUserSettingsInput = {
    id?: string
    categoryId: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    joinedUsers?: UserUncheckedCreateNestedManyWithoutJoinedHabitsInput
    proofs?: HabitProofUncheckedCreateNestedManyWithoutHabitInput
    invites?: HabitInviteUncheckedCreateNestedManyWithoutHabitInput
  }

  export type HabitCreateOrConnectWithoutUserSettingsInput = {
    where: HabitWhereUniqueInput
    create: XOR<HabitCreateWithoutUserSettingsInput, HabitUncheckedCreateWithoutUserSettingsInput>
  }

  export type UserUpsertWithoutHabitSettingsInput = {
    update: XOR<UserUpdateWithoutHabitSettingsInput, UserUncheckedUpdateWithoutHabitSettingsInput>
    create: XOR<UserCreateWithoutHabitSettingsInput, UserUncheckedCreateWithoutHabitSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHabitSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHabitSettingsInput, UserUncheckedUpdateWithoutHabitSettingsInput>
  }

  export type UserUpdateWithoutHabitSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutHabitSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type HabitUpsertWithoutUserSettingsInput = {
    update: XOR<HabitUpdateWithoutUserSettingsInput, HabitUncheckedUpdateWithoutUserSettingsInput>
    create: XOR<HabitCreateWithoutUserSettingsInput, HabitUncheckedCreateWithoutUserSettingsInput>
    where?: HabitWhereInput
  }

  export type HabitUpdateToOneWithWhereWithoutUserSettingsInput = {
    where?: HabitWhereInput
    data: XOR<HabitUpdateWithoutUserSettingsInput, HabitUncheckedUpdateWithoutUserSettingsInput>
  }

  export type HabitUpdateWithoutUserSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: HabitCategoryUpdateOneRequiredWithoutHabitsNestedInput
    joinedUsers?: UserUpdateManyWithoutJoinedHabitsNestedInput
    proofs?: HabitProofUpdateManyWithoutHabitNestedInput
    invites?: HabitInviteUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateWithoutUserSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedUsers?: UserUncheckedUpdateManyWithoutJoinedHabitsNestedInput
    proofs?: HabitProofUncheckedUpdateManyWithoutHabitNestedInput
    invites?: HabitInviteUncheckedUpdateManyWithoutHabitNestedInput
  }

  export type UserCreateWithoutHabitProofsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutHabitProofsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutHabitProofsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHabitProofsInput, UserUncheckedCreateWithoutHabitProofsInput>
  }

  export type HabitCreateWithoutProofsInput = {
    id?: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: HabitCategoryCreateNestedOneWithoutHabitsInput
    joinedUsers?: UserCreateNestedManyWithoutJoinedHabitsInput
    invites?: HabitInviteCreateNestedManyWithoutHabitInput
    userSettings?: HabitUserSettingsCreateNestedManyWithoutHabitInput
  }

  export type HabitUncheckedCreateWithoutProofsInput = {
    id?: string
    categoryId: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    joinedUsers?: UserUncheckedCreateNestedManyWithoutJoinedHabitsInput
    invites?: HabitInviteUncheckedCreateNestedManyWithoutHabitInput
    userSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutHabitInput
  }

  export type HabitCreateOrConnectWithoutProofsInput = {
    where: HabitWhereUniqueInput
    create: XOR<HabitCreateWithoutProofsInput, HabitUncheckedCreateWithoutProofsInput>
  }

  export type ProofVoteCreateWithoutProofInput = {
    id?: string
    voteType: string
    createdAt?: Date | string
    voter: UserCreateNestedOneWithoutProofVotesInput
  }

  export type ProofVoteUncheckedCreateWithoutProofInput = {
    id?: string
    voterId: string
    voteType: string
    createdAt?: Date | string
  }

  export type ProofVoteCreateOrConnectWithoutProofInput = {
    where: ProofVoteWhereUniqueInput
    create: XOR<ProofVoteCreateWithoutProofInput, ProofVoteUncheckedCreateWithoutProofInput>
  }

  export type ProofVoteCreateManyProofInputEnvelope = {
    data: ProofVoteCreateManyProofInput | ProofVoteCreateManyProofInput[]
  }

  export type UserUpsertWithoutHabitProofsInput = {
    update: XOR<UserUpdateWithoutHabitProofsInput, UserUncheckedUpdateWithoutHabitProofsInput>
    create: XOR<UserCreateWithoutHabitProofsInput, UserUncheckedCreateWithoutHabitProofsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHabitProofsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHabitProofsInput, UserUncheckedUpdateWithoutHabitProofsInput>
  }

  export type UserUpdateWithoutHabitProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutHabitProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type HabitUpsertWithoutProofsInput = {
    update: XOR<HabitUpdateWithoutProofsInput, HabitUncheckedUpdateWithoutProofsInput>
    create: XOR<HabitCreateWithoutProofsInput, HabitUncheckedCreateWithoutProofsInput>
    where?: HabitWhereInput
  }

  export type HabitUpdateToOneWithWhereWithoutProofsInput = {
    where?: HabitWhereInput
    data: XOR<HabitUpdateWithoutProofsInput, HabitUncheckedUpdateWithoutProofsInput>
  }

  export type HabitUpdateWithoutProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: HabitCategoryUpdateOneRequiredWithoutHabitsNestedInput
    joinedUsers?: UserUpdateManyWithoutJoinedHabitsNestedInput
    invites?: HabitInviteUpdateManyWithoutHabitNestedInput
    userSettings?: HabitUserSettingsUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateWithoutProofsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedUsers?: UserUncheckedUpdateManyWithoutJoinedHabitsNestedInput
    invites?: HabitInviteUncheckedUpdateManyWithoutHabitNestedInput
    userSettings?: HabitUserSettingsUncheckedUpdateManyWithoutHabitNestedInput
  }

  export type ProofVoteUpsertWithWhereUniqueWithoutProofInput = {
    where: ProofVoteWhereUniqueInput
    update: XOR<ProofVoteUpdateWithoutProofInput, ProofVoteUncheckedUpdateWithoutProofInput>
    create: XOR<ProofVoteCreateWithoutProofInput, ProofVoteUncheckedCreateWithoutProofInput>
  }

  export type ProofVoteUpdateWithWhereUniqueWithoutProofInput = {
    where: ProofVoteWhereUniqueInput
    data: XOR<ProofVoteUpdateWithoutProofInput, ProofVoteUncheckedUpdateWithoutProofInput>
  }

  export type ProofVoteUpdateManyWithWhereWithoutProofInput = {
    where: ProofVoteScalarWhereInput
    data: XOR<ProofVoteUpdateManyMutationInput, ProofVoteUncheckedUpdateManyWithoutProofInput>
  }

  export type HabitProofCreateWithoutVotesInput = {
    id?: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHabitProofsInput
    habit: HabitCreateNestedOneWithoutProofsInput
  }

  export type HabitProofUncheckedCreateWithoutVotesInput = {
    id?: string
    userId: string
    habitId: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitProofCreateOrConnectWithoutVotesInput = {
    where: HabitProofWhereUniqueInput
    create: XOR<HabitProofCreateWithoutVotesInput, HabitProofUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutProofVotesInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutProofVotesInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutProofVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProofVotesInput, UserUncheckedCreateWithoutProofVotesInput>
  }

  export type HabitProofUpsertWithoutVotesInput = {
    update: XOR<HabitProofUpdateWithoutVotesInput, HabitProofUncheckedUpdateWithoutVotesInput>
    create: XOR<HabitProofCreateWithoutVotesInput, HabitProofUncheckedCreateWithoutVotesInput>
    where?: HabitProofWhereInput
  }

  export type HabitProofUpdateToOneWithWhereWithoutVotesInput = {
    where?: HabitProofWhereInput
    data: XOR<HabitProofUpdateWithoutVotesInput, HabitProofUncheckedUpdateWithoutVotesInput>
  }

  export type HabitProofUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHabitProofsNestedInput
    habit?: HabitUpdateOneRequiredWithoutProofsNestedInput
  }

  export type HabitProofUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutProofVotesInput = {
    update: XOR<UserUpdateWithoutProofVotesInput, UserUncheckedUpdateWithoutProofVotesInput>
    create: XOR<UserCreateWithoutProofVotesInput, UserUncheckedCreateWithoutProofVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProofVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProofVotesInput, UserUncheckedUpdateWithoutProofVotesInput>
  }

  export type UserUpdateWithoutProofVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutProofVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type UserCreateWithoutFriendsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutFriendsInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutFriendsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendsInput, UserUncheckedCreateWithoutFriendsInput>
  }

  export type UserCreateWithoutFriendOfInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutFriendOfInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutFriendOfInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendOfInput, UserUncheckedCreateWithoutFriendOfInput>
  }

  export type UserUpsertWithoutFriendsInput = {
    update: XOR<UserUpdateWithoutFriendsInput, UserUncheckedUpdateWithoutFriendsInput>
    create: XOR<UserCreateWithoutFriendsInput, UserUncheckedCreateWithoutFriendsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendsInput, UserUncheckedUpdateWithoutFriendsInput>
  }

  export type UserUpdateWithoutFriendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type UserUpsertWithoutFriendOfInput = {
    update: XOR<UserUpdateWithoutFriendOfInput, UserUncheckedUpdateWithoutFriendOfInput>
    create: XOR<UserCreateWithoutFriendOfInput, UserUncheckedCreateWithoutFriendOfInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendOfInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendOfInput, UserUncheckedUpdateWithoutFriendOfInput>
  }

  export type UserUpdateWithoutFriendOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitInvites?: HabitInviteUncheckedCreateNestedManyWithoutInviterInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type HabitCreateWithoutInvitesInput = {
    id?: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: HabitCategoryCreateNestedOneWithoutHabitsInput
    joinedUsers?: UserCreateNestedManyWithoutJoinedHabitsInput
    proofs?: HabitProofCreateNestedManyWithoutHabitInput
    userSettings?: HabitUserSettingsCreateNestedManyWithoutHabitInput
  }

  export type HabitUncheckedCreateWithoutInvitesInput = {
    id?: string
    categoryId: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    joinedUsers?: UserUncheckedCreateNestedManyWithoutJoinedHabitsInput
    proofs?: HabitProofUncheckedCreateNestedManyWithoutHabitInput
    userSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutHabitInput
  }

  export type HabitCreateOrConnectWithoutInvitesInput = {
    where: HabitWhereUniqueInput
    create: XOR<HabitCreateWithoutInvitesInput, HabitUncheckedCreateWithoutInvitesInput>
  }

  export type UserCreateWithoutHabitInvitesInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMountain?: HabitCategoryCreateNestedOneWithoutActiveClimbersInput
    inventory?: UserInventoryItemCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteCreateNestedManyWithoutVoterInput
    friends?: FriendshipCreateNestedManyWithoutUserInput
    friendOf?: FriendshipCreateNestedManyWithoutFriendInput
    habitSettings?: HabitUserSettingsCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowingInput
    following?: FollowCreateNestedManyWithoutFollowerInput
  }

  export type UserUncheckedCreateWithoutHabitInvitesInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentMountainId?: string | null
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    participations?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    progressLogs?: ProgressLogUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    createdChallenges?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    joinedHabits?: HabitUncheckedCreateNestedManyWithoutJoinedUsersInput
    habitProofs?: HabitProofUncheckedCreateNestedManyWithoutUserInput
    proofVotes?: ProofVoteUncheckedCreateNestedManyWithoutVoterInput
    friends?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendOf?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    habitSettings?: HabitUserSettingsUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowerInput
  }

  export type UserCreateOrConnectWithoutHabitInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHabitInvitesInput, UserUncheckedCreateWithoutHabitInvitesInput>
  }

  export type HabitUpsertWithoutInvitesInput = {
    update: XOR<HabitUpdateWithoutInvitesInput, HabitUncheckedUpdateWithoutInvitesInput>
    create: XOR<HabitCreateWithoutInvitesInput, HabitUncheckedCreateWithoutInvitesInput>
    where?: HabitWhereInput
  }

  export type HabitUpdateToOneWithWhereWithoutInvitesInput = {
    where?: HabitWhereInput
    data: XOR<HabitUpdateWithoutInvitesInput, HabitUncheckedUpdateWithoutInvitesInput>
  }

  export type HabitUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: HabitCategoryUpdateOneRequiredWithoutHabitsNestedInput
    joinedUsers?: UserUpdateManyWithoutJoinedHabitsNestedInput
    proofs?: HabitProofUpdateManyWithoutHabitNestedInput
    userSettings?: HabitUserSettingsUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedUsers?: UserUncheckedUpdateManyWithoutJoinedHabitsNestedInput
    proofs?: HabitProofUncheckedUpdateManyWithoutHabitNestedInput
    userSettings?: HabitUserSettingsUncheckedUpdateManyWithoutHabitNestedInput
  }

  export type UserUpsertWithoutHabitInvitesInput = {
    update: XOR<UserUpdateWithoutHabitInvitesInput, UserUncheckedUpdateWithoutHabitInvitesInput>
    create: XOR<UserCreateWithoutHabitInvitesInput, UserUncheckedCreateWithoutHabitInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHabitInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHabitInvitesInput, UserUncheckedUpdateWithoutHabitInvitesInput>
  }

  export type UserUpdateWithoutHabitInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutHabitInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type UserInventoryItemCreateManyUserInput = {
    id?: string
    itemId: string
  }

  export type TeamMemberCreateManyUserInput = {
    id?: string
    teamId: string
    role?: string
    joinedAt?: Date | string
  }

  export type ChallengeParticipantCreateManyUserInput = {
    id?: string
    challengeId: string
    currentValue?: number
    heartsLeft?: number | null
    isEliminated?: boolean
    relayOrder?: number | null
    relayCompleted?: boolean
    joinedAt?: Date | string
  }

  export type ProgressLogCreateManyUserInput = {
    id?: string
    challengeId: string
    value: number
    isSuccess?: boolean
    note?: string | null
    date?: Date | string
    createdAt?: Date | string
  }

  export type UserBadgeCreateManyUserInput = {
    id?: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type ChallengeCreateManyCreatorInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    teamId?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitProofCreateManyUserInput = {
    id?: string
    habitId: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProofVoteCreateManyVoterInput = {
    id?: string
    proofId: string
    voteType: string
    createdAt?: Date | string
  }

  export type FriendshipCreateManyUserInput = {
    id?: string
    friendId: string
    status?: string
    createdAt?: Date | string
  }

  export type FriendshipCreateManyFriendInput = {
    id?: string
    userId: string
    status?: string
    createdAt?: Date | string
  }

  export type HabitInviteCreateManyInviterInput = {
    id?: string
    code: string
    habitId?: string | null
    inviteePhone?: string | null
    expiresAt: Date | string
    usedById?: string | null
    createdAt?: Date | string
  }

  export type HabitUserSettingsCreateManyUserInput = {
    habitId: string
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateManyFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowCreateManyFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type UserInventoryItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type UserInventoryItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type UserInventoryItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    heartsLeft?: NullableIntFieldUpdateOperationsInput | number | null
    isEliminated?: BoolFieldUpdateOperationsInput | boolean
    relayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    relayCompleted?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ChallengeParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    heartsLeft?: NullableIntFieldUpdateOperationsInput | number | null
    isEliminated?: BoolFieldUpdateOperationsInput | boolean
    relayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    relayCompleted?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    heartsLeft?: NullableIntFieldUpdateOperationsInput | number | null
    isEliminated?: BoolFieldUpdateOperationsInput | boolean
    relayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    relayCompleted?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutProgressLogsNestedInput
  }

  export type ProgressLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutChallengesNestedInput
    participants?: ChallengeParticipantUpdateManyWithoutChallengeNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUpdateWithoutJoinedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: HabitCategoryUpdateOneRequiredWithoutHabitsNestedInput
    proofs?: HabitProofUpdateManyWithoutHabitNestedInput
    invites?: HabitInviteUpdateManyWithoutHabitNestedInput
    userSettings?: HabitUserSettingsUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateWithoutJoinedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proofs?: HabitProofUncheckedUpdateManyWithoutHabitNestedInput
    invites?: HabitInviteUncheckedUpdateManyWithoutHabitNestedInput
    userSettings?: HabitUserSettingsUncheckedUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateManyWithoutJoinedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitProofUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habit?: HabitUpdateOneRequiredWithoutProofsNestedInput
    votes?: ProofVoteUpdateManyWithoutProofNestedInput
  }

  export type HabitProofUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ProofVoteUncheckedUpdateManyWithoutProofNestedInput
  }

  export type HabitProofUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProofVoteUpdateWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proof?: HabitProofUpdateOneRequiredWithoutVotesNestedInput
  }

  export type ProofVoteUncheckedUpdateWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    proofId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProofVoteUncheckedUpdateManyWithoutVoterInput = {
    id?: StringFieldUpdateOperationsInput | string
    proofId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friend?: UserUpdateOneRequiredWithoutFriendOfNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFriendsNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitInviteUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habit?: HabitUpdateOneWithoutInvitesNestedInput
  }

  export type HabitInviteUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    habitId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitInviteUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    habitId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUserSettingsUpdateWithoutUserInput = {
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notifyMe?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habit?: HabitUpdateOneRequiredWithoutUserSettingsNestedInput
  }

  export type HabitUserSettingsUncheckedUpdateWithoutUserInput = {
    habitId?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notifyMe?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUserSettingsUncheckedUpdateManyWithoutUserInput = {
    habitId?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notifyMe?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type ChallengeCreateManyTeamInput = {
    id?: string
    title: string
    description: string
    type: string
    category: string
    targetGoal: number
    thresholdPct?: number | null
    maxHearts?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedChallengesNestedInput
    participants?: ChallengeParticipantUpdateManyWithoutChallengeNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    targetGoal?: FloatFieldUpdateOperationsInput | number
    thresholdPct?: NullableFloatFieldUpdateOperationsInput | number | null
    maxHearts?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantCreateManyChallengeInput = {
    id?: string
    userId: string
    currentValue?: number
    heartsLeft?: number | null
    isEliminated?: boolean
    relayOrder?: number | null
    relayCompleted?: boolean
    joinedAt?: Date | string
  }

  export type ProgressLogCreateManyChallengeInput = {
    id?: string
    userId: string
    value: number
    isSuccess?: boolean
    note?: string | null
    date?: Date | string
    createdAt?: Date | string
  }

  export type ChallengeParticipantUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    heartsLeft?: NullableIntFieldUpdateOperationsInput | number | null
    isEliminated?: BoolFieldUpdateOperationsInput | boolean
    relayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    relayCompleted?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type ChallengeParticipantUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    heartsLeft?: NullableIntFieldUpdateOperationsInput | number | null
    isEliminated?: BoolFieldUpdateOperationsInput | boolean
    relayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    relayCompleted?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentValue?: FloatFieldUpdateOperationsInput | number
    heartsLeft?: NullableIntFieldUpdateOperationsInput | number | null
    isEliminated?: BoolFieldUpdateOperationsInput | boolean
    relayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    relayCompleted?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressLogUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgressLogsNestedInput
  }

  export type ProgressLogUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgressLogUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyBadgeInput = {
    id?: string
    userId: string
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitCreateManyCategoryInput = {
    id?: string
    title: string
    difficulty: string
    description?: string | null
    rating?: number
    maturity?: string | null
    submissionType?: string
    tips?: string | null
    preChallengeGuide?: string | null
    incentives?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyCurrentMountainInput = {
    id?: string
    phoneNumber?: string | null
    username: string
    password?: string | null
    email?: string | null
    gender?: string | null
    birthday?: Date | string | null
    bio?: string | null
    avatarUrl?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isPublic?: boolean
    xp?: number
    level?: number
    coins?: number
    totalAchievements?: number
    currentAltitude?: number
    lastActive?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedUsers?: UserUpdateManyWithoutJoinedHabitsNestedInput
    proofs?: HabitProofUpdateManyWithoutHabitNestedInput
    invites?: HabitInviteUpdateManyWithoutHabitNestedInput
    userSettings?: HabitUserSettingsUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinedUsers?: UserUncheckedUpdateManyWithoutJoinedHabitsNestedInput
    proofs?: HabitProofUncheckedUpdateManyWithoutHabitNestedInput
    invites?: HabitInviteUncheckedUpdateManyWithoutHabitNestedInput
    userSettings?: HabitUserSettingsUncheckedUpdateManyWithoutHabitNestedInput
  }

  export type HabitUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    maturity?: NullableStringFieldUpdateOperationsInput | string | null
    submissionType?: StringFieldUpdateOperationsInput | string
    tips?: NullableStringFieldUpdateOperationsInput | string | null
    preChallengeGuide?: NullableStringFieldUpdateOperationsInput | string | null
    incentives?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCurrentMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutCurrentMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    joinedHabits?: HabitUncheckedUpdateManyWithoutJoinedUsersNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCurrentMountainInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitProofCreateManyHabitInput = {
    id?: string
    userId: string
    imageUrl: string
    round?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HabitInviteCreateManyHabitInput = {
    id?: string
    code: string
    inviterId: string
    inviteePhone?: string | null
    expiresAt: Date | string
    usedById?: string | null
    createdAt?: Date | string
  }

  export type HabitUserSettingsCreateManyHabitInput = {
    userId: string
    isFavorite?: boolean
    notifyMe?: boolean
    rating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutJoinedHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMountain?: HabitCategoryUpdateOneWithoutActiveClimbersNestedInput
    inventory?: UserInventoryItemUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUpdateManyWithoutCreatorNestedInput
    habitProofs?: HabitProofUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowingNestedInput
    following?: FollowUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateWithoutJoinedHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    participations?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    progressLogs?: ProgressLogUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    createdChallenges?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    habitProofs?: HabitProofUncheckedUpdateManyWithoutUserNestedInput
    proofVotes?: ProofVoteUncheckedUpdateManyWithoutVoterNestedInput
    friends?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendOf?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    habitInvites?: HabitInviteUncheckedUpdateManyWithoutInviterNestedInput
    habitSettings?: HabitUserSettingsUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutJoinedHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    totalAchievements?: IntFieldUpdateOperationsInput | number
    currentMountainId?: NullableStringFieldUpdateOperationsInput | string | null
    currentAltitude?: FloatFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitProofUpdateWithoutHabitInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHabitProofsNestedInput
    votes?: ProofVoteUpdateManyWithoutProofNestedInput
  }

  export type HabitProofUncheckedUpdateWithoutHabitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ProofVoteUncheckedUpdateManyWithoutProofNestedInput
  }

  export type HabitProofUncheckedUpdateManyWithoutHabitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitInviteUpdateWithoutHabitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserUpdateOneRequiredWithoutHabitInvitesNestedInput
  }

  export type HabitInviteUncheckedUpdateWithoutHabitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitInviteUncheckedUpdateManyWithoutHabitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUserSettingsUpdateWithoutHabitInput = {
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notifyMe?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHabitSettingsNestedInput
  }

  export type HabitUserSettingsUncheckedUpdateWithoutHabitInput = {
    userId?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notifyMe?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HabitUserSettingsUncheckedUpdateManyWithoutHabitInput = {
    userId?: StringFieldUpdateOperationsInput | string
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    notifyMe?: BoolFieldUpdateOperationsInput | boolean
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProofVoteCreateManyProofInput = {
    id?: string
    voterId: string
    voteType: string
    createdAt?: Date | string
  }

  export type ProofVoteUpdateWithoutProofInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voter?: UserUpdateOneRequiredWithoutProofVotesNestedInput
  }

  export type ProofVoteUncheckedUpdateWithoutProofInput = {
    id?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProofVoteUncheckedUpdateManyWithoutProofInput = {
    id?: StringFieldUpdateOperationsInput | string
    voterId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeCountOutputTypeDefaultArgs instead
     */
    export type ChallengeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeCountOutputTypeDefaultArgs instead
     */
    export type BadgeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitCategoryCountOutputTypeDefaultArgs instead
     */
    export type HabitCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitCountOutputTypeDefaultArgs instead
     */
    export type HabitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitProofCountOutputTypeDefaultArgs instead
     */
    export type HabitProofCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitProofCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserInventoryItemDefaultArgs instead
     */
    export type UserInventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserInventoryItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamDefaultArgs instead
     */
    export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamMemberDefaultArgs instead
     */
    export type TeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeDefaultArgs instead
     */
    export type ChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeParticipantDefaultArgs instead
     */
    export type ChallengeParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgressLogDefaultArgs instead
     */
    export type ProgressLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgressLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeDefaultArgs instead
     */
    export type BadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBadgeDefaultArgs instead
     */
    export type UserBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitCategoryDefaultArgs instead
     */
    export type HabitCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitDefaultArgs instead
     */
    export type HabitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitUserSettingsDefaultArgs instead
     */
    export type HabitUserSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitUserSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitProofDefaultArgs instead
     */
    export type HabitProofArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitProofDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProofVoteDefaultArgs instead
     */
    export type ProofVoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProofVoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FriendshipDefaultArgs instead
     */
    export type FriendshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FriendshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FollowDefaultArgs instead
     */
    export type FollowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FollowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitInviteDefaultArgs instead
     */
    export type HabitInviteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitInviteDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}